# Simulator Independent Coverage

## Section 3: `cover` Implementation for Simulators

### Treadle

**Claim:**
> Adding support
> for the cover statement took less than one work week
> and around 200 lines of Scala code.

`cover` support was added to treadle in this PR:
https://github.com/chipsalliance/treadle/pull/296

### Verilator

Support for reading and interpreting the coverage data from Verilator
was added to the `chiseltest` library in this PR:
https://github.com/ucb-bar/chiseltest/pull/281

Wilson Snyder added an option to the Verilator C++ API to report coverage
on a per instance instead of a per module basis:
https://github.com/verilator/verilator/issues/2793#issuecomment-803228754


**Claim:**
> Our interface code thus generates the exact same map
> from cover statement names to counts as provided by
> our native implementation for Treadle.


See our unittests.

### FireSim

TODO!


### SymbiYosys

`formal` directory. TODO: how to run?


### ESSENT

**Claim:**
> Overall, it took us
> around 5 hours and 60 lines of code to add support for our
> cover primitive and thus allow ESSENT users to make
> use of all our coverage metrics.

Our fork of ESSENT has the `cover` feature implemented in three commits
from November 19th 2021: https://github.com/ekiwi/essent/commits/coverage


## Table 1: Code complexity of coverage passes and report generators.



## Table 2: Benchmarks

**Software simulation benchmarks and the number
cover points generated by the different instrumentation
passes.**

### riscv-mini


### TLRAM

### serv-chisel


### NeuroProc



## Figure 7: Coverage instrumentation overhead on Verilator.




## Figure 8 + 9: FireSim overhead


## Section 5.2: Number of `cover` statements + FireSim execution speed.




## Figure 10: Fuzzing

**Cumulative line coverage of inputs discovered
through fuzzing with various feedback metrics.**
