;buildInfoPackage: chisel3, version: 3.4.3, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit NeuromorphicProcessor : 
  extmodule ClockBufferBB : 
    input I : Clock
    input CE : UInt<1>
    output O : Clock
    
    defname = ClockBufferBB
    
    
  module ClockBufferVerilog : 
    input clock : Clock
    input reset : Reset
    output io : {flip I : Clock, flip CE : UInt<1>, O : Clock}
    
    inst bb of ClockBufferBB @[ClockBuffer.scala 46:18]
    bb.O is invalid
    bb.CE is invalid
    bb.I is invalid
    io.O <= bb.O @[ClockBuffer.scala 47:6]
    bb.CE <= io.CE @[ClockBuffer.scala 47:6]
    bb.I <= io.I @[ClockBuffer.scala 47:6]
    
  extmodule ClockBufferBB_1 : 
    input I : Clock
    input CE : UInt<1>
    output O : Clock
    
    defname = ClockBufferBB
    
    
  module ClockBufferVerilog_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip I : Clock, flip CE : UInt<1>, O : Clock}
    
    inst bb of ClockBufferBB_1 @[ClockBuffer.scala 46:18]
    bb.O is invalid
    bb.CE is invalid
    bb.I is invalid
    io.O <= bb.O @[ClockBuffer.scala 47:6]
    bb.CE <= io.CE @[ClockBuffer.scala 47:6]
    bb.I <= io.I @[ClockBuffer.scala 47:6]
    
  module TrueDualPortMemory : 
    output io : {flip clka : Clock, flip ena : UInt<1>, flip wea : UInt<1>, flip addra : UInt<9>, flip dia : UInt<9>, doa : UInt<9>, flip clkb : Clock, flip enb : UInt<1>, flip web : UInt<1>, flip addrb : UInt<9>, flip dib : UInt<9>, dob : UInt<9>}
    
    smem ram : UInt<9>[512], undefined @[TrueDualPortMemory.scala 28:24]
    io.doa is invalid @[TrueDualPortMemory.scala 32:12]
    when io.ena : @[TrueDualPortMemory.scala 33:18]
      when io.wea : @[TrueDualPortMemory.scala 34:20]
        infer mport MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 35:12]
        MPORT <= io.dia @[TrueDualPortMemory.scala 35:23]
        skip @[TrueDualPortMemory.scala 34:20]
      infer mport io_doa_MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 37:20]
      io.doa <= io_doa_MPORT @[TrueDualPortMemory.scala 37:14]
      skip @[TrueDualPortMemory.scala 33:18]
    io.dob is invalid @[TrueDualPortMemory.scala 43:12]
    when io.enb : @[TrueDualPortMemory.scala 44:18]
      when io.web : @[TrueDualPortMemory.scala 45:20]
        infer mport MPORT_1 = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 46:12]
        MPORT_1 <= io.dib @[TrueDualPortMemory.scala 46:23]
        skip @[TrueDualPortMemory.scala 45:20]
      infer mport io_dob_MPORT = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 48:20]
      io.dob <= io_dob_MPORT @[TrueDualPortMemory.scala 48:14]
      skip @[TrueDualPortMemory.scala 44:18]
    
  module TrueDualPortMemory_1 : 
    output io : {flip clka : Clock, flip ena : UInt<1>, flip wea : UInt<1>, flip addra : UInt<9>, flip dia : UInt<9>, doa : UInt<9>, flip clkb : Clock, flip enb : UInt<1>, flip web : UInt<1>, flip addrb : UInt<9>, flip dib : UInt<9>, dob : UInt<9>}
    
    smem ram : UInt<9>[512], undefined @[TrueDualPortMemory.scala 28:24]
    io.doa is invalid @[TrueDualPortMemory.scala 32:12]
    when io.ena : @[TrueDualPortMemory.scala 33:18]
      when io.wea : @[TrueDualPortMemory.scala 34:20]
        infer mport MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 35:12]
        MPORT <= io.dia @[TrueDualPortMemory.scala 35:23]
        skip @[TrueDualPortMemory.scala 34:20]
      infer mport io_doa_MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 37:20]
      io.doa <= io_doa_MPORT @[TrueDualPortMemory.scala 37:14]
      skip @[TrueDualPortMemory.scala 33:18]
    io.dob is invalid @[TrueDualPortMemory.scala 43:12]
    when io.enb : @[TrueDualPortMemory.scala 44:18]
      when io.web : @[TrueDualPortMemory.scala 45:20]
        infer mport MPORT_1 = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 46:12]
        MPORT_1 <= io.dib @[TrueDualPortMemory.scala 46:23]
        skip @[TrueDualPortMemory.scala 45:20]
      infer mport io_dob_MPORT = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 48:20]
      io.dob <= io_dob_MPORT @[TrueDualPortMemory.scala 48:14]
      skip @[TrueDualPortMemory.scala 44:18]
    
  module TrueDualPortMemory_2 : 
    output io : {flip clka : Clock, flip ena : UInt<1>, flip wea : UInt<1>, flip addra : UInt<4>, flip dia : UInt<8>, doa : UInt<8>, flip clkb : Clock, flip enb : UInt<1>, flip web : UInt<1>, flip addrb : UInt<4>, flip dib : UInt<8>, dob : UInt<8>}
    
    smem ram : UInt<8>[16], undefined @[TrueDualPortMemory.scala 28:24]
    io.doa is invalid @[TrueDualPortMemory.scala 32:12]
    when io.ena : @[TrueDualPortMemory.scala 33:18]
      when io.wea : @[TrueDualPortMemory.scala 34:20]
        infer mport MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 35:12]
        MPORT <= io.dia @[TrueDualPortMemory.scala 35:23]
        skip @[TrueDualPortMemory.scala 34:20]
      infer mport io_doa_MPORT = ram[io.addra], io.clka @[TrueDualPortMemory.scala 37:20]
      io.doa <= io_doa_MPORT @[TrueDualPortMemory.scala 37:14]
      skip @[TrueDualPortMemory.scala 33:18]
    io.dob is invalid @[TrueDualPortMemory.scala 43:12]
    when io.enb : @[TrueDualPortMemory.scala 44:18]
      when io.web : @[TrueDualPortMemory.scala 45:20]
        infer mport MPORT_1 = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 46:12]
        MPORT_1 <= io.dib @[TrueDualPortMemory.scala 46:23]
        skip @[TrueDualPortMemory.scala 45:20]
      infer mport io_dob_MPORT = ram[io.addrb], io.clkb @[TrueDualPortMemory.scala 48:20]
      io.dob <= io_dob_MPORT @[TrueDualPortMemory.scala 48:14]
      skip @[TrueDualPortMemory.scala 44:18]
    
  module WriteControl : 
    output io : {flip clkw : Clock, flip resetw : UInt<1>, flip wr : UInt<1>, flip rPtr : UInt<5>, full : UInt<1>, wPtr : UInt<5>, wAddr : UInt<4>}
    
    node _T = asAsyncReset(io.resetw) @[TrueDualPortFIFO.scala 45:42]
    wire wPtrNext : UInt<5> @[TrueDualPortFIFO.scala 47:26]
    wire gray1 : UInt<5> @[TrueDualPortFIFO.scala 48:23]
    wire wAddr : UInt<4> @[TrueDualPortFIFO.scala 49:23]
    wire wAddrMsb : UInt<1> @[TrueDualPortFIFO.scala 50:26]
    wire rAddrMsb : UInt<1> @[TrueDualPortFIFO.scala 51:26]
    wire fullFlag : UInt<1> @[TrueDualPortFIFO.scala 52:26]
    reg wPtr : UInt, io.clkw with : (reset => (_T, UInt<1>("h00"))) @[TrueDualPortFIFO.scala 55:25]
    wPtr <= wPtrNext @[TrueDualPortFIFO.scala 55:25]
    wire gray1_b1 : UInt<5> @[TrueDualPortFIFO.scala 28:18]
    node _gray1_bVec_T = bits(wPtr, 4, 0) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_1 = xorr(_gray1_bVec_T) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_2 = bits(wPtr, 4, 1) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_3 = xorr(_gray1_bVec_T_2) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_4 = bits(wPtr, 4, 2) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_5 = xorr(_gray1_bVec_T_4) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_6 = bits(wPtr, 4, 3) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_7 = xorr(_gray1_bVec_T_6) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_8 = bits(wPtr, 4, 4) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_9 = xorr(_gray1_bVec_T_8) @[TrueDualPortFIFO.scala 29:60]
    wire gray1_bVec : UInt<1>[5] @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[0] <= _gray1_bVec_T_1 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[1] <= _gray1_bVec_T_3 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[2] <= _gray1_bVec_T_5 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[3] <= _gray1_bVec_T_7 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[4] <= _gray1_bVec_T_9 @[TrueDualPortFIFO.scala 29:23]
    node gray1_b1_lo = cat(gray1_bVec[1], gray1_bVec[0]) @[TrueDualPortFIFO.scala 30:16]
    node gray1_b1_hi_hi = cat(gray1_bVec[4], gray1_bVec[3]) @[TrueDualPortFIFO.scala 30:16]
    node gray1_b1_hi = cat(gray1_b1_hi_hi, gray1_bVec[2]) @[TrueDualPortFIFO.scala 30:16]
    node _gray1_b1_T = cat(gray1_b1_hi, gray1_b1_lo) @[TrueDualPortFIFO.scala 30:16]
    node _gray1_b1_T_1 = add(_gray1_b1_T, UInt<1>("h01")) @[TrueDualPortFIFO.scala 30:23]
    node _gray1_b1_T_2 = tail(_gray1_b1_T_1, 1) @[TrueDualPortFIFO.scala 30:23]
    gray1_b1 <= _gray1_b1_T_2 @[TrueDualPortFIFO.scala 30:8]
    node _gray1_T = bits(gray1_b1, 4, 1) @[TrueDualPortFIFO.scala 31:25]
    node _gray1_T_1 = cat(UInt<1>("h00"), _gray1_T) @[TrueDualPortFIFO.scala 31:20]
    node _gray1_T_2 = xor(gray1_b1, _gray1_T_1) @[TrueDualPortFIFO.scala 31:8]
    gray1 <= _gray1_T_2 @[TrueDualPortFIFO.scala 58:13]
    node _wPtrNext_T = eq(fullFlag, UInt<1>("h00")) @[TrueDualPortFIFO.scala 61:32]
    node _wPtrNext_T_1 = and(io.wr, _wPtrNext_T) @[TrueDualPortFIFO.scala 61:29]
    node _wPtrNext_T_2 = mux(_wPtrNext_T_1, gray1, wPtr) @[TrueDualPortFIFO.scala 61:22]
    wPtrNext <= _wPtrNext_T_2 @[TrueDualPortFIFO.scala 61:16]
    node _wAddrMsb_T = bits(wPtr, 4, 4) @[TrueDualPortFIFO.scala 64:23]
    node _wAddrMsb_T_1 = bits(wPtr, 3, 3) @[TrueDualPortFIFO.scala 64:37]
    node _wAddrMsb_T_2 = xor(_wAddrMsb_T, _wAddrMsb_T_1) @[TrueDualPortFIFO.scala 64:31]
    wAddrMsb <= _wAddrMsb_T_2 @[TrueDualPortFIFO.scala 64:16]
    node _wAddr_T = bits(wPtr, 2, 0) @[TrueDualPortFIFO.scala 65:35]
    node _wAddr_T_1 = cat(wAddrMsb, _wAddr_T) @[TrueDualPortFIFO.scala 65:28]
    wAddr <= _wAddr_T_1 @[TrueDualPortFIFO.scala 65:16]
    node _rAddrMsb_T = bits(io.rPtr, 4, 4) @[TrueDualPortFIFO.scala 68:26]
    node _rAddrMsb_T_1 = bits(io.rPtr, 3, 3) @[TrueDualPortFIFO.scala 68:43]
    node _rAddrMsb_T_2 = xor(_rAddrMsb_T, _rAddrMsb_T_1) @[TrueDualPortFIFO.scala 68:34]
    rAddrMsb <= _rAddrMsb_T_2 @[TrueDualPortFIFO.scala 68:16]
    node _fullFlag_T = bits(io.rPtr, 4, 4) @[TrueDualPortFIFO.scala 69:27]
    node _fullFlag_T_1 = bits(wPtr, 4, 4) @[TrueDualPortFIFO.scala 69:43]
    node _fullFlag_T_2 = neq(_fullFlag_T, _fullFlag_T_1) @[TrueDualPortFIFO.scala 69:35]
    node _fullFlag_T_3 = bits(io.rPtr, 2, 0) @[TrueDualPortFIFO.scala 69:63]
    node _fullFlag_T_4 = bits(wPtr, 2, 0) @[TrueDualPortFIFO.scala 69:84]
    node _fullFlag_T_5 = eq(_fullFlag_T_3, _fullFlag_T_4) @[TrueDualPortFIFO.scala 69:76]
    node _fullFlag_T_6 = and(_fullFlag_T_2, _fullFlag_T_5) @[TrueDualPortFIFO.scala 69:52]
    node _fullFlag_T_7 = eq(rAddrMsb, wAddrMsb) @[TrueDualPortFIFO.scala 69:111]
    node _fullFlag_T_8 = and(_fullFlag_T_6, _fullFlag_T_7) @[TrueDualPortFIFO.scala 69:98]
    fullFlag <= _fullFlag_T_8 @[TrueDualPortFIFO.scala 69:16]
    io.wAddr <= wAddr @[TrueDualPortFIFO.scala 72:16]
    io.wPtr <= wPtr @[TrueDualPortFIFO.scala 73:16]
    io.full <= fullFlag @[TrueDualPortFIFO.scala 74:16]
    
  module ReadControl : 
    output io : {flip clkr : Clock, flip resetr : UInt<1>, flip rd : UInt<1>, flip wPtr : UInt<5>, empty : UInt<1>, rPtr : UInt<5>, rAddr : UInt<4>}
    
    node _T = asAsyncReset(io.resetr) @[TrueDualPortFIFO.scala 89:42]
    wire rPtrNext : UInt<5> @[TrueDualPortFIFO.scala 91:26]
    wire gray1 : UInt<5> @[TrueDualPortFIFO.scala 92:23]
    wire rAddr : UInt<4> @[TrueDualPortFIFO.scala 93:23]
    wire rAddrMsb : UInt<1> @[TrueDualPortFIFO.scala 94:27]
    wire wAddrMsb : UInt<1> @[TrueDualPortFIFO.scala 95:27]
    wire emptyFlag : UInt<1> @[TrueDualPortFIFO.scala 96:27]
    reg rPtr : UInt, io.clkr with : (reset => (_T, UInt<1>("h00"))) @[TrueDualPortFIFO.scala 99:25]
    rPtr <= rPtrNext @[TrueDualPortFIFO.scala 99:25]
    wire gray1_b1 : UInt<5> @[TrueDualPortFIFO.scala 28:18]
    node _gray1_bVec_T = bits(rPtr, 4, 0) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_1 = xorr(_gray1_bVec_T) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_2 = bits(rPtr, 4, 1) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_3 = xorr(_gray1_bVec_T_2) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_4 = bits(rPtr, 4, 2) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_5 = xorr(_gray1_bVec_T_4) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_6 = bits(rPtr, 4, 3) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_7 = xorr(_gray1_bVec_T_6) @[TrueDualPortFIFO.scala 29:60]
    node _gray1_bVec_T_8 = bits(rPtr, 4, 4) @[TrueDualPortFIFO.scala 29:47]
    node _gray1_bVec_T_9 = xorr(_gray1_bVec_T_8) @[TrueDualPortFIFO.scala 29:60]
    wire gray1_bVec : UInt<1>[5] @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[0] <= _gray1_bVec_T_1 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[1] <= _gray1_bVec_T_3 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[2] <= _gray1_bVec_T_5 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[3] <= _gray1_bVec_T_7 @[TrueDualPortFIFO.scala 29:23]
    gray1_bVec[4] <= _gray1_bVec_T_9 @[TrueDualPortFIFO.scala 29:23]
    node gray1_b1_lo = cat(gray1_bVec[1], gray1_bVec[0]) @[TrueDualPortFIFO.scala 30:16]
    node gray1_b1_hi_hi = cat(gray1_bVec[4], gray1_bVec[3]) @[TrueDualPortFIFO.scala 30:16]
    node gray1_b1_hi = cat(gray1_b1_hi_hi, gray1_bVec[2]) @[TrueDualPortFIFO.scala 30:16]
    node _gray1_b1_T = cat(gray1_b1_hi, gray1_b1_lo) @[TrueDualPortFIFO.scala 30:16]
    node _gray1_b1_T_1 = add(_gray1_b1_T, UInt<1>("h01")) @[TrueDualPortFIFO.scala 30:23]
    node _gray1_b1_T_2 = tail(_gray1_b1_T_1, 1) @[TrueDualPortFIFO.scala 30:23]
    gray1_b1 <= _gray1_b1_T_2 @[TrueDualPortFIFO.scala 30:8]
    node _gray1_T = bits(gray1_b1, 4, 1) @[TrueDualPortFIFO.scala 31:25]
    node _gray1_T_1 = cat(UInt<1>("h00"), _gray1_T) @[TrueDualPortFIFO.scala 31:20]
    node _gray1_T_2 = xor(gray1_b1, _gray1_T_1) @[TrueDualPortFIFO.scala 31:8]
    gray1 <= _gray1_T_2 @[TrueDualPortFIFO.scala 102:13]
    node _rPtrNext_T = eq(emptyFlag, UInt<1>("h00")) @[TrueDualPortFIFO.scala 105:32]
    node _rPtrNext_T_1 = and(io.rd, _rPtrNext_T) @[TrueDualPortFIFO.scala 105:29]
    node _rPtrNext_T_2 = mux(_rPtrNext_T_1, gray1, rPtr) @[TrueDualPortFIFO.scala 105:22]
    rPtrNext <= _rPtrNext_T_2 @[TrueDualPortFIFO.scala 105:16]
    node _rAddrMsb_T = bits(rPtr, 4, 4) @[TrueDualPortFIFO.scala 108:23]
    node _rAddrMsb_T_1 = bits(rPtr, 3, 3) @[TrueDualPortFIFO.scala 108:37]
    node _rAddrMsb_T_2 = xor(_rAddrMsb_T, _rAddrMsb_T_1) @[TrueDualPortFIFO.scala 108:31]
    rAddrMsb <= _rAddrMsb_T_2 @[TrueDualPortFIFO.scala 108:16]
    node _rAddr_T = bits(rPtr, 2, 0) @[TrueDualPortFIFO.scala 109:35]
    node _rAddr_T_1 = cat(rAddrMsb, _rAddr_T) @[TrueDualPortFIFO.scala 109:28]
    rAddr <= _rAddr_T_1 @[TrueDualPortFIFO.scala 109:16]
    node _wAddrMsb_T = bits(io.wPtr, 4, 4) @[TrueDualPortFIFO.scala 112:27]
    node _wAddrMsb_T_1 = bits(io.wPtr, 3, 3) @[TrueDualPortFIFO.scala 112:44]
    node _wAddrMsb_T_2 = xor(_wAddrMsb_T, _wAddrMsb_T_1) @[TrueDualPortFIFO.scala 112:35]
    wAddrMsb <= _wAddrMsb_T_2 @[TrueDualPortFIFO.scala 112:17]
    node _emptyFlag_T = bits(io.wPtr, 4, 4) @[TrueDualPortFIFO.scala 113:28]
    node _emptyFlag_T_1 = bits(rPtr, 4, 4) @[TrueDualPortFIFO.scala 113:44]
    node _emptyFlag_T_2 = eq(_emptyFlag_T, _emptyFlag_T_1) @[TrueDualPortFIFO.scala 113:36]
    node _emptyFlag_T_3 = bits(io.wPtr, 2, 0) @[TrueDualPortFIFO.scala 113:64]
    node _emptyFlag_T_4 = bits(rPtr, 2, 0) @[TrueDualPortFIFO.scala 113:85]
    node _emptyFlag_T_5 = eq(_emptyFlag_T_3, _emptyFlag_T_4) @[TrueDualPortFIFO.scala 113:77]
    node _emptyFlag_T_6 = and(_emptyFlag_T_2, _emptyFlag_T_5) @[TrueDualPortFIFO.scala 113:53]
    node _emptyFlag_T_7 = eq(wAddrMsb, rAddrMsb) @[TrueDualPortFIFO.scala 113:112]
    node _emptyFlag_T_8 = and(_emptyFlag_T_6, _emptyFlag_T_7) @[TrueDualPortFIFO.scala 113:99]
    emptyFlag <= _emptyFlag_T_8 @[TrueDualPortFIFO.scala 113:17]
    io.rAddr <= rAddr @[TrueDualPortFIFO.scala 116:16]
    io.rPtr <= rPtr @[TrueDualPortFIFO.scala 117:16]
    io.empty <= emptyFlag @[TrueDualPortFIFO.scala 118:16]
    
  module TrueDualPortFIFO : 
    output io : {flip clki : Clock, flip we : UInt<1>, flip datai : UInt<8>, full : UInt<1>, flip clko : Clock, flip en : UInt<1>, datao : UInt<8>, empty : UInt<1>, flip rst : UInt<1>}
    
    inst ram of TrueDualPortMemory_2 @[TrueDualPortFIFO.scala 123:21]
    inst wctrl of WriteControl @[TrueDualPortFIFO.scala 124:21]
    inst rctrl of ReadControl @[TrueDualPortFIFO.scala 125:21]
    wire wAddr : UInt<4> @[TrueDualPortFIFO.scala 126:19]
    wire wPtr : UInt<5> @[TrueDualPortFIFO.scala 127:19]
    wire rAddr : UInt<4> @[TrueDualPortFIFO.scala 128:19]
    wire rPtr : UInt<5> @[TrueDualPortFIFO.scala 129:19]
    ram.io.clka <= io.clki @[TrueDualPortFIFO.scala 132:16]
    ram.io.addra <= wAddr @[TrueDualPortFIFO.scala 133:16]
    ram.io.dia <= io.datai @[TrueDualPortFIFO.scala 134:16]
    node _ram_io_ena_T = eq(wctrl.io.full, UInt<1>("h00")) @[TrueDualPortFIFO.scala 135:28]
    node _ram_io_ena_T_1 = and(io.we, _ram_io_ena_T) @[TrueDualPortFIFO.scala 135:25]
    ram.io.ena <= _ram_io_ena_T_1 @[TrueDualPortFIFO.scala 135:16]
    node _ram_io_wea_T = eq(wctrl.io.full, UInt<1>("h00")) @[TrueDualPortFIFO.scala 136:28]
    node _ram_io_wea_T_1 = and(io.we, _ram_io_wea_T) @[TrueDualPortFIFO.scala 136:25]
    ram.io.wea <= _ram_io_wea_T_1 @[TrueDualPortFIFO.scala 136:16]
    wctrl.io.clkw <= io.clki @[TrueDualPortFIFO.scala 138:17]
    wctrl.io.resetw <= io.rst @[TrueDualPortFIFO.scala 139:19]
    wctrl.io.wr <= io.we @[TrueDualPortFIFO.scala 140:15]
    wctrl.io.rPtr <= rPtr @[TrueDualPortFIFO.scala 141:17]
    io.full <= wctrl.io.full @[TrueDualPortFIFO.scala 142:11]
    wPtr <= wctrl.io.wPtr @[TrueDualPortFIFO.scala 143:8]
    wAddr <= wctrl.io.wAddr @[TrueDualPortFIFO.scala 144:9]
    ram.io.clkb <= io.clko @[TrueDualPortFIFO.scala 147:16]
    ram.io.addrb <= rAddr @[TrueDualPortFIFO.scala 148:16]
    ram.io.dib <= UInt<1>("h00") @[TrueDualPortFIFO.scala 149:16]
    node _ram_io_enb_T = eq(rctrl.io.empty, UInt<1>("h00")) @[TrueDualPortFIFO.scala 150:28]
    node _ram_io_enb_T_1 = and(io.en, _ram_io_enb_T) @[TrueDualPortFIFO.scala 150:25]
    ram.io.enb <= _ram_io_enb_T_1 @[TrueDualPortFIFO.scala 150:16]
    ram.io.web <= UInt<1>("h00") @[TrueDualPortFIFO.scala 151:16]
    io.datao <= ram.io.dob @[TrueDualPortFIFO.scala 152:16]
    rctrl.io.clkr <= io.clko @[TrueDualPortFIFO.scala 154:17]
    rctrl.io.resetr <= io.rst @[TrueDualPortFIFO.scala 155:19]
    rctrl.io.rd <= io.en @[TrueDualPortFIFO.scala 156:15]
    rctrl.io.wPtr <= wPtr @[TrueDualPortFIFO.scala 157:17]
    io.empty <= rctrl.io.empty @[TrueDualPortFIFO.scala 158:12]
    rPtr <= rctrl.io.rPtr @[TrueDualPortFIFO.scala 159:8]
    rAddr <= rctrl.io.rAddr @[TrueDualPortFIFO.scala 160:9]
    
  module Tx : 
    input clock : Clock
    input reset : Reset
    output io : {tx : UInt<1>, ready : UInt<1>, flip valid : UInt<1>, flip data : UInt<8>}
    
    reg clkCnt : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[UART.scala 17:23]
    reg baudtick : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[UART.scala 18:25]
    reg state : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[UART.scala 19:22]
    reg data : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[UART.scala 20:21]
    reg txBit : UInt<1>, clock with : (reset => (reset, UInt<1>("h01"))) @[UART.scala 21:22]
    reg bitCnt : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[UART.scala 22:23]
    reg readyR : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[UART.scala 23:23]
    io.tx <= txBit @[UART.scala 25:9]
    io.ready <= readyR @[UART.scala 26:12]
    node _T = eq(clkCnt, UInt<10>("h02b6")) @[UART.scala 28:15]
    when _T : @[UART.scala 28:30]
      clkCnt <= UInt<1>("h00") @[UART.scala 29:12]
      baudtick <= UInt<1>("h01") @[UART.scala 30:14]
      skip @[UART.scala 28:30]
    else : @[UART.scala 31:15]
      node _clkCnt_T = add(clkCnt, UInt<1>("h01")) @[UART.scala 32:22]
      node _clkCnt_T_1 = tail(_clkCnt_T, 1) @[UART.scala 32:22]
      clkCnt <= _clkCnt_T_1 @[UART.scala 32:12]
      baudtick <= UInt<1>("h00") @[UART.scala 33:14]
      skip @[UART.scala 31:15]
    readyR <= UInt<1>("h00") @[UART.scala 36:10]
    node _T_1 = eq(UInt<2>("h00"), state) @[Conditional.scala 37:30]
    when _T_1 : @[Conditional.scala 40:58]
      node _T_2 = and(baudtick, io.valid) @[UART.scala 40:21]
      when _T_2 : @[UART.scala 40:34]
        txBit <= UInt<1>("h00") @[UART.scala 41:15]
        state <= UInt<2>("h01") @[UART.scala 42:15]
        bitCnt <= UInt<1>("h00") @[UART.scala 43:16]
        readyR <= UInt<1>("h01") @[UART.scala 44:16]
        data <= io.data @[UART.scala 45:14]
        skip @[UART.scala 40:34]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<2>("h01"), state) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        when baudtick : @[UART.scala 49:22]
          node _txBit_T = bits(data, 0, 0) @[UART.scala 50:22]
          txBit <= _txBit_T @[UART.scala 50:15]
          node _data_T = bits(data, 7, 1) @[UART.scala 51:31]
          node _data_T_1 = cat(UInt<1>("h01"), _data_T) @[UART.scala 51:24]
          data <= _data_T_1 @[UART.scala 51:14]
          node _T_4 = lt(bitCnt, UInt<3>("h07")) @[UART.scala 52:21]
          when _T_4 : @[UART.scala 52:28]
            node _bitCnt_T = add(bitCnt, UInt<1>("h01")) @[UART.scala 53:28]
            node _bitCnt_T_1 = tail(_bitCnt_T, 1) @[UART.scala 53:28]
            bitCnt <= _bitCnt_T_1 @[UART.scala 53:18]
            skip @[UART.scala 52:28]
          else : @[UART.scala 54:21]
            bitCnt <= UInt<1>("h00") @[UART.scala 55:18]
            state <= UInt<2>("h02") @[UART.scala 56:17]
            skip @[UART.scala 54:21]
          skip @[UART.scala 49:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_5 = eq(UInt<2>("h02"), state) @[Conditional.scala 37:30]
        when _T_5 : @[Conditional.scala 39:67]
          when baudtick : @[UART.scala 61:22]
            txBit <= UInt<1>("h01") @[UART.scala 62:15]
            state <= UInt<2>("h00") @[UART.scala 63:15]
            skip @[UART.scala 61:22]
          skip @[Conditional.scala 39:67]
    
  module Rx : 
    input clock : Clock
    input reset : Reset
    output io : {flip rx : UInt<1>, flip ready : UInt<1>, valid : UInt<1>, data : UInt<8>}
    
    reg dataSr : UInt<2>, clock with : (reset => (reset, UInt<2>("h03"))) @[UART.scala 80:25]
    reg filter : UInt<2>, clock with : (reset => (reset, UInt<2>("h03"))) @[UART.scala 81:25]
    reg rxBit : UInt<1>, clock with : (reset => (reset, UInt<1>("h01"))) @[UART.scala 82:25]
    reg spaceCnt : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[UART.scala 83:25]
    reg data : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[UART.scala 84:25]
    reg clkCnt : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[UART.scala 85:25]
    reg baudTick : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[UART.scala 86:25]
    reg bitTick : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[UART.scala 87:25]
    reg state : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[UART.scala 88:25]
    reg bitCnt : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[UART.scala 89:25]
    reg validR : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[UART.scala 90:25]
    io.data <= data @[UART.scala 92:11]
    io.valid <= validR @[UART.scala 93:12]
    node _T = and(validR, io.ready) @[UART.scala 95:15]
    when _T : @[UART.scala 95:28]
      validR <= UInt<1>("h00") @[UART.scala 96:12]
      skip @[UART.scala 95:28]
    node _T_1 = eq(clkCnt, UInt<6>("h02b")) @[UART.scala 99:15]
    when _T_1 : @[UART.scala 99:34]
      baudTick <= UInt<1>("h01") @[UART.scala 100:14]
      clkCnt <= UInt<1>("h00") @[UART.scala 101:12]
      skip @[UART.scala 99:34]
    else : @[UART.scala 102:15]
      baudTick <= UInt<1>("h00") @[UART.scala 103:14]
      node _clkCnt_T = add(clkCnt, UInt<1>("h01")) @[UART.scala 104:22]
      node _clkCnt_T_1 = tail(_clkCnt_T, 1) @[UART.scala 104:22]
      clkCnt <= _clkCnt_T_1 @[UART.scala 104:12]
      skip @[UART.scala 102:15]
    bitTick <= UInt<1>("h00") @[UART.scala 107:11]
    when baudTick : @[UART.scala 109:18]
      node _dataSr_T = bits(dataSr, 0, 0) @[UART.scala 110:21]
      node _dataSr_T_1 = cat(_dataSr_T, io.rx) @[UART.scala 110:25]
      dataSr <= _dataSr_T_1 @[UART.scala 110:12]
      node _T_2 = bits(dataSr, 1, 1) @[UART.scala 112:16]
      node _T_3 = lt(filter, UInt<2>("h03")) @[UART.scala 112:30]
      node _T_4 = and(_T_2, _T_3) @[UART.scala 112:20]
      when _T_4 : @[UART.scala 112:37]
        node _filter_T = add(filter, UInt<1>("h01")) @[UART.scala 113:24]
        node _filter_T_1 = tail(_filter_T, 1) @[UART.scala 113:24]
        filter <= _filter_T_1 @[UART.scala 113:14]
        skip @[UART.scala 112:37]
      else : @[UART.scala 114:44]
        node _T_5 = bits(dataSr, 1, 1) @[UART.scala 114:23]
        node _T_6 = eq(_T_5, UInt<1>("h00")) @[UART.scala 114:16]
        node _T_7 = gt(filter, UInt<1>("h00")) @[UART.scala 114:37]
        node _T_8 = and(_T_6, _T_7) @[UART.scala 114:27]
        when _T_8 : @[UART.scala 114:44]
          node _filter_T_2 = sub(filter, UInt<1>("h01")) @[UART.scala 115:24]
          node _filter_T_3 = tail(_filter_T_2, 1) @[UART.scala 115:24]
          filter <= _filter_T_3 @[UART.scala 115:14]
          skip @[UART.scala 114:44]
      node _T_9 = eq(filter, UInt<2>("h03")) @[UART.scala 118:17]
      when _T_9 : @[UART.scala 118:26]
        rxBit <= UInt<1>("h01") @[UART.scala 119:13]
        skip @[UART.scala 118:26]
      else : @[UART.scala 120:32]
        node _T_10 = eq(filter, UInt<1>("h00")) @[UART.scala 120:23]
        when _T_10 : @[UART.scala 120:32]
          rxBit <= UInt<1>("h00") @[UART.scala 121:13]
          skip @[UART.scala 120:32]
      node _T_11 = eq(spaceCnt, UInt<4>("h0f")) @[UART.scala 124:19]
      when _T_11 : @[UART.scala 124:29]
        bitTick <= UInt<1>("h01") @[UART.scala 125:15]
        spaceCnt <= UInt<1>("h00") @[UART.scala 126:16]
        skip @[UART.scala 124:29]
      else : @[UART.scala 127:17]
        node _spaceCnt_T = add(spaceCnt, UInt<1>("h01")) @[UART.scala 128:28]
        node _spaceCnt_T_1 = tail(_spaceCnt_T, 1) @[UART.scala 128:28]
        spaceCnt <= _spaceCnt_T_1 @[UART.scala 128:16]
        skip @[UART.scala 127:17]
      node _T_12 = eq(state, UInt<2>("h00")) @[UART.scala 130:16]
      when _T_12 : @[UART.scala 130:28]
        spaceCnt <= UInt<1>("h00") @[UART.scala 131:16]
        skip @[UART.scala 130:28]
      skip @[UART.scala 109:18]
    node _T_13 = eq(UInt<2>("h00"), state) @[Conditional.scala 37:30]
    when _T_13 : @[Conditional.scala 40:58]
      node _T_14 = eq(rxBit, UInt<1>("h00")) @[UART.scala 137:24]
      node _T_15 = and(baudTick, _T_14) @[UART.scala 137:21]
      when _T_15 : @[UART.scala 137:32]
        state <= UInt<2>("h01") @[UART.scala 138:15]
        skip @[UART.scala 137:32]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_16 = eq(UInt<2>("h01"), state) @[Conditional.scala 37:30]
      when _T_16 : @[Conditional.scala 39:67]
        when bitTick : @[UART.scala 142:21]
          node _data_T = bits(data, 7, 1) @[UART.scala 143:30]
          node _data_T_1 = cat(rxBit, _data_T) @[UART.scala 143:23]
          data <= _data_T_1 @[UART.scala 143:14]
          node _T_17 = lt(bitCnt, UInt<3>("h07")) @[UART.scala 144:21]
          when _T_17 : @[UART.scala 144:27]
            node _bitCnt_T = add(bitCnt, UInt<1>("h01")) @[UART.scala 145:28]
            node _bitCnt_T_1 = tail(_bitCnt_T, 1) @[UART.scala 145:28]
            bitCnt <= _bitCnt_T_1 @[UART.scala 145:18]
            skip @[UART.scala 144:27]
          else : @[UART.scala 146:21]
            bitCnt <= UInt<1>("h00") @[UART.scala 147:18]
            state <= UInt<2>("h02") @[UART.scala 148:17]
            skip @[UART.scala 146:21]
          skip @[UART.scala 142:21]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_18 = eq(UInt<2>("h02"), state) @[Conditional.scala 37:30]
        when _T_18 : @[Conditional.scala 39:67]
          node _T_19 = and(bitTick, rxBit) @[UART.scala 153:20]
          when _T_19 : @[UART.scala 153:30]
            state <= UInt<2>("h00") @[UART.scala 154:15]
            validR <= UInt<1>("h01") @[UART.scala 155:16]
            skip @[UART.scala 153:30]
          skip @[Conditional.scala 39:67]
    
  module Uart : 
    input clock : Clock
    input reset : Reset
    output io : {flip rxd : UInt<1>, txd : UInt<1>, flip rxReady : UInt<1>, rxValid : UInt<1>, rxByte : UInt<8>, txReady : UInt<1>, flip txValid : UInt<1>, flip txByte : UInt<8>}
    
    inst tx of Tx @[UART.scala 175:18]
    tx.clock <= clock
    tx.reset <= reset
    inst rx of Rx @[UART.scala 176:18]
    rx.clock <= clock
    rx.reset <= reset
    io.txd <= tx.io.tx @[UART.scala 178:10]
    io.txReady <= tx.io.ready @[UART.scala 179:14]
    tx.io.valid <= io.txValid @[UART.scala 180:15]
    tx.io.data <= io.txByte @[UART.scala 181:14]
    rx.io.rx <= io.rxd @[UART.scala 183:12]
    rx.io.ready <= io.rxReady @[UART.scala 184:15]
    io.rxValid <= rx.io.valid @[UART.scala 185:14]
    io.rxByte <= rx.io.data @[UART.scala 186:13]
    
  module OffChipCom : 
    input clock : Clock
    input reset : Reset
    output io : {tx : UInt<1>, flip rx : UInt<1>, inC0We : UInt<1>, inC0Addr : UInt<9>, inC0Di : UInt<9>, inC1We : UInt<1>, inC1Addr : UInt<9>, inC1Di : UInt<9>, qEn : UInt<1>, flip qData : UInt<8>, flip qEmpty : UInt<1>, flip inC0HSin : UInt<1>, inC0HSout : UInt<1>, flip inC1HSin : UInt<1>, inC1HSout : UInt<1>}
    
    inst uart of Uart @[OffChipCom.scala 34:20]
    uart.clock <= clock
    uart.reset <= reset
    reg txBuf : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[OffChipCom.scala 35:22]
    reg txV : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[OffChipCom.scala 36:20]
    uart.io.rxd <= io.rx @[OffChipCom.scala 39:15]
    uart.io.rxReady <= UInt<1>("h00") @[OffChipCom.scala 40:19]
    io.tx <= uart.io.txd @[OffChipCom.scala 43:9]
    uart.io.txValid <= txV @[OffChipCom.scala 44:19]
    uart.io.txByte <= txBuf @[OffChipCom.scala 45:18]
    node _T = and(uart.io.txReady, txV) @[OffChipCom.scala 46:24]
    when _T : @[OffChipCom.scala 46:32]
      txV <= UInt<1>("h00") @[OffChipCom.scala 47:9]
      skip @[OffChipCom.scala 46:32]
    wire en : UInt<1> @[OffChipCom.scala 51:16]
    reg enReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[OffChipCom.scala 52:22]
    node _en_T = eq(io.qEmpty, UInt<1>("h00")) @[OffChipCom.scala 53:9]
    node _en_T_1 = eq(txV, UInt<1>("h00")) @[OffChipCom.scala 53:23]
    node _en_T_2 = and(_en_T, _en_T_1) @[OffChipCom.scala 53:20]
    node _en_T_3 = eq(enReg, UInt<1>("h00")) @[OffChipCom.scala 53:31]
    node _en_T_4 = and(_en_T_2, _en_T_3) @[OffChipCom.scala 53:28]
    en <= _en_T_4 @[OffChipCom.scala 53:6]
    enReg <= en @[OffChipCom.scala 54:9]
    io.qEn <= en @[OffChipCom.scala 55:10]
    when enReg : @[OffChipCom.scala 56:15]
      txBuf <= io.qData @[OffChipCom.scala 57:11]
      txV <= UInt<1>("h01") @[OffChipCom.scala 58:9]
      skip @[OffChipCom.scala 56:15]
    reg addr1 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[OffChipCom.scala 62:22]
    reg addr0 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[OffChipCom.scala 63:22]
    reg rate1 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[OffChipCom.scala 64:22]
    reg rate0 : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[OffChipCom.scala 65:22]
    reg phase : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[OffChipCom.scala 68:22]
    node _defAddr_T = add(addr0, UInt<9>("h0100")) @[OffChipCom.scala 71:42]
    node _defAddr_T_1 = tail(_defAddr_T, 1) @[OffChipCom.scala 71:42]
    node _defAddr_T_2 = mux(phase, addr0, _defAddr_T_1) @[OffChipCom.scala 71:21]
    node defAddr = bits(_defAddr_T_2, 8, 0) @[OffChipCom.scala 71:60]
    node _defData_T = cat(rate1, rate0) @[OffChipCom.scala 72:25]
    node defData = bits(_defData_T, 8, 0) @[OffChipCom.scala 72:34]
    io.inC0HSout <= phase @[OffChipCom.scala 73:16]
    io.inC0We <= UInt<1>("h00") @[OffChipCom.scala 74:16]
    io.inC0Addr <= defAddr @[OffChipCom.scala 75:16]
    io.inC0Di <= defData @[OffChipCom.scala 76:16]
    io.inC1HSout <= phase @[OffChipCom.scala 78:16]
    io.inC1We <= UInt<1>("h00") @[OffChipCom.scala 79:16]
    io.inC1Addr <= defAddr @[OffChipCom.scala 80:16]
    io.inC1Di <= defData @[OffChipCom.scala 81:16]
    reg stateReg : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[OffChipCom.scala 85:25]
    reg byteCnt : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[OffChipCom.scala 86:25]
    reg pixCnt : UInt<9>, clock with : (reset => (reset, UInt<9>("h00"))) @[OffChipCom.scala 87:25]
    node _T_1 = eq(UInt<2>("h00"), stateReg) @[Conditional.scala 37:30]
    when _T_1 : @[Conditional.scala 40:58]
      node _T_2 = eq(phase, io.inC0HSin) @[OffChipCom.scala 91:18]
      node _T_3 = eq(io.inC0HSin, io.inC1HSin) @[OffChipCom.scala 91:49]
      node _T_4 = and(_T_2, _T_3) @[OffChipCom.scala 91:34]
      when _T_4 : @[OffChipCom.scala 91:66]
        stateReg <= UInt<2>("h01") @[OffChipCom.scala 92:18]
        skip @[OffChipCom.scala 91:66]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_5 = eq(UInt<2>("h01"), stateReg) @[Conditional.scala 37:30]
      when _T_5 : @[Conditional.scala 39:67]
        when uart.io.txReady : @[OffChipCom.scala 98:29]
          stateReg <= UInt<2>("h02") @[OffChipCom.scala 99:18]
          skip @[OffChipCom.scala 98:29]
        else : @[OffChipCom.scala 100:19]
          pixCnt <= UInt<1>("h00") @[OffChipCom.scala 101:16]
          byteCnt <= UInt<1>("h00") @[OffChipCom.scala 102:17]
          txBuf <= UInt<8>("h0ff") @[OffChipCom.scala 103:15]
          txV <= UInt<1>("h01") @[OffChipCom.scala 104:13]
          skip @[OffChipCom.scala 100:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_6 = eq(UInt<2>("h02"), stateReg) @[Conditional.scala 37:30]
        when _T_6 : @[Conditional.scala 39:67]
          when uart.io.rxValid : @[OffChipCom.scala 109:29]
            addr1 <= addr0 @[OffChipCom.scala 110:15]
            addr0 <= rate1 @[OffChipCom.scala 111:15]
            rate1 <= rate0 @[OffChipCom.scala 112:15]
            rate0 <= uart.io.rxByte @[OffChipCom.scala 113:15]
            uart.io.rxReady <= UInt<1>("h01") @[OffChipCom.scala 114:25]
            node _byteCnt_T = add(byteCnt, UInt<1>("h01")) @[OffChipCom.scala 116:28]
            node _byteCnt_T_1 = tail(_byteCnt_T, 1) @[OffChipCom.scala 116:28]
            byteCnt <= _byteCnt_T_1 @[OffChipCom.scala 116:17]
            node _T_7 = eq(byteCnt, UInt<2>("h03")) @[OffChipCom.scala 118:22]
            when _T_7 : @[OffChipCom.scala 118:31]
              stateReg <= UInt<2>("h03") @[OffChipCom.scala 119:20]
              skip @[OffChipCom.scala 118:31]
            else : @[OffChipCom.scala 120:21]
              stateReg <= UInt<2>("h02") @[OffChipCom.scala 121:20]
              skip @[OffChipCom.scala 120:21]
            skip @[OffChipCom.scala 109:29]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_8 = eq(UInt<2>("h03"), stateReg) @[Conditional.scala 37:30]
          when _T_8 : @[Conditional.scala 39:67]
            node _T_9 = eq(addr1, UInt<1>("h00")) @[OffChipCom.scala 127:18]
            when _T_9 : @[OffChipCom.scala 127:27]
              io.inC0We <= UInt<1>("h01") @[OffChipCom.scala 128:19]
              skip @[OffChipCom.scala 127:27]
            else : @[OffChipCom.scala 129:19]
              io.inC1We <= UInt<1>("h01") @[OffChipCom.scala 130:19]
              skip @[OffChipCom.scala 129:19]
            node _pixCnt_T = add(pixCnt, UInt<1>("h01")) @[OffChipCom.scala 132:24]
            node _pixCnt_T_1 = tail(_pixCnt_T, 1) @[OffChipCom.scala 132:24]
            pixCnt <= _pixCnt_T_1 @[OffChipCom.scala 132:14]
            node _T_10 = eq(pixCnt, UInt<9>("h01e3")) @[OffChipCom.scala 136:19]
            when _T_10 : @[OffChipCom.scala 136:40]
              stateReg <= UInt<2>("h00") @[OffChipCom.scala 137:18]
              node _phase_T = not(phase) @[OffChipCom.scala 138:18]
              phase <= _phase_T @[OffChipCom.scala 138:15]
              skip @[OffChipCom.scala 136:40]
            else : @[OffChipCom.scala 139:19]
              stateReg <= UInt<2>("h02") @[OffChipCom.scala 140:18]
              skip @[OffChipCom.scala 139:19]
            skip @[Conditional.scala 39:67]
    
  module BusArbiter : 
    input clock : Clock
    input reset : Reset
    output io : {flip reqs : UInt<1>[5], grants : UInt<1>[5]}
    
    wire maskedReqs : UInt<1>[5] @[BusArbiter.scala 12:24]
    wire mask : UInt<1>[5] @[BusArbiter.scala 13:24]
    wire _maskRegs_WIRE : UInt<1>[5] @[BusArbiter.scala 14:35]
    _maskRegs_WIRE[0] <= UInt<1>("h01") @[BusArbiter.scala 14:35]
    _maskRegs_WIRE[1] <= UInt<1>("h01") @[BusArbiter.scala 14:35]
    _maskRegs_WIRE[2] <= UInt<1>("h01") @[BusArbiter.scala 14:35]
    _maskRegs_WIRE[3] <= UInt<1>("h01") @[BusArbiter.scala 14:35]
    _maskRegs_WIRE[4] <= UInt<1>("h01") @[BusArbiter.scala 14:35]
    reg maskRegs : UInt<1>[5], clock with : (reset => (reset, _maskRegs_WIRE)) @[BusArbiter.scala 14:27]
    wire grants : UInt<1>[5] @[BusArbiter.scala 15:24]
    wire _grantRegs_WIRE : UInt<1>[5] @[BusArbiter.scala 16:35]
    _grantRegs_WIRE[0] <= UInt<1>("h00") @[BusArbiter.scala 16:35]
    _grantRegs_WIRE[1] <= UInt<1>("h00") @[BusArbiter.scala 16:35]
    _grantRegs_WIRE[2] <= UInt<1>("h00") @[BusArbiter.scala 16:35]
    _grantRegs_WIRE[3] <= UInt<1>("h00") @[BusArbiter.scala 16:35]
    _grantRegs_WIRE[4] <= UInt<1>("h00") @[BusArbiter.scala 16:35]
    reg grantRegs : UInt<1>[5], clock with : (reset => (reset, _grantRegs_WIRE)) @[BusArbiter.scala 16:27]
    wire oneReq : UInt<1> @[BusArbiter.scala 18:24]
    wire value : UInt<3> @[BusArbiter.scala 19:24]
    value <= UInt<1>("h00") @[BusArbiter.scala 22:10]
    oneReq <= UInt<1>("h00") @[BusArbiter.scala 23:10]
    maskRegs[0] <= mask[0] @[BusArbiter.scala 27:18]
    grantRegs[0] <= grants[0] @[BusArbiter.scala 28:18]
    node _maskedReqs_0_T = and(maskRegs[0], io.reqs[0]) @[BusArbiter.scala 31:34]
    maskedReqs[0] <= _maskedReqs_0_T @[BusArbiter.scala 31:19]
    when maskedReqs[0] : @[BusArbiter.scala 34:25]
      oneReq <= UInt<1>("h01") @[BusArbiter.scala 35:14]
      value <= UInt<1>("h00") @[BusArbiter.scala 36:14]
      skip @[BusArbiter.scala 34:25]
    node _grants_0_T = eq(UInt<1>("h00"), value) @[BusArbiter.scala 40:23]
    node _grants_0_T_1 = and(_grants_0_T, oneReq) @[BusArbiter.scala 40:33]
    grants[0] <= _grants_0_T_1 @[BusArbiter.scala 40:15]
    maskRegs[1] <= mask[1] @[BusArbiter.scala 27:18]
    grantRegs[1] <= grants[1] @[BusArbiter.scala 28:18]
    node _maskedReqs_1_T = and(maskRegs[1], io.reqs[1]) @[BusArbiter.scala 31:34]
    maskedReqs[1] <= _maskedReqs_1_T @[BusArbiter.scala 31:19]
    when maskedReqs[1] : @[BusArbiter.scala 34:25]
      oneReq <= UInt<1>("h01") @[BusArbiter.scala 35:14]
      value <= UInt<1>("h01") @[BusArbiter.scala 36:14]
      skip @[BusArbiter.scala 34:25]
    node _grants_1_T = eq(UInt<1>("h01"), value) @[BusArbiter.scala 40:23]
    node _grants_1_T_1 = and(_grants_1_T, oneReq) @[BusArbiter.scala 40:33]
    grants[1] <= _grants_1_T_1 @[BusArbiter.scala 40:15]
    maskRegs[2] <= mask[2] @[BusArbiter.scala 27:18]
    grantRegs[2] <= grants[2] @[BusArbiter.scala 28:18]
    node _maskedReqs_2_T = and(maskRegs[2], io.reqs[2]) @[BusArbiter.scala 31:34]
    maskedReqs[2] <= _maskedReqs_2_T @[BusArbiter.scala 31:19]
    when maskedReqs[2] : @[BusArbiter.scala 34:25]
      oneReq <= UInt<1>("h01") @[BusArbiter.scala 35:14]
      value <= UInt<2>("h02") @[BusArbiter.scala 36:14]
      skip @[BusArbiter.scala 34:25]
    node _grants_2_T = eq(UInt<2>("h02"), value) @[BusArbiter.scala 40:23]
    node _grants_2_T_1 = and(_grants_2_T, oneReq) @[BusArbiter.scala 40:33]
    grants[2] <= _grants_2_T_1 @[BusArbiter.scala 40:15]
    maskRegs[3] <= mask[3] @[BusArbiter.scala 27:18]
    grantRegs[3] <= grants[3] @[BusArbiter.scala 28:18]
    node _maskedReqs_3_T = and(maskRegs[3], io.reqs[3]) @[BusArbiter.scala 31:34]
    maskedReqs[3] <= _maskedReqs_3_T @[BusArbiter.scala 31:19]
    when maskedReqs[3] : @[BusArbiter.scala 34:25]
      oneReq <= UInt<1>("h01") @[BusArbiter.scala 35:14]
      value <= UInt<2>("h03") @[BusArbiter.scala 36:14]
      skip @[BusArbiter.scala 34:25]
    node _grants_3_T = eq(UInt<2>("h03"), value) @[BusArbiter.scala 40:23]
    node _grants_3_T_1 = and(_grants_3_T, oneReq) @[BusArbiter.scala 40:33]
    grants[3] <= _grants_3_T_1 @[BusArbiter.scala 40:15]
    maskRegs[4] <= mask[4] @[BusArbiter.scala 27:18]
    grantRegs[4] <= grants[4] @[BusArbiter.scala 28:18]
    node _maskedReqs_4_T = and(maskRegs[4], io.reqs[4]) @[BusArbiter.scala 31:34]
    maskedReqs[4] <= _maskedReqs_4_T @[BusArbiter.scala 31:19]
    when maskedReqs[4] : @[BusArbiter.scala 34:25]
      oneReq <= UInt<1>("h01") @[BusArbiter.scala 35:14]
      value <= UInt<3>("h04") @[BusArbiter.scala 36:14]
      skip @[BusArbiter.scala 34:25]
    node _grants_4_T = eq(UInt<3>("h04"), value) @[BusArbiter.scala 40:23]
    node _grants_4_T_1 = and(_grants_4_T, oneReq) @[BusArbiter.scala 40:33]
    grants[4] <= _grants_4_T_1 @[BusArbiter.scala 40:15]
    node _mask_0_T = or(mask[1], maskedReqs[1]) @[BusArbiter.scala 45:28]
    mask[0] <= _mask_0_T @[BusArbiter.scala 45:13]
    node _mask_1_T = or(mask[2], maskedReqs[2]) @[BusArbiter.scala 45:28]
    mask[1] <= _mask_1_T @[BusArbiter.scala 45:13]
    node _mask_2_T = or(mask[3], maskedReqs[3]) @[BusArbiter.scala 45:28]
    mask[2] <= _mask_2_T @[BusArbiter.scala 45:13]
    node _mask_3_T = or(mask[4], maskedReqs[4]) @[BusArbiter.scala 45:28]
    mask[3] <= _mask_3_T @[BusArbiter.scala 45:13]
    node _mask_4_T = eq(value, UInt<1>("h00")) @[BusArbiter.scala 47:26]
    mask[4] <= _mask_4_T @[BusArbiter.scala 47:17]
    io.grants[0] <= grantRegs[0] @[BusArbiter.scala 49:13]
    io.grants[1] <= grantRegs[1] @[BusArbiter.scala 49:13]
    io.grants[2] <= grantRegs[2] @[BusArbiter.scala 49:13]
    io.grants[3] <= grantRegs[3] @[BusArbiter.scala 49:13]
    io.grants[4] <= grantRegs[4] @[BusArbiter.scala 49:13]
    
  module BusInterface : 
    input clock : Clock
    input reset : Reset
    output io : {flip grant : UInt<1>, reqOut : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, axonID : UInt<10>, valid : UInt<1>, flip spikeID : UInt<11>, ready : UInt<1>, flip reqIn : UInt<1>}
    
    wire filterROM : UInt<3>[5] @[BusInterface.scala 28:27]
    filterROM[0] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[1] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[2] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[3] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[4] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    node _io_tx_T = mux(io.grant, io.spikeID, UInt<1>("h00")) @[BusInterface.scala 31:15]
    io.tx <= _io_tx_T @[BusInterface.scala 31:9]
    node _io_reqOut_T = not(io.grant) @[BusInterface.scala 32:28]
    node _io_reqOut_T_1 = and(io.reqIn, _io_reqOut_T) @[BusInterface.scala 32:25]
    io.reqOut <= _io_reqOut_T_1 @[BusInterface.scala 32:13]
    io.ready <= io.grant @[BusInterface.scala 33:13]
    reg axonIDLSBReg : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[BusInterface.scala 36:29]
    node _axonIDLSBReg_T = bits(io.rx, 7, 0) @[BusInterface.scala 37:24]
    axonIDLSBReg <= _axonIDLSBReg_T @[BusInterface.scala 37:16]
    reg synROMReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[BusInterface.scala 39:27]
    node _synROMReg_T = orr(io.rx) @[BusInterface.scala 40:26]
    node _synROMReg_T_1 = bits(io.rx, 10, 8) @[BusInterface.scala 40:46]
    node _synROMReg_T_2 = mux(_synROMReg_T, filterROM[_synROMReg_T_1], UInt<1>("h00")) @[BusInterface.scala 40:19]
    synROMReg <= _synROMReg_T_2 @[BusInterface.scala 40:13]
    node _io_valid_T = bits(synROMReg, 2, 2) @[BusInterface.scala 42:25]
    io.valid <= _io_valid_T @[BusInterface.scala 42:13]
    node _io_axonID_T = bits(synROMReg, 1, 0) @[BusInterface.scala 43:25]
    node _io_axonID_T_1 = cat(_io_axonID_T, axonIDLSBReg) @[BusInterface.scala 43:47]
    io.axonID <= _io_axonID_T_1 @[BusInterface.scala 43:13]
    
  module PriorityMaskRstEncoder : 
    input clock : Clock
    input reset : Reset
    output io : {flip reqs : UInt<1>[8], value : UInt<3>, mask : UInt<1>[8], rst : UInt<1>[8], valid : UInt<1>}
    
    io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 16:12]
    io.valid <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 17:12]
    when io.reqs[0] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[1] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[2] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h02") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[3] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h03") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[4] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h04") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[5] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h05") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[6] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h06") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[7] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h07") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    node _io_mask_0_T = or(io.mask[1], io.reqs[1]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[0] <= _io_mask_0_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_1_T = or(io.mask[2], io.reqs[2]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[1] <= _io_mask_1_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_2_T = or(io.mask[3], io.reqs[3]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[2] <= _io_mask_2_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_3_T = or(io.mask[4], io.reqs[4]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[3] <= _io_mask_3_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_4_T = or(io.mask[5], io.reqs[5]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[4] <= _io_mask_4_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_5_T = or(io.mask[6], io.reqs[6]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[5] <= _io_mask_5_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_6_T = or(io.mask[7], io.reqs[7]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[6] <= _io_mask_6_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_7_T = eq(io.value, UInt<1>("h00")) @[PriorityMaskRstEncoder.scala 30:38]
    io.mask[7] <= _io_mask_7_T @[PriorityMaskRstEncoder.scala 30:26]
    node _io_rst_0_T = eq(UInt<1>("h00"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_0_T_1 = and(_io_rst_0_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[0] <= _io_rst_0_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_1_T = eq(UInt<1>("h01"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_1_T_1 = and(_io_rst_1_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[1] <= _io_rst_1_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_2_T = eq(UInt<2>("h02"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_2_T_1 = and(_io_rst_2_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[2] <= _io_rst_2_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_3_T = eq(UInt<2>("h03"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_3_T_1 = and(_io_rst_3_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[3] <= _io_rst_3_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_4_T = eq(UInt<3>("h04"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_4_T_1 = and(_io_rst_4_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[4] <= _io_rst_4_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_5_T = eq(UInt<3>("h05"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_5_T_1 = and(_io_rst_5_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[5] <= _io_rst_5_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_6_T = eq(UInt<3>("h06"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_6_T_1 = and(_io_rst_6_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[6] <= _io_rst_6_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_7_T = eq(UInt<3>("h07"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_7_T_1 = and(_io_rst_7_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[7] <= _io_rst_7_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    
  module TransmissionSystem : 
    input clock : Clock
    input reset : Reset
    output io : {data : UInt<11>, flip ready : UInt<1>, valid : UInt<1>, flip n : UInt<5>, flip spikes : UInt<1>[8]}
    
    wire _spikeRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[0] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[1] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[2] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[3] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[4] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[5] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[6] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[7] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    reg spikeRegs : UInt<1>[8], clock with : (reset => (reset, _spikeRegs_WIRE)) @[TransmissionSystem.scala 18:29]
    wire _neuronIdMSB_WIRE : UInt<5>[8] @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[0] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[1] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[2] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[3] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[4] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[5] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[6] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[7] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    reg neuronIdMSB : UInt<5>[8], clock with : (reset => (reset, _neuronIdMSB_WIRE)) @[TransmissionSystem.scala 19:29]
    wire _maskRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[0] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[1] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[2] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[3] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[4] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[5] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[6] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[7] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    reg maskRegs : UInt<1>[8], clock with : (reset => (reset, _maskRegs_WIRE)) @[TransmissionSystem.scala 20:29]
    inst spikeEncoder of PriorityMaskRstEncoder @[TransmissionSystem.scala 22:28]
    spikeEncoder.clock <= clock
    spikeEncoder.reset <= reset
    wire encoderReqs : UInt<1>[8] @[TransmissionSystem.scala 23:26]
    wire rstReadySel : UInt<1>[8] @[TransmissionSystem.scala 24:26]
    wire spikeUpdate : UInt<1>[8] @[TransmissionSystem.scala 25:26]
    io.data <= UInt<1>("h00") @[TransmissionSystem.scala 28:12]
    io.valid <= spikeEncoder.io.valid @[TransmissionSystem.scala 29:12]
    spikeEncoder.io.reqs[0] <= encoderReqs[0] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[1] <= encoderReqs[1] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[2] <= encoderReqs[2] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[3] <= encoderReqs[3] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[4] <= encoderReqs[4] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[5] <= encoderReqs[5] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[6] <= encoderReqs[6] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[7] <= encoderReqs[7] @[TransmissionSystem.scala 30:24]
    node _encoderReqs_0_T = and(maskRegs[0], spikeRegs[0]) @[TransmissionSystem.scala 33:35]
    encoderReqs[0] <= _encoderReqs_0_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_0_T = and(spikeEncoder.io.rst[0], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_0_T_1 = not(_rstReadySel_0_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[0] <= _rstReadySel_0_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_0_T = and(rstReadySel[0], spikeRegs[0]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[0] <= _spikeUpdate_0_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[0] <= spikeEncoder.io.mask[0] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T : @[TransmissionSystem.scala 40:40]
        maskRegs[0] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_1 = not(spikeUpdate[0]) @[TransmissionSystem.scala 44:10]
    when _T_1 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[0] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[0] <= io.spikes[0] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_2 = eq(UInt<1>("h00"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_2 : @[TransmissionSystem.scala 49:41]
      node _io_data_T = cat(UInt<3>("h00"), neuronIdMSB[0]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_1 = cat(_io_data_T, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_1 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_1_T = and(maskRegs[1], spikeRegs[1]) @[TransmissionSystem.scala 33:35]
    encoderReqs[1] <= _encoderReqs_1_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_1_T = and(spikeEncoder.io.rst[1], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_1_T_1 = not(_rstReadySel_1_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[1] <= _rstReadySel_1_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_1_T = and(rstReadySel[1], spikeRegs[1]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[1] <= _spikeUpdate_1_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[1] <= spikeEncoder.io.mask[1] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_3 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_3 : @[TransmissionSystem.scala 40:40]
        maskRegs[1] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_4 = not(spikeUpdate[1]) @[TransmissionSystem.scala 44:10]
    when _T_4 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[1] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[1] <= io.spikes[1] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_5 = eq(UInt<1>("h01"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_5 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_2 = cat(UInt<3>("h00"), neuronIdMSB[1]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_3 = cat(_io_data_T_2, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_3 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_2_T = and(maskRegs[2], spikeRegs[2]) @[TransmissionSystem.scala 33:35]
    encoderReqs[2] <= _encoderReqs_2_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_2_T = and(spikeEncoder.io.rst[2], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_2_T_1 = not(_rstReadySel_2_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[2] <= _rstReadySel_2_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_2_T = and(rstReadySel[2], spikeRegs[2]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[2] <= _spikeUpdate_2_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[2] <= spikeEncoder.io.mask[2] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_6 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_6 : @[TransmissionSystem.scala 40:40]
        maskRegs[2] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_7 = not(spikeUpdate[2]) @[TransmissionSystem.scala 44:10]
    when _T_7 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[2] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[2] <= io.spikes[2] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_8 = eq(UInt<2>("h02"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_8 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_4 = cat(UInt<3>("h00"), neuronIdMSB[2]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_5 = cat(_io_data_T_4, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_5 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_3_T = and(maskRegs[3], spikeRegs[3]) @[TransmissionSystem.scala 33:35]
    encoderReqs[3] <= _encoderReqs_3_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_3_T = and(spikeEncoder.io.rst[3], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_3_T_1 = not(_rstReadySel_3_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[3] <= _rstReadySel_3_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_3_T = and(rstReadySel[3], spikeRegs[3]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[3] <= _spikeUpdate_3_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[3] <= spikeEncoder.io.mask[3] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_9 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_9 : @[TransmissionSystem.scala 40:40]
        maskRegs[3] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_10 = not(spikeUpdate[3]) @[TransmissionSystem.scala 44:10]
    when _T_10 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[3] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[3] <= io.spikes[3] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_11 = eq(UInt<2>("h03"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_11 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_6 = cat(UInt<3>("h00"), neuronIdMSB[3]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_7 = cat(_io_data_T_6, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_7 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_4_T = and(maskRegs[4], spikeRegs[4]) @[TransmissionSystem.scala 33:35]
    encoderReqs[4] <= _encoderReqs_4_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_4_T = and(spikeEncoder.io.rst[4], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_4_T_1 = not(_rstReadySel_4_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[4] <= _rstReadySel_4_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_4_T = and(rstReadySel[4], spikeRegs[4]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[4] <= _spikeUpdate_4_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[4] <= spikeEncoder.io.mask[4] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_12 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_12 : @[TransmissionSystem.scala 40:40]
        maskRegs[4] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_13 = not(spikeUpdate[4]) @[TransmissionSystem.scala 44:10]
    when _T_13 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[4] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[4] <= io.spikes[4] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_14 = eq(UInt<3>("h04"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_14 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_8 = cat(UInt<3>("h00"), neuronIdMSB[4]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_9 = cat(_io_data_T_8, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_9 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_5_T = and(maskRegs[5], spikeRegs[5]) @[TransmissionSystem.scala 33:35]
    encoderReqs[5] <= _encoderReqs_5_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_5_T = and(spikeEncoder.io.rst[5], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_5_T_1 = not(_rstReadySel_5_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[5] <= _rstReadySel_5_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_5_T = and(rstReadySel[5], spikeRegs[5]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[5] <= _spikeUpdate_5_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[5] <= spikeEncoder.io.mask[5] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_15 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_15 : @[TransmissionSystem.scala 40:40]
        maskRegs[5] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_16 = not(spikeUpdate[5]) @[TransmissionSystem.scala 44:10]
    when _T_16 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[5] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[5] <= io.spikes[5] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_17 = eq(UInt<3>("h05"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_17 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_10 = cat(UInt<3>("h00"), neuronIdMSB[5]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_11 = cat(_io_data_T_10, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_11 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_6_T = and(maskRegs[6], spikeRegs[6]) @[TransmissionSystem.scala 33:35]
    encoderReqs[6] <= _encoderReqs_6_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_6_T = and(spikeEncoder.io.rst[6], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_6_T_1 = not(_rstReadySel_6_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[6] <= _rstReadySel_6_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_6_T = and(rstReadySel[6], spikeRegs[6]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[6] <= _spikeUpdate_6_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[6] <= spikeEncoder.io.mask[6] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_18 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_18 : @[TransmissionSystem.scala 40:40]
        maskRegs[6] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_19 = not(spikeUpdate[6]) @[TransmissionSystem.scala 44:10]
    when _T_19 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[6] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[6] <= io.spikes[6] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_20 = eq(UInt<3>("h06"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_20 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_12 = cat(UInt<3>("h00"), neuronIdMSB[6]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_13 = cat(_io_data_T_12, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_13 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_7_T = and(maskRegs[7], spikeRegs[7]) @[TransmissionSystem.scala 33:35]
    encoderReqs[7] <= _encoderReqs_7_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_7_T = and(spikeEncoder.io.rst[7], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_7_T_1 = not(_rstReadySel_7_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[7] <= _rstReadySel_7_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_7_T = and(rstReadySel[7], spikeRegs[7]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[7] <= _spikeUpdate_7_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[7] <= spikeEncoder.io.mask[7] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_21 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_21 : @[TransmissionSystem.scala 40:40]
        maskRegs[7] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_22 = not(spikeUpdate[7]) @[TransmissionSystem.scala 44:10]
    when _T_22 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[7] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[7] <= io.spikes[7] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_23 = eq(UInt<3>("h07"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_23 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_14 = cat(UInt<3>("h00"), neuronIdMSB[7]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_15 = cat(_io_data_T_14, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_15 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    
  module InputCore : 
    input clock : Clock
    input reset : Reset
    output io : {pmClkEn : UInt<1>, flip newTS : UInt<1>, flip offCCHSin : UInt<1>, offCCHSout : UInt<1>, memEn : UInt<1>, memAddr : UInt<9>, flip memDo : UInt<9>, flip grant : UInt<1>, req : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, nothing : UInt<3>}
    
    io.nothing <= UInt<1>("h00") @[InputCore.scala 30:14]
    inst interface of BusInterface @[InputCore.scala 33:25]
    interface.clock <= clock
    interface.reset <= reset
    interface.io.grant <= io.grant @[InputCore.scala 34:22]
    io.req <= interface.io.reqOut @[InputCore.scala 35:22]
    io.tx <= interface.io.tx @[InputCore.scala 36:22]
    interface.io.rx <= io.rx @[InputCore.scala 37:22]
    inst spikeTrans of TransmissionSystem @[InputCore.scala 40:26]
    spikeTrans.clock <= clock
    spikeTrans.reset <= reset
    interface.io.spikeID <= spikeTrans.io.data @[InputCore.scala 41:27]
    spikeTrans.io.ready <= interface.io.ready @[InputCore.scala 42:27]
    interface.io.reqIn <= spikeTrans.io.valid @[InputCore.scala 43:27]
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[InputCore.scala 47:23]
    reg ts : UInt<9>, clock with : (reset => (reset, UInt<9>("h00"))) @[InputCore.scala 48:23]
    reg pixCnt : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[InputCore.scala 49:23]
    reg pixCntLate : UInt, clock @[InputCore.scala 50:28]
    pixCntLate <= pixCnt @[InputCore.scala 50:28]
    reg pixCntLater : UInt, clock @[InputCore.scala 51:28]
    pixCntLater <= pixCntLate @[InputCore.scala 51:28]
    wire shouldSpike : UInt<1> @[InputCore.scala 53:26]
    wire _spikePulse_WIRE : UInt<1>[8] @[InputCore.scala 54:37]
    _spikePulse_WIRE[0] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[1] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[2] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[3] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[4] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[5] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[6] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[7] <= UInt<1>("h00") @[InputCore.scala 54:37]
    reg spikePulse : UInt<1>[8], clock with : (reset => (reset, _spikePulse_WIRE)) @[InputCore.scala 54:29]
    wire sPulseDecSig : UInt<4>
    sPulseDecSig <= UInt<4>("h08")
    reg phase : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[InputCore.scala 57:22]
    io.offCCHSout <= phase @[InputCore.scala 58:17]
    node _shouldSpike_res_T = eq(ts, UInt<1>("h00")) @[InputCore.scala 62:22]
    node _shouldSpike_res_T_1 = eq(io.memDo, UInt<1>("h00")) @[InputCore.scala 62:42]
    node _shouldSpike_res_T_2 = or(_shouldSpike_res_T, _shouldSpike_res_T_1) @[InputCore.scala 62:30]
    node _shouldSpike_res_T_3 = rem(ts, io.memDo) @[InputCore.scala 62:59]
    node shouldSpike_res = mux(_shouldSpike_res_T_2, UInt<1>("h01"), _shouldSpike_res_T_3) @[InputCore.scala 62:18]
    node _shouldSpike_T = eq(shouldSpike_res, UInt<1>("h00")) @[InputCore.scala 63:9]
    shouldSpike <= _shouldSpike_T @[InputCore.scala 71:17]
    io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 74:14]
    io.memEn <= UInt<1>("h00") @[InputCore.scala 75:14]
    node _io_memAddr_T = add(pixCnt, UInt<9>("h0100")) @[InputCore.scala 76:35]
    node _io_memAddr_T_1 = tail(_io_memAddr_T, 1) @[InputCore.scala 76:35]
    node _io_memAddr_T_2 = mux(phase, _io_memAddr_T_1, pixCnt) @[InputCore.scala 76:20]
    io.memAddr <= _io_memAddr_T_2 @[InputCore.scala 76:14]
    node _T = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      io.pmClkEn <= UInt<1>("h00") @[InputCore.scala 80:18]
      ts <= UInt<1>("h00") @[InputCore.scala 81:10]
      pixCnt <= UInt<1>("h00") @[InputCore.scala 82:14]
      node _T_1 = neq(io.offCCHSin, phase) @[InputCore.scala 84:25]
      node _T_2 = and(_T_1, io.newTS) @[InputCore.scala 84:35]
      when _T_2 : @[InputCore.scala 84:48]
        io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 85:20]
        state <= UInt<3>("h01") @[InputCore.scala 86:15]
        node _phase_T = eq(phase, UInt<1>("h00")) @[InputCore.scala 87:18]
        phase <= _phase_T @[InputCore.scala 87:15]
        skip @[InputCore.scala 84:48]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        io.memEn <= UInt<1>("h01") @[InputCore.scala 93:16]
        node _pixCnt_T = add(pixCnt, UInt<1>("h01")) @[InputCore.scala 94:24]
        node _pixCnt_T_1 = tail(_pixCnt_T, 1) @[InputCore.scala 94:24]
        pixCnt <= _pixCnt_T_1 @[InputCore.scala 94:14]
        state <= UInt<3>("h02") @[InputCore.scala 96:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          io.memEn <= UInt<1>("h01") @[InputCore.scala 102:16]
          node _pixCnt_T_2 = add(pixCnt, UInt<1>("h01")) @[InputCore.scala 103:24]
          node _pixCnt_T_3 = tail(_pixCnt_T_2, 1) @[InputCore.scala 103:24]
          pixCnt <= _pixCnt_T_3 @[InputCore.scala 103:14]
          when shouldSpike : @[InputCore.scala 104:25]
            node _sPulseDecSig_T = bits(pixCntLate, 2, 0) @[InputCore.scala 105:47]
            node _sPulseDecSig_T_1 = cat(UInt<1>("h00"), _sPulseDecSig_T) @[InputCore.scala 105:34]
            sPulseDecSig <= _sPulseDecSig_T_1 @[InputCore.scala 105:22]
            skip @[InputCore.scala 104:25]
          node _T_5 = eq(pixCnt, UInt<8>("h0ff")) @[InputCore.scala 108:19]
          when _T_5 : @[InputCore.scala 108:43]
            state <= UInt<3>("h03") @[InputCore.scala 109:15]
            skip @[InputCore.scala 108:43]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_6 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_6 : @[Conditional.scala 39:67]
            node _ts_T = add(ts, UInt<1>("h01")) @[InputCore.scala 115:16]
            node _ts_T_1 = tail(_ts_T, 1) @[InputCore.scala 115:16]
            ts <= _ts_T_1 @[InputCore.scala 115:10]
            when shouldSpike : @[InputCore.scala 116:25]
              node _sPulseDecSig_T_2 = bits(pixCntLate, 2, 0) @[InputCore.scala 117:47]
              node _sPulseDecSig_T_3 = cat(UInt<1>("h00"), _sPulseDecSig_T_2) @[InputCore.scala 117:34]
              sPulseDecSig <= _sPulseDecSig_T_3 @[InputCore.scala 117:22]
              skip @[InputCore.scala 116:25]
            state <= UInt<3>("h04") @[InputCore.scala 120:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_7 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_7 : @[Conditional.scala 39:67]
              node _T_8 = eq(interface.io.reqOut, UInt<1>("h00")) @[InputCore.scala 126:12]
              node _T_9 = eq(io.newTS, UInt<1>("h00")) @[InputCore.scala 126:36]
              node _T_10 = and(_T_8, _T_9) @[InputCore.scala 126:33]
              when _T_10 : @[InputCore.scala 126:47]
                io.pmClkEn <= UInt<1>("h00") @[InputCore.scala 127:20]
                skip @[InputCore.scala 126:47]
              when io.newTS : @[InputCore.scala 130:22]
                io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 131:20]
                node _T_11 = eq(ts, UInt<9>("h01f3")) @[InputCore.scala 132:17]
                when _T_11 : @[InputCore.scala 132:28]
                  state <= UInt<3>("h00") @[InputCore.scala 133:17]
                  skip @[InputCore.scala 132:28]
                else : @[InputCore.scala 134:21]
                  state <= UInt<3>("h01") @[InputCore.scala 135:17]
                  skip @[InputCore.scala 134:21]
                skip @[InputCore.scala 130:22]
              skip @[Conditional.scala 39:67]
    spikePulse[0] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_12 = eq(sPulseDecSig, UInt<1>("h00")) @[InputCore.scala 144:24]
    when _T_12 : @[InputCore.scala 144:33]
      spikePulse[0] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[1] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_13 = eq(sPulseDecSig, UInt<1>("h01")) @[InputCore.scala 144:24]
    when _T_13 : @[InputCore.scala 144:33]
      spikePulse[1] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[2] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_14 = eq(sPulseDecSig, UInt<2>("h02")) @[InputCore.scala 144:24]
    when _T_14 : @[InputCore.scala 144:33]
      spikePulse[2] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[3] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_15 = eq(sPulseDecSig, UInt<2>("h03")) @[InputCore.scala 144:24]
    when _T_15 : @[InputCore.scala 144:33]
      spikePulse[3] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[4] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_16 = eq(sPulseDecSig, UInt<3>("h04")) @[InputCore.scala 144:24]
    when _T_16 : @[InputCore.scala 144:33]
      spikePulse[4] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[5] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_17 = eq(sPulseDecSig, UInt<3>("h05")) @[InputCore.scala 144:24]
    when _T_17 : @[InputCore.scala 144:33]
      spikePulse[5] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[6] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_18 = eq(sPulseDecSig, UInt<3>("h06")) @[InputCore.scala 144:24]
    when _T_18 : @[InputCore.scala 144:33]
      spikePulse[6] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[7] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_19 = eq(sPulseDecSig, UInt<3>("h07")) @[InputCore.scala 144:24]
    when _T_19 : @[InputCore.scala 144:33]
      spikePulse[7] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    node _spikeTrans_io_n_T = bits(pixCntLater, 7, 3) @[InputCore.scala 150:33]
    spikeTrans.io.n <= _spikeTrans_io_n_T @[InputCore.scala 150:19]
    spikeTrans.io.spikes[0] <= spikePulse[0] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[1] <= spikePulse[1] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[2] <= spikePulse[2] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[3] <= spikePulse[3] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[4] <= spikePulse[4] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[5] <= spikePulse[5] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[6] <= spikePulse[6] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[7] <= spikePulse[7] @[InputCore.scala 152:29]
    
  module BusInterface_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip grant : UInt<1>, reqOut : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, axonID : UInt<10>, valid : UInt<1>, flip spikeID : UInt<11>, ready : UInt<1>, flip reqIn : UInt<1>}
    
    wire filterROM : UInt<3>[5] @[BusInterface.scala 28:27]
    filterROM[0] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[1] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[2] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[3] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[4] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    node _io_tx_T = mux(io.grant, io.spikeID, UInt<1>("h00")) @[BusInterface.scala 31:15]
    io.tx <= _io_tx_T @[BusInterface.scala 31:9]
    node _io_reqOut_T = not(io.grant) @[BusInterface.scala 32:28]
    node _io_reqOut_T_1 = and(io.reqIn, _io_reqOut_T) @[BusInterface.scala 32:25]
    io.reqOut <= _io_reqOut_T_1 @[BusInterface.scala 32:13]
    io.ready <= io.grant @[BusInterface.scala 33:13]
    reg axonIDLSBReg : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[BusInterface.scala 36:29]
    node _axonIDLSBReg_T = bits(io.rx, 7, 0) @[BusInterface.scala 37:24]
    axonIDLSBReg <= _axonIDLSBReg_T @[BusInterface.scala 37:16]
    reg synROMReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[BusInterface.scala 39:27]
    node _synROMReg_T = orr(io.rx) @[BusInterface.scala 40:26]
    node _synROMReg_T_1 = bits(io.rx, 10, 8) @[BusInterface.scala 40:46]
    node _synROMReg_T_2 = mux(_synROMReg_T, filterROM[_synROMReg_T_1], UInt<1>("h00")) @[BusInterface.scala 40:19]
    synROMReg <= _synROMReg_T_2 @[BusInterface.scala 40:13]
    node _io_valid_T = bits(synROMReg, 2, 2) @[BusInterface.scala 42:25]
    io.valid <= _io_valid_T @[BusInterface.scala 42:13]
    node _io_axonID_T = bits(synROMReg, 1, 0) @[BusInterface.scala 43:25]
    node _io_axonID_T_1 = cat(_io_axonID_T, axonIDLSBReg) @[BusInterface.scala 43:47]
    io.axonID <= _io_axonID_T_1 @[BusInterface.scala 43:13]
    
  module PriorityMaskRstEncoder_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip reqs : UInt<1>[8], value : UInt<3>, mask : UInt<1>[8], rst : UInt<1>[8], valid : UInt<1>}
    
    io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 16:12]
    io.valid <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 17:12]
    when io.reqs[0] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[1] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[2] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h02") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[3] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h03") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[4] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h04") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[5] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h05") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[6] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h06") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[7] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h07") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    node _io_mask_0_T = or(io.mask[1], io.reqs[1]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[0] <= _io_mask_0_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_1_T = or(io.mask[2], io.reqs[2]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[1] <= _io_mask_1_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_2_T = or(io.mask[3], io.reqs[3]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[2] <= _io_mask_2_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_3_T = or(io.mask[4], io.reqs[4]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[3] <= _io_mask_3_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_4_T = or(io.mask[5], io.reqs[5]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[4] <= _io_mask_4_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_5_T = or(io.mask[6], io.reqs[6]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[5] <= _io_mask_5_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_6_T = or(io.mask[7], io.reqs[7]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[6] <= _io_mask_6_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_7_T = eq(io.value, UInt<1>("h00")) @[PriorityMaskRstEncoder.scala 30:38]
    io.mask[7] <= _io_mask_7_T @[PriorityMaskRstEncoder.scala 30:26]
    node _io_rst_0_T = eq(UInt<1>("h00"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_0_T_1 = and(_io_rst_0_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[0] <= _io_rst_0_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_1_T = eq(UInt<1>("h01"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_1_T_1 = and(_io_rst_1_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[1] <= _io_rst_1_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_2_T = eq(UInt<2>("h02"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_2_T_1 = and(_io_rst_2_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[2] <= _io_rst_2_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_3_T = eq(UInt<2>("h03"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_3_T_1 = and(_io_rst_3_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[3] <= _io_rst_3_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_4_T = eq(UInt<3>("h04"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_4_T_1 = and(_io_rst_4_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[4] <= _io_rst_4_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_5_T = eq(UInt<3>("h05"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_5_T_1 = and(_io_rst_5_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[5] <= _io_rst_5_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_6_T = eq(UInt<3>("h06"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_6_T_1 = and(_io_rst_6_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[6] <= _io_rst_6_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_7_T = eq(UInt<3>("h07"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_7_T_1 = and(_io_rst_7_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[7] <= _io_rst_7_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    
  module TransmissionSystem_1 : 
    input clock : Clock
    input reset : Reset
    output io : {data : UInt<11>, flip ready : UInt<1>, valid : UInt<1>, flip n : UInt<5>, flip spikes : UInt<1>[8]}
    
    wire _spikeRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[0] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[1] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[2] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[3] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[4] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[5] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[6] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[7] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    reg spikeRegs : UInt<1>[8], clock with : (reset => (reset, _spikeRegs_WIRE)) @[TransmissionSystem.scala 18:29]
    wire _neuronIdMSB_WIRE : UInt<5>[8] @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[0] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[1] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[2] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[3] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[4] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[5] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[6] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[7] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    reg neuronIdMSB : UInt<5>[8], clock with : (reset => (reset, _neuronIdMSB_WIRE)) @[TransmissionSystem.scala 19:29]
    wire _maskRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[0] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[1] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[2] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[3] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[4] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[5] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[6] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[7] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    reg maskRegs : UInt<1>[8], clock with : (reset => (reset, _maskRegs_WIRE)) @[TransmissionSystem.scala 20:29]
    inst spikeEncoder of PriorityMaskRstEncoder_1 @[TransmissionSystem.scala 22:28]
    spikeEncoder.clock <= clock
    spikeEncoder.reset <= reset
    wire encoderReqs : UInt<1>[8] @[TransmissionSystem.scala 23:26]
    wire rstReadySel : UInt<1>[8] @[TransmissionSystem.scala 24:26]
    wire spikeUpdate : UInt<1>[8] @[TransmissionSystem.scala 25:26]
    io.data <= UInt<1>("h00") @[TransmissionSystem.scala 28:12]
    io.valid <= spikeEncoder.io.valid @[TransmissionSystem.scala 29:12]
    spikeEncoder.io.reqs[0] <= encoderReqs[0] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[1] <= encoderReqs[1] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[2] <= encoderReqs[2] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[3] <= encoderReqs[3] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[4] <= encoderReqs[4] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[5] <= encoderReqs[5] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[6] <= encoderReqs[6] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[7] <= encoderReqs[7] @[TransmissionSystem.scala 30:24]
    node _encoderReqs_0_T = and(maskRegs[0], spikeRegs[0]) @[TransmissionSystem.scala 33:35]
    encoderReqs[0] <= _encoderReqs_0_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_0_T = and(spikeEncoder.io.rst[0], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_0_T_1 = not(_rstReadySel_0_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[0] <= _rstReadySel_0_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_0_T = and(rstReadySel[0], spikeRegs[0]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[0] <= _spikeUpdate_0_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[0] <= spikeEncoder.io.mask[0] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T : @[TransmissionSystem.scala 40:40]
        maskRegs[0] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_1 = not(spikeUpdate[0]) @[TransmissionSystem.scala 44:10]
    when _T_1 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[0] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[0] <= io.spikes[0] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_2 = eq(UInt<1>("h00"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_2 : @[TransmissionSystem.scala 49:41]
      node _io_data_T = cat(UInt<3>("h01"), neuronIdMSB[0]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_1 = cat(_io_data_T, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_1 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_1_T = and(maskRegs[1], spikeRegs[1]) @[TransmissionSystem.scala 33:35]
    encoderReqs[1] <= _encoderReqs_1_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_1_T = and(spikeEncoder.io.rst[1], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_1_T_1 = not(_rstReadySel_1_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[1] <= _rstReadySel_1_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_1_T = and(rstReadySel[1], spikeRegs[1]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[1] <= _spikeUpdate_1_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[1] <= spikeEncoder.io.mask[1] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_3 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_3 : @[TransmissionSystem.scala 40:40]
        maskRegs[1] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_4 = not(spikeUpdate[1]) @[TransmissionSystem.scala 44:10]
    when _T_4 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[1] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[1] <= io.spikes[1] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_5 = eq(UInt<1>("h01"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_5 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_2 = cat(UInt<3>("h01"), neuronIdMSB[1]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_3 = cat(_io_data_T_2, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_3 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_2_T = and(maskRegs[2], spikeRegs[2]) @[TransmissionSystem.scala 33:35]
    encoderReqs[2] <= _encoderReqs_2_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_2_T = and(spikeEncoder.io.rst[2], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_2_T_1 = not(_rstReadySel_2_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[2] <= _rstReadySel_2_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_2_T = and(rstReadySel[2], spikeRegs[2]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[2] <= _spikeUpdate_2_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[2] <= spikeEncoder.io.mask[2] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_6 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_6 : @[TransmissionSystem.scala 40:40]
        maskRegs[2] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_7 = not(spikeUpdate[2]) @[TransmissionSystem.scala 44:10]
    when _T_7 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[2] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[2] <= io.spikes[2] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_8 = eq(UInt<2>("h02"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_8 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_4 = cat(UInt<3>("h01"), neuronIdMSB[2]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_5 = cat(_io_data_T_4, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_5 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_3_T = and(maskRegs[3], spikeRegs[3]) @[TransmissionSystem.scala 33:35]
    encoderReqs[3] <= _encoderReqs_3_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_3_T = and(spikeEncoder.io.rst[3], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_3_T_1 = not(_rstReadySel_3_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[3] <= _rstReadySel_3_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_3_T = and(rstReadySel[3], spikeRegs[3]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[3] <= _spikeUpdate_3_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[3] <= spikeEncoder.io.mask[3] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_9 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_9 : @[TransmissionSystem.scala 40:40]
        maskRegs[3] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_10 = not(spikeUpdate[3]) @[TransmissionSystem.scala 44:10]
    when _T_10 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[3] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[3] <= io.spikes[3] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_11 = eq(UInt<2>("h03"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_11 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_6 = cat(UInt<3>("h01"), neuronIdMSB[3]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_7 = cat(_io_data_T_6, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_7 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_4_T = and(maskRegs[4], spikeRegs[4]) @[TransmissionSystem.scala 33:35]
    encoderReqs[4] <= _encoderReqs_4_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_4_T = and(spikeEncoder.io.rst[4], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_4_T_1 = not(_rstReadySel_4_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[4] <= _rstReadySel_4_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_4_T = and(rstReadySel[4], spikeRegs[4]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[4] <= _spikeUpdate_4_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[4] <= spikeEncoder.io.mask[4] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_12 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_12 : @[TransmissionSystem.scala 40:40]
        maskRegs[4] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_13 = not(spikeUpdate[4]) @[TransmissionSystem.scala 44:10]
    when _T_13 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[4] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[4] <= io.spikes[4] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_14 = eq(UInt<3>("h04"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_14 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_8 = cat(UInt<3>("h01"), neuronIdMSB[4]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_9 = cat(_io_data_T_8, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_9 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_5_T = and(maskRegs[5], spikeRegs[5]) @[TransmissionSystem.scala 33:35]
    encoderReqs[5] <= _encoderReqs_5_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_5_T = and(spikeEncoder.io.rst[5], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_5_T_1 = not(_rstReadySel_5_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[5] <= _rstReadySel_5_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_5_T = and(rstReadySel[5], spikeRegs[5]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[5] <= _spikeUpdate_5_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[5] <= spikeEncoder.io.mask[5] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_15 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_15 : @[TransmissionSystem.scala 40:40]
        maskRegs[5] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_16 = not(spikeUpdate[5]) @[TransmissionSystem.scala 44:10]
    when _T_16 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[5] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[5] <= io.spikes[5] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_17 = eq(UInt<3>("h05"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_17 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_10 = cat(UInt<3>("h01"), neuronIdMSB[5]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_11 = cat(_io_data_T_10, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_11 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_6_T = and(maskRegs[6], spikeRegs[6]) @[TransmissionSystem.scala 33:35]
    encoderReqs[6] <= _encoderReqs_6_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_6_T = and(spikeEncoder.io.rst[6], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_6_T_1 = not(_rstReadySel_6_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[6] <= _rstReadySel_6_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_6_T = and(rstReadySel[6], spikeRegs[6]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[6] <= _spikeUpdate_6_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[6] <= spikeEncoder.io.mask[6] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_18 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_18 : @[TransmissionSystem.scala 40:40]
        maskRegs[6] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_19 = not(spikeUpdate[6]) @[TransmissionSystem.scala 44:10]
    when _T_19 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[6] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[6] <= io.spikes[6] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_20 = eq(UInt<3>("h06"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_20 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_12 = cat(UInt<3>("h01"), neuronIdMSB[6]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_13 = cat(_io_data_T_12, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_13 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_7_T = and(maskRegs[7], spikeRegs[7]) @[TransmissionSystem.scala 33:35]
    encoderReqs[7] <= _encoderReqs_7_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_7_T = and(spikeEncoder.io.rst[7], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_7_T_1 = not(_rstReadySel_7_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[7] <= _rstReadySel_7_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_7_T = and(rstReadySel[7], spikeRegs[7]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[7] <= _spikeUpdate_7_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[7] <= spikeEncoder.io.mask[7] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_21 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_21 : @[TransmissionSystem.scala 40:40]
        maskRegs[7] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_22 = not(spikeUpdate[7]) @[TransmissionSystem.scala 44:10]
    when _T_22 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[7] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[7] <= io.spikes[7] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_23 = eq(UInt<3>("h07"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_23 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_14 = cat(UInt<3>("h01"), neuronIdMSB[7]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_15 = cat(_io_data_T_14, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_15 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    
  module InputCore_1 : 
    input clock : Clock
    input reset : Reset
    output io : {pmClkEn : UInt<1>, flip newTS : UInt<1>, flip offCCHSin : UInt<1>, offCCHSout : UInt<1>, memEn : UInt<1>, memAddr : UInt<9>, flip memDo : UInt<9>, flip grant : UInt<1>, req : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, nothing : UInt<3>}
    
    io.nothing <= UInt<1>("h01") @[InputCore.scala 30:14]
    inst interface of BusInterface_1 @[InputCore.scala 33:25]
    interface.clock <= clock
    interface.reset <= reset
    interface.io.grant <= io.grant @[InputCore.scala 34:22]
    io.req <= interface.io.reqOut @[InputCore.scala 35:22]
    io.tx <= interface.io.tx @[InputCore.scala 36:22]
    interface.io.rx <= io.rx @[InputCore.scala 37:22]
    inst spikeTrans of TransmissionSystem_1 @[InputCore.scala 40:26]
    spikeTrans.clock <= clock
    spikeTrans.reset <= reset
    interface.io.spikeID <= spikeTrans.io.data @[InputCore.scala 41:27]
    spikeTrans.io.ready <= interface.io.ready @[InputCore.scala 42:27]
    interface.io.reqIn <= spikeTrans.io.valid @[InputCore.scala 43:27]
    reg state : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[InputCore.scala 47:23]
    reg ts : UInt<9>, clock with : (reset => (reset, UInt<9>("h00"))) @[InputCore.scala 48:23]
    reg pixCnt : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[InputCore.scala 49:23]
    reg pixCntLate : UInt, clock @[InputCore.scala 50:28]
    pixCntLate <= pixCnt @[InputCore.scala 50:28]
    reg pixCntLater : UInt, clock @[InputCore.scala 51:28]
    pixCntLater <= pixCntLate @[InputCore.scala 51:28]
    wire shouldSpike : UInt<1> @[InputCore.scala 53:26]
    wire _spikePulse_WIRE : UInt<1>[8] @[InputCore.scala 54:37]
    _spikePulse_WIRE[0] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[1] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[2] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[3] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[4] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[5] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[6] <= UInt<1>("h00") @[InputCore.scala 54:37]
    _spikePulse_WIRE[7] <= UInt<1>("h00") @[InputCore.scala 54:37]
    reg spikePulse : UInt<1>[8], clock with : (reset => (reset, _spikePulse_WIRE)) @[InputCore.scala 54:29]
    wire sPulseDecSig : UInt<4>
    sPulseDecSig <= UInt<4>("h08")
    reg phase : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[InputCore.scala 57:22]
    io.offCCHSout <= phase @[InputCore.scala 58:17]
    node _shouldSpike_res_T = eq(ts, UInt<1>("h00")) @[InputCore.scala 62:22]
    node _shouldSpike_res_T_1 = eq(io.memDo, UInt<1>("h00")) @[InputCore.scala 62:42]
    node _shouldSpike_res_T_2 = or(_shouldSpike_res_T, _shouldSpike_res_T_1) @[InputCore.scala 62:30]
    node _shouldSpike_res_T_3 = rem(ts, io.memDo) @[InputCore.scala 62:59]
    node shouldSpike_res = mux(_shouldSpike_res_T_2, UInt<1>("h01"), _shouldSpike_res_T_3) @[InputCore.scala 62:18]
    node _shouldSpike_T = eq(shouldSpike_res, UInt<1>("h00")) @[InputCore.scala 63:9]
    shouldSpike <= _shouldSpike_T @[InputCore.scala 71:17]
    io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 74:14]
    io.memEn <= UInt<1>("h00") @[InputCore.scala 75:14]
    node _io_memAddr_T = add(pixCnt, UInt<9>("h0100")) @[InputCore.scala 76:35]
    node _io_memAddr_T_1 = tail(_io_memAddr_T, 1) @[InputCore.scala 76:35]
    node _io_memAddr_T_2 = mux(phase, _io_memAddr_T_1, pixCnt) @[InputCore.scala 76:20]
    io.memAddr <= _io_memAddr_T_2 @[InputCore.scala 76:14]
    node _T = eq(UInt<3>("h00"), state) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      io.pmClkEn <= UInt<1>("h00") @[InputCore.scala 80:18]
      ts <= UInt<1>("h00") @[InputCore.scala 81:10]
      pixCnt <= UInt<1>("h00") @[InputCore.scala 82:14]
      node _T_1 = neq(io.offCCHSin, phase) @[InputCore.scala 84:25]
      node _T_2 = and(_T_1, io.newTS) @[InputCore.scala 84:35]
      when _T_2 : @[InputCore.scala 84:48]
        io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 85:20]
        state <= UInt<3>("h01") @[InputCore.scala 86:15]
        node _phase_T = eq(phase, UInt<1>("h00")) @[InputCore.scala 87:18]
        phase <= _phase_T @[InputCore.scala 87:15]
        skip @[InputCore.scala 84:48]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<3>("h01"), state) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        io.memEn <= UInt<1>("h01") @[InputCore.scala 93:16]
        node _pixCnt_T = add(pixCnt, UInt<1>("h01")) @[InputCore.scala 94:24]
        node _pixCnt_T_1 = tail(_pixCnt_T, 1) @[InputCore.scala 94:24]
        pixCnt <= _pixCnt_T_1 @[InputCore.scala 94:14]
        state <= UInt<3>("h02") @[InputCore.scala 96:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<3>("h02"), state) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          io.memEn <= UInt<1>("h01") @[InputCore.scala 102:16]
          node _pixCnt_T_2 = add(pixCnt, UInt<1>("h01")) @[InputCore.scala 103:24]
          node _pixCnt_T_3 = tail(_pixCnt_T_2, 1) @[InputCore.scala 103:24]
          pixCnt <= _pixCnt_T_3 @[InputCore.scala 103:14]
          when shouldSpike : @[InputCore.scala 104:25]
            node _sPulseDecSig_T = bits(pixCntLate, 2, 0) @[InputCore.scala 105:47]
            node _sPulseDecSig_T_1 = cat(UInt<1>("h00"), _sPulseDecSig_T) @[InputCore.scala 105:34]
            sPulseDecSig <= _sPulseDecSig_T_1 @[InputCore.scala 105:22]
            skip @[InputCore.scala 104:25]
          node _T_5 = eq(pixCnt, UInt<8>("h0ff")) @[InputCore.scala 108:19]
          when _T_5 : @[InputCore.scala 108:43]
            state <= UInt<3>("h03") @[InputCore.scala 109:15]
            skip @[InputCore.scala 108:43]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_6 = eq(UInt<3>("h03"), state) @[Conditional.scala 37:30]
          when _T_6 : @[Conditional.scala 39:67]
            node _ts_T = add(ts, UInt<1>("h01")) @[InputCore.scala 115:16]
            node _ts_T_1 = tail(_ts_T, 1) @[InputCore.scala 115:16]
            ts <= _ts_T_1 @[InputCore.scala 115:10]
            when shouldSpike : @[InputCore.scala 116:25]
              node _sPulseDecSig_T_2 = bits(pixCntLate, 2, 0) @[InputCore.scala 117:47]
              node _sPulseDecSig_T_3 = cat(UInt<1>("h00"), _sPulseDecSig_T_2) @[InputCore.scala 117:34]
              sPulseDecSig <= _sPulseDecSig_T_3 @[InputCore.scala 117:22]
              skip @[InputCore.scala 116:25]
            state <= UInt<3>("h04") @[InputCore.scala 120:13]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_7 = eq(UInt<3>("h04"), state) @[Conditional.scala 37:30]
            when _T_7 : @[Conditional.scala 39:67]
              node _T_8 = eq(interface.io.reqOut, UInt<1>("h00")) @[InputCore.scala 126:12]
              node _T_9 = eq(io.newTS, UInt<1>("h00")) @[InputCore.scala 126:36]
              node _T_10 = and(_T_8, _T_9) @[InputCore.scala 126:33]
              when _T_10 : @[InputCore.scala 126:47]
                io.pmClkEn <= UInt<1>("h00") @[InputCore.scala 127:20]
                skip @[InputCore.scala 126:47]
              when io.newTS : @[InputCore.scala 130:22]
                io.pmClkEn <= UInt<1>("h01") @[InputCore.scala 131:20]
                node _T_11 = eq(ts, UInt<9>("h01f3")) @[InputCore.scala 132:17]
                when _T_11 : @[InputCore.scala 132:28]
                  state <= UInt<3>("h00") @[InputCore.scala 133:17]
                  skip @[InputCore.scala 132:28]
                else : @[InputCore.scala 134:21]
                  state <= UInt<3>("h01") @[InputCore.scala 135:17]
                  skip @[InputCore.scala 134:21]
                skip @[InputCore.scala 130:22]
              skip @[Conditional.scala 39:67]
    spikePulse[0] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_12 = eq(sPulseDecSig, UInt<1>("h00")) @[InputCore.scala 144:24]
    when _T_12 : @[InputCore.scala 144:33]
      spikePulse[0] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[1] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_13 = eq(sPulseDecSig, UInt<1>("h01")) @[InputCore.scala 144:24]
    when _T_13 : @[InputCore.scala 144:33]
      spikePulse[1] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[2] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_14 = eq(sPulseDecSig, UInt<2>("h02")) @[InputCore.scala 144:24]
    when _T_14 : @[InputCore.scala 144:33]
      spikePulse[2] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[3] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_15 = eq(sPulseDecSig, UInt<2>("h03")) @[InputCore.scala 144:24]
    when _T_15 : @[InputCore.scala 144:33]
      spikePulse[3] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[4] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_16 = eq(sPulseDecSig, UInt<3>("h04")) @[InputCore.scala 144:24]
    when _T_16 : @[InputCore.scala 144:33]
      spikePulse[4] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[5] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_17 = eq(sPulseDecSig, UInt<3>("h05")) @[InputCore.scala 144:24]
    when _T_17 : @[InputCore.scala 144:33]
      spikePulse[5] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[6] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_18 = eq(sPulseDecSig, UInt<3>("h06")) @[InputCore.scala 144:24]
    when _T_18 : @[InputCore.scala 144:33]
      spikePulse[6] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    spikePulse[7] <= UInt<1>("h00") @[InputCore.scala 143:19]
    node _T_19 = eq(sPulseDecSig, UInt<3>("h07")) @[InputCore.scala 144:24]
    when _T_19 : @[InputCore.scala 144:33]
      spikePulse[7] <= UInt<1>("h01") @[InputCore.scala 145:21]
      skip @[InputCore.scala 144:33]
    node _spikeTrans_io_n_T = bits(pixCntLater, 7, 3) @[InputCore.scala 150:33]
    spikeTrans.io.n <= _spikeTrans_io_n_T @[InputCore.scala 150:19]
    spikeTrans.io.spikes[0] <= spikePulse[0] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[1] <= spikePulse[1] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[2] <= spikePulse[2] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[3] <= spikePulse[3] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[4] <= spikePulse[4] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[5] <= spikePulse[5] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[6] <= spikePulse[6] @[InputCore.scala 152:29]
    spikeTrans.io.spikes[7] <= spikePulse[7] @[InputCore.scala 152:29]
    
  module BusInterface_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip grant : UInt<1>, reqOut : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, axonID : UInt<10>, valid : UInt<1>, flip spikeID : UInt<11>, ready : UInt<1>, flip reqIn : UInt<1>}
    
    wire filterROM : UInt<3>[5] @[BusInterface.scala 28:27]
    filterROM[0] <= UInt<3>("h04") @[BusInterface.scala 28:27]
    filterROM[1] <= UInt<3>("h05") @[BusInterface.scala 28:27]
    filterROM[2] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[3] <= UInt<3>("h06") @[BusInterface.scala 28:27]
    filterROM[4] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    node _io_tx_T = mux(io.grant, io.spikeID, UInt<1>("h00")) @[BusInterface.scala 31:15]
    io.tx <= _io_tx_T @[BusInterface.scala 31:9]
    node _io_reqOut_T = not(io.grant) @[BusInterface.scala 32:28]
    node _io_reqOut_T_1 = and(io.reqIn, _io_reqOut_T) @[BusInterface.scala 32:25]
    io.reqOut <= _io_reqOut_T_1 @[BusInterface.scala 32:13]
    io.ready <= io.grant @[BusInterface.scala 33:13]
    reg axonIDLSBReg : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[BusInterface.scala 36:29]
    node _axonIDLSBReg_T = bits(io.rx, 7, 0) @[BusInterface.scala 37:24]
    axonIDLSBReg <= _axonIDLSBReg_T @[BusInterface.scala 37:16]
    reg synROMReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[BusInterface.scala 39:27]
    node _synROMReg_T = orr(io.rx) @[BusInterface.scala 40:26]
    node _synROMReg_T_1 = bits(io.rx, 10, 8) @[BusInterface.scala 40:46]
    node _synROMReg_T_2 = mux(_synROMReg_T, filterROM[_synROMReg_T_1], UInt<1>("h00")) @[BusInterface.scala 40:19]
    synROMReg <= _synROMReg_T_2 @[BusInterface.scala 40:13]
    node _io_valid_T = bits(synROMReg, 2, 2) @[BusInterface.scala 42:25]
    io.valid <= _io_valid_T @[BusInterface.scala 42:13]
    node _io_axonID_T = bits(synROMReg, 1, 0) @[BusInterface.scala 43:25]
    node _io_axonID_T_1 = cat(_io_axonID_T, axonIDLSBReg) @[BusInterface.scala 43:47]
    io.axonID <= _io_axonID_T_1 @[BusInterface.scala 43:13]
    
  module AxonSystem : 
    input clock : Clock
    input reset : Reset
    output io : {flip axonIn : UInt<10>, flip axonValid : UInt<1>, flip inOut : UInt<1>, spikeCnt : UInt<10>, flip rAddr : UInt<10>, flip rEna : UInt<1>, rData : UInt<10>}
    
    reg inOutReg : UInt<1>, clock @[AxonSystem.scala 21:25]
    inOutReg <= io.inOut @[AxonSystem.scala 21:25]
    reg spikeCntReg : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[AxonSystem.scala 22:28]
    node _T = neq(inOutReg, io.inOut) @[AxonSystem.scala 23:17]
    when _T : @[AxonSystem.scala 23:31]
      spikeCntReg <= UInt<1>("h00") @[AxonSystem.scala 24:17]
      skip @[AxonSystem.scala 23:31]
    else : @[AxonSystem.scala 25:28]
      when io.axonValid : @[AxonSystem.scala 25:28]
        node _spikeCntReg_T = add(spikeCntReg, UInt<1>("h01")) @[AxonSystem.scala 26:32]
        node _spikeCntReg_T_1 = tail(_spikeCntReg_T, 1) @[AxonSystem.scala 26:32]
        spikeCntReg <= _spikeCntReg_T_1 @[AxonSystem.scala 26:17]
        skip @[AxonSystem.scala 25:28]
    io.spikeCnt <= spikeCntReg @[AxonSystem.scala 28:15]
    wire ena0 : UInt<1> @[AxonSystem.scala 31:22]
    wire wr0 : UInt<1> @[AxonSystem.scala 32:22]
    wire rdata0 : UInt<10> @[AxonSystem.scala 33:22]
    wire wdata0 : UInt<10> @[AxonSystem.scala 34:22]
    wire addr0 : UInt<10> @[AxonSystem.scala 35:22]
    smem axonMem0 : UInt<10>[1024], undefined @[AxonSystem.scala 36:29]
    rdata0 is invalid @[AxonSystem.scala 38:10]
    when ena0 : @[AxonSystem.scala 39:14]
      when wr0 : @[AxonSystem.scala 40:15]
        infer mport MPORT = axonMem0[addr0], clock @[AxonSystem.scala 41:15]
        MPORT <= wdata0 @[AxonSystem.scala 41:23]
        skip @[AxonSystem.scala 40:15]
      else : @[AxonSystem.scala 42:17]
        infer mport rdata0_MPORT = axonMem0[addr0], clock @[AxonSystem.scala 43:25]
        rdata0 <= rdata0_MPORT @[AxonSystem.scala 43:14]
        skip @[AxonSystem.scala 42:17]
      skip @[AxonSystem.scala 39:14]
    wire ena1 : UInt<1> @[AxonSystem.scala 47:22]
    wire wr1 : UInt<1> @[AxonSystem.scala 48:22]
    wire rdata1 : UInt<10> @[AxonSystem.scala 49:22]
    wire wdata1 : UInt<10> @[AxonSystem.scala 50:22]
    wire addr1 : UInt<10> @[AxonSystem.scala 51:22]
    smem axonMem1 : UInt<10>[1024], undefined @[AxonSystem.scala 52:29]
    rdata1 is invalid @[AxonSystem.scala 54:10]
    when ena1 : @[AxonSystem.scala 55:14]
      when wr1 : @[AxonSystem.scala 56:15]
        infer mport MPORT_1 = axonMem1[addr1], clock @[AxonSystem.scala 57:15]
        MPORT_1 <= wdata1 @[AxonSystem.scala 57:23]
        skip @[AxonSystem.scala 56:15]
      else : @[AxonSystem.scala 58:17]
        infer mport rdata1_MPORT = axonMem1[addr1], clock @[AxonSystem.scala 59:25]
        rdata1 <= rdata1_MPORT @[AxonSystem.scala 59:14]
        skip @[AxonSystem.scala 58:17]
      skip @[AxonSystem.scala 55:14]
    node _T_1 = not(io.inOut) @[AxonSystem.scala 64:8]
    when _T_1 : @[AxonSystem.scala 64:19]
      ena0 <= io.axonValid @[AxonSystem.scala 65:12]
      wr0 <= UInt<1>("h01") @[AxonSystem.scala 66:12]
      wdata0 <= io.axonIn @[AxonSystem.scala 67:12]
      addr0 <= spikeCntReg @[AxonSystem.scala 68:12]
      ena1 <= io.rEna @[AxonSystem.scala 70:14]
      wr1 <= UInt<1>("h00") @[AxonSystem.scala 71:14]
      io.rData <= rdata1 @[AxonSystem.scala 72:14]
      wdata1 <= UInt<1>("h00") @[AxonSystem.scala 73:14]
      addr1 <= io.rAddr @[AxonSystem.scala 74:14]
      skip @[AxonSystem.scala 64:19]
    else : @[AxonSystem.scala 75:15]
      ena0 <= io.rEna @[AxonSystem.scala 76:14]
      wr0 <= UInt<1>("h00") @[AxonSystem.scala 77:14]
      io.rData <= rdata0 @[AxonSystem.scala 78:14]
      wdata0 <= UInt<1>("h00") @[AxonSystem.scala 79:14]
      addr0 <= io.rAddr @[AxonSystem.scala 80:14]
      ena1 <= io.axonValid @[AxonSystem.scala 82:14]
      wr1 <= UInt<1>("h01") @[AxonSystem.scala 83:14]
      wdata1 <= io.axonIn @[AxonSystem.scala 84:14]
      addr1 <= spikeCntReg @[AxonSystem.scala 85:14]
      skip @[AxonSystem.scala 75:15]
    
  module PriorityMaskRstEncoder_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip reqs : UInt<1>[8], value : UInt<3>, mask : UInt<1>[8], rst : UInt<1>[8], valid : UInt<1>}
    
    io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 16:12]
    io.valid <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 17:12]
    when io.reqs[0] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[1] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[2] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h02") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[3] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h03") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[4] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h04") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[5] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h05") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[6] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h06") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[7] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h07") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    node _io_mask_0_T = or(io.mask[1], io.reqs[1]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[0] <= _io_mask_0_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_1_T = or(io.mask[2], io.reqs[2]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[1] <= _io_mask_1_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_2_T = or(io.mask[3], io.reqs[3]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[2] <= _io_mask_2_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_3_T = or(io.mask[4], io.reqs[4]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[3] <= _io_mask_3_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_4_T = or(io.mask[5], io.reqs[5]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[4] <= _io_mask_4_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_5_T = or(io.mask[6], io.reqs[6]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[5] <= _io_mask_5_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_6_T = or(io.mask[7], io.reqs[7]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[6] <= _io_mask_6_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_7_T = eq(io.value, UInt<1>("h00")) @[PriorityMaskRstEncoder.scala 30:38]
    io.mask[7] <= _io_mask_7_T @[PriorityMaskRstEncoder.scala 30:26]
    node _io_rst_0_T = eq(UInt<1>("h00"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_0_T_1 = and(_io_rst_0_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[0] <= _io_rst_0_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_1_T = eq(UInt<1>("h01"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_1_T_1 = and(_io_rst_1_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[1] <= _io_rst_1_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_2_T = eq(UInt<2>("h02"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_2_T_1 = and(_io_rst_2_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[2] <= _io_rst_2_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_3_T = eq(UInt<2>("h03"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_3_T_1 = and(_io_rst_3_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[3] <= _io_rst_3_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_4_T = eq(UInt<3>("h04"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_4_T_1 = and(_io_rst_4_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[4] <= _io_rst_4_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_5_T = eq(UInt<3>("h05"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_5_T_1 = and(_io_rst_5_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[5] <= _io_rst_5_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_6_T = eq(UInt<3>("h06"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_6_T_1 = and(_io_rst_6_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[6] <= _io_rst_6_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_7_T = eq(UInt<3>("h07"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_7_T_1 = and(_io_rst_7_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[7] <= _io_rst_7_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    
  module TransmissionSystem_2 : 
    input clock : Clock
    input reset : Reset
    output io : {data : UInt<11>, flip ready : UInt<1>, valid : UInt<1>, flip n : UInt<5>, flip spikes : UInt<1>[8]}
    
    wire _spikeRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[0] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[1] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[2] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[3] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[4] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[5] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[6] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[7] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    reg spikeRegs : UInt<1>[8], clock with : (reset => (reset, _spikeRegs_WIRE)) @[TransmissionSystem.scala 18:29]
    wire _neuronIdMSB_WIRE : UInt<5>[8] @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[0] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[1] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[2] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[3] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[4] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[5] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[6] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[7] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    reg neuronIdMSB : UInt<5>[8], clock with : (reset => (reset, _neuronIdMSB_WIRE)) @[TransmissionSystem.scala 19:29]
    wire _maskRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[0] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[1] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[2] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[3] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[4] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[5] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[6] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[7] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    reg maskRegs : UInt<1>[8], clock with : (reset => (reset, _maskRegs_WIRE)) @[TransmissionSystem.scala 20:29]
    inst spikeEncoder of PriorityMaskRstEncoder_2 @[TransmissionSystem.scala 22:28]
    spikeEncoder.clock <= clock
    spikeEncoder.reset <= reset
    wire encoderReqs : UInt<1>[8] @[TransmissionSystem.scala 23:26]
    wire rstReadySel : UInt<1>[8] @[TransmissionSystem.scala 24:26]
    wire spikeUpdate : UInt<1>[8] @[TransmissionSystem.scala 25:26]
    io.data <= UInt<1>("h00") @[TransmissionSystem.scala 28:12]
    io.valid <= spikeEncoder.io.valid @[TransmissionSystem.scala 29:12]
    spikeEncoder.io.reqs[0] <= encoderReqs[0] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[1] <= encoderReqs[1] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[2] <= encoderReqs[2] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[3] <= encoderReqs[3] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[4] <= encoderReqs[4] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[5] <= encoderReqs[5] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[6] <= encoderReqs[6] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[7] <= encoderReqs[7] @[TransmissionSystem.scala 30:24]
    node _encoderReqs_0_T = and(maskRegs[0], spikeRegs[0]) @[TransmissionSystem.scala 33:35]
    encoderReqs[0] <= _encoderReqs_0_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_0_T = and(spikeEncoder.io.rst[0], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_0_T_1 = not(_rstReadySel_0_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[0] <= _rstReadySel_0_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_0_T = and(rstReadySel[0], spikeRegs[0]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[0] <= _spikeUpdate_0_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[0] <= spikeEncoder.io.mask[0] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T : @[TransmissionSystem.scala 40:40]
        maskRegs[0] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_1 = not(spikeUpdate[0]) @[TransmissionSystem.scala 44:10]
    when _T_1 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[0] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[0] <= io.spikes[0] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_2 = eq(UInt<1>("h00"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_2 : @[TransmissionSystem.scala 49:41]
      node _io_data_T = cat(UInt<3>("h02"), neuronIdMSB[0]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_1 = cat(_io_data_T, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_1 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_1_T = and(maskRegs[1], spikeRegs[1]) @[TransmissionSystem.scala 33:35]
    encoderReqs[1] <= _encoderReqs_1_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_1_T = and(spikeEncoder.io.rst[1], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_1_T_1 = not(_rstReadySel_1_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[1] <= _rstReadySel_1_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_1_T = and(rstReadySel[1], spikeRegs[1]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[1] <= _spikeUpdate_1_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[1] <= spikeEncoder.io.mask[1] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_3 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_3 : @[TransmissionSystem.scala 40:40]
        maskRegs[1] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_4 = not(spikeUpdate[1]) @[TransmissionSystem.scala 44:10]
    when _T_4 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[1] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[1] <= io.spikes[1] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_5 = eq(UInt<1>("h01"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_5 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_2 = cat(UInt<3>("h02"), neuronIdMSB[1]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_3 = cat(_io_data_T_2, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_3 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_2_T = and(maskRegs[2], spikeRegs[2]) @[TransmissionSystem.scala 33:35]
    encoderReqs[2] <= _encoderReqs_2_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_2_T = and(spikeEncoder.io.rst[2], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_2_T_1 = not(_rstReadySel_2_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[2] <= _rstReadySel_2_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_2_T = and(rstReadySel[2], spikeRegs[2]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[2] <= _spikeUpdate_2_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[2] <= spikeEncoder.io.mask[2] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_6 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_6 : @[TransmissionSystem.scala 40:40]
        maskRegs[2] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_7 = not(spikeUpdate[2]) @[TransmissionSystem.scala 44:10]
    when _T_7 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[2] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[2] <= io.spikes[2] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_8 = eq(UInt<2>("h02"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_8 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_4 = cat(UInt<3>("h02"), neuronIdMSB[2]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_5 = cat(_io_data_T_4, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_5 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_3_T = and(maskRegs[3], spikeRegs[3]) @[TransmissionSystem.scala 33:35]
    encoderReqs[3] <= _encoderReqs_3_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_3_T = and(spikeEncoder.io.rst[3], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_3_T_1 = not(_rstReadySel_3_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[3] <= _rstReadySel_3_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_3_T = and(rstReadySel[3], spikeRegs[3]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[3] <= _spikeUpdate_3_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[3] <= spikeEncoder.io.mask[3] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_9 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_9 : @[TransmissionSystem.scala 40:40]
        maskRegs[3] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_10 = not(spikeUpdate[3]) @[TransmissionSystem.scala 44:10]
    when _T_10 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[3] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[3] <= io.spikes[3] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_11 = eq(UInt<2>("h03"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_11 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_6 = cat(UInt<3>("h02"), neuronIdMSB[3]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_7 = cat(_io_data_T_6, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_7 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_4_T = and(maskRegs[4], spikeRegs[4]) @[TransmissionSystem.scala 33:35]
    encoderReqs[4] <= _encoderReqs_4_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_4_T = and(spikeEncoder.io.rst[4], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_4_T_1 = not(_rstReadySel_4_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[4] <= _rstReadySel_4_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_4_T = and(rstReadySel[4], spikeRegs[4]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[4] <= _spikeUpdate_4_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[4] <= spikeEncoder.io.mask[4] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_12 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_12 : @[TransmissionSystem.scala 40:40]
        maskRegs[4] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_13 = not(spikeUpdate[4]) @[TransmissionSystem.scala 44:10]
    when _T_13 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[4] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[4] <= io.spikes[4] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_14 = eq(UInt<3>("h04"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_14 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_8 = cat(UInt<3>("h02"), neuronIdMSB[4]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_9 = cat(_io_data_T_8, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_9 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_5_T = and(maskRegs[5], spikeRegs[5]) @[TransmissionSystem.scala 33:35]
    encoderReqs[5] <= _encoderReqs_5_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_5_T = and(spikeEncoder.io.rst[5], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_5_T_1 = not(_rstReadySel_5_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[5] <= _rstReadySel_5_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_5_T = and(rstReadySel[5], spikeRegs[5]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[5] <= _spikeUpdate_5_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[5] <= spikeEncoder.io.mask[5] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_15 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_15 : @[TransmissionSystem.scala 40:40]
        maskRegs[5] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_16 = not(spikeUpdate[5]) @[TransmissionSystem.scala 44:10]
    when _T_16 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[5] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[5] <= io.spikes[5] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_17 = eq(UInt<3>("h05"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_17 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_10 = cat(UInt<3>("h02"), neuronIdMSB[5]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_11 = cat(_io_data_T_10, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_11 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_6_T = and(maskRegs[6], spikeRegs[6]) @[TransmissionSystem.scala 33:35]
    encoderReqs[6] <= _encoderReqs_6_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_6_T = and(spikeEncoder.io.rst[6], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_6_T_1 = not(_rstReadySel_6_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[6] <= _rstReadySel_6_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_6_T = and(rstReadySel[6], spikeRegs[6]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[6] <= _spikeUpdate_6_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[6] <= spikeEncoder.io.mask[6] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_18 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_18 : @[TransmissionSystem.scala 40:40]
        maskRegs[6] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_19 = not(spikeUpdate[6]) @[TransmissionSystem.scala 44:10]
    when _T_19 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[6] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[6] <= io.spikes[6] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_20 = eq(UInt<3>("h06"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_20 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_12 = cat(UInt<3>("h02"), neuronIdMSB[6]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_13 = cat(_io_data_T_12, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_13 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_7_T = and(maskRegs[7], spikeRegs[7]) @[TransmissionSystem.scala 33:35]
    encoderReqs[7] <= _encoderReqs_7_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_7_T = and(spikeEncoder.io.rst[7], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_7_T_1 = not(_rstReadySel_7_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[7] <= _rstReadySel_7_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_7_T = and(rstReadySel[7], spikeRegs[7]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[7] <= _spikeUpdate_7_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[7] <= spikeEncoder.io.mask[7] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_21 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_21 : @[TransmissionSystem.scala 40:40]
        maskRegs[7] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_22 = not(spikeUpdate[7]) @[TransmissionSystem.scala 44:10]
    when _T_22 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[7] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[7] <= io.spikes[7] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_23 = eq(UInt<3>("h07"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_23 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_14 = cat(UInt<3>("h02"), neuronIdMSB[7]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_15 = cat(_io_data_T_14, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_15 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    
  module ControlUnit : 
    input clock : Clock
    input reset : Reset
    output io : {done : UInt<1>, flip newTS : UInt<1>, addr : {sel : UInt<2>, pos : UInt<15>}, wr : UInt<1>, ena : UInt<1>, flip spikeIndi : UInt<1>[8], flip refracIndi : UInt<1>[8], cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}[8], evalEnable : UInt<1>, inOut : UInt<1>, flip spikeCnt : UInt<10>, aAddr : UInt<10>, aEna : UInt<1>, flip aData : UInt<10>, n : UInt<5>, spikes : UInt<1>[8]}
    
    reg state : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[ControlUnit.scala 36:22]
    wire _spikePulse_WIRE : UInt<1>[8] @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[0] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[1] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[2] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[3] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[4] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[5] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[6] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[7] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    reg spikePulse : UInt<1>[8], clock with : (reset => (reset, _spikePulse_WIRE)) @[ControlUnit.scala 42:27]
    reg n : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[ControlUnit.scala 45:22]
    io.n <= n @[ControlUnit.scala 46:12]
    reg a : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[ControlUnit.scala 47:22]
    io.aAddr <= a @[ControlUnit.scala 48:12]
    reg spikeCnt : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[ControlUnit.scala 50:25]
    reg inOut : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ControlUnit.scala 52:22]
    io.inOut <= inOut @[ControlUnit.scala 53:12]
    wire _evalUnitActive_WIRE : UInt<1>[8] @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[0] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[1] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[2] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[3] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[4] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[5] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[6] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[7] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    reg evalUnitActive : UInt<1>[8], clock with : (reset => (reset, _evalUnitActive_WIRE)) @[ControlUnit.scala 55:31]
    wire localCntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}[8] @[ControlUnit.scala 56:28]
    reg nrNeuMapped : UInt, clock with : (reset => (reset, UInt<8>("h0c8"))) @[ControlUnit.scala 58:28]
    spikePulse[0] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[0].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[0].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[0].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[0].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[0].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_0_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_0_T_1 = add(_evalUnitActive_0_T, UInt<1>("h00")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_0_T_2 = tail(_evalUnitActive_0_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_0_T_3 = gt(nrNeuMapped, _evalUnitActive_0_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[0] <= _evalUnitActive_0_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[0] : @[ControlUnit.scala 71:29]
      io.cntrSels[0].potSel <= localCntrSels[0].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[0].spikeSel <= localCntrSels[0].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[0].refracSel <= localCntrSels[0].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[0].writeDataSel <= localCntrSels[0].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[0].decaySel <= localCntrSels[0].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[0].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[0].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[0].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[0].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[0].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[0] <= spikePulse[0] @[ControlUnit.scala 86:18]
    spikePulse[1] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[1].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[1].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[1].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[1].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[1].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_1_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_1_T_1 = add(_evalUnitActive_1_T, UInt<1>("h01")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_1_T_2 = tail(_evalUnitActive_1_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_1_T_3 = gt(nrNeuMapped, _evalUnitActive_1_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[1] <= _evalUnitActive_1_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[1] : @[ControlUnit.scala 71:29]
      io.cntrSels[1].potSel <= localCntrSels[1].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[1].spikeSel <= localCntrSels[1].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[1].refracSel <= localCntrSels[1].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[1].writeDataSel <= localCntrSels[1].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[1].decaySel <= localCntrSels[1].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[1].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[1].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[1].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[1].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[1].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[1] <= spikePulse[1] @[ControlUnit.scala 86:18]
    spikePulse[2] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[2].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[2].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[2].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[2].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[2].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_2_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_2_T_1 = add(_evalUnitActive_2_T, UInt<2>("h02")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_2_T_2 = tail(_evalUnitActive_2_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_2_T_3 = gt(nrNeuMapped, _evalUnitActive_2_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[2] <= _evalUnitActive_2_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[2] : @[ControlUnit.scala 71:29]
      io.cntrSels[2].potSel <= localCntrSels[2].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[2].spikeSel <= localCntrSels[2].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[2].refracSel <= localCntrSels[2].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[2].writeDataSel <= localCntrSels[2].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[2].decaySel <= localCntrSels[2].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[2].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[2].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[2].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[2].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[2].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[2] <= spikePulse[2] @[ControlUnit.scala 86:18]
    spikePulse[3] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[3].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[3].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[3].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[3].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[3].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_3_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_3_T_1 = add(_evalUnitActive_3_T, UInt<2>("h03")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_3_T_2 = tail(_evalUnitActive_3_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_3_T_3 = gt(nrNeuMapped, _evalUnitActive_3_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[3] <= _evalUnitActive_3_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[3] : @[ControlUnit.scala 71:29]
      io.cntrSels[3].potSel <= localCntrSels[3].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[3].spikeSel <= localCntrSels[3].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[3].refracSel <= localCntrSels[3].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[3].writeDataSel <= localCntrSels[3].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[3].decaySel <= localCntrSels[3].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[3].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[3].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[3].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[3].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[3].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[3] <= spikePulse[3] @[ControlUnit.scala 86:18]
    spikePulse[4] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[4].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[4].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[4].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[4].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[4].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_4_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_4_T_1 = add(_evalUnitActive_4_T, UInt<3>("h04")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_4_T_2 = tail(_evalUnitActive_4_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_4_T_3 = gt(nrNeuMapped, _evalUnitActive_4_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[4] <= _evalUnitActive_4_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[4] : @[ControlUnit.scala 71:29]
      io.cntrSels[4].potSel <= localCntrSels[4].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[4].spikeSel <= localCntrSels[4].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[4].refracSel <= localCntrSels[4].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[4].writeDataSel <= localCntrSels[4].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[4].decaySel <= localCntrSels[4].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[4].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[4].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[4].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[4].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[4].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[4] <= spikePulse[4] @[ControlUnit.scala 86:18]
    spikePulse[5] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[5].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[5].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[5].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[5].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[5].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_5_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_5_T_1 = add(_evalUnitActive_5_T, UInt<3>("h05")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_5_T_2 = tail(_evalUnitActive_5_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_5_T_3 = gt(nrNeuMapped, _evalUnitActive_5_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[5] <= _evalUnitActive_5_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[5] : @[ControlUnit.scala 71:29]
      io.cntrSels[5].potSel <= localCntrSels[5].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[5].spikeSel <= localCntrSels[5].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[5].refracSel <= localCntrSels[5].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[5].writeDataSel <= localCntrSels[5].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[5].decaySel <= localCntrSels[5].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[5].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[5].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[5].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[5].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[5].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[5] <= spikePulse[5] @[ControlUnit.scala 86:18]
    spikePulse[6] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[6].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[6].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[6].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[6].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[6].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_6_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_6_T_1 = add(_evalUnitActive_6_T, UInt<3>("h06")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_6_T_2 = tail(_evalUnitActive_6_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_6_T_3 = gt(nrNeuMapped, _evalUnitActive_6_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[6] <= _evalUnitActive_6_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[6] : @[ControlUnit.scala 71:29]
      io.cntrSels[6].potSel <= localCntrSels[6].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[6].spikeSel <= localCntrSels[6].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[6].refracSel <= localCntrSels[6].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[6].writeDataSel <= localCntrSels[6].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[6].decaySel <= localCntrSels[6].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[6].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[6].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[6].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[6].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[6].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[6] <= spikePulse[6] @[ControlUnit.scala 86:18]
    spikePulse[7] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[7].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[7].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[7].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[7].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[7].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_7_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_7_T_1 = add(_evalUnitActive_7_T, UInt<3>("h07")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_7_T_2 = tail(_evalUnitActive_7_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_7_T_3 = gt(nrNeuMapped, _evalUnitActive_7_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[7] <= _evalUnitActive_7_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[7] : @[ControlUnit.scala 71:29]
      io.cntrSels[7].potSel <= localCntrSels[7].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[7].spikeSel <= localCntrSels[7].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[7].refracSel <= localCntrSels[7].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[7].writeDataSel <= localCntrSels[7].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[7].decaySel <= localCntrSels[7].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[7].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[7].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[7].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[7].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[7].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[7] <= spikePulse[7] @[ControlUnit.scala 86:18]
    io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 89:15]
    io.addr.pos <= UInt<1>("h00") @[ControlUnit.scala 90:15]
    io.ena <= UInt<1>("h00") @[ControlUnit.scala 91:10]
    io.wr <= UInt<1>("h00") @[ControlUnit.scala 92:10]
    io.evalEnable <= UInt<1>("h01") @[ControlUnit.scala 94:17]
    io.aEna <= UInt<1>("h00") @[ControlUnit.scala 96:11]
    io.done <= UInt<1>("h00") @[ControlUnit.scala 99:11]
    node _T = eq(UInt<4>("h00"), state) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      io.done <= UInt<1>("h01") @[ControlUnit.scala 103:15]
      n <= UInt<1>("h00") @[ControlUnit.scala 104:9]
      a <= UInt<1>("h00") @[ControlUnit.scala 105:9]
      io.evalEnable <= UInt<1>("h00") @[ControlUnit.scala 106:21]
      when io.newTS : @[ControlUnit.scala 107:22]
        io.done <= UInt<1>("h00") @[ControlUnit.scala 108:18]
        spikeCnt <= io.spikeCnt @[ControlUnit.scala 109:18]
        node _inOut_T = not(inOut) @[ControlUnit.scala 110:21]
        inOut <= _inOut_T @[ControlUnit.scala 110:18]
        state <= UInt<4>("h01") @[ControlUnit.scala 111:18]
        skip @[ControlUnit.scala 107:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<4>("h01"), state) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        io.ena <= UInt<1>("h01") @[ControlUnit.scala 117:19]
        io.wr <= UInt<1>("h00") @[ControlUnit.scala 118:19]
        io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 119:19]
        io.addr.pos <= n @[ControlUnit.scala 120:19]
        localCntrSels[0].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[1].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[2].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[3].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[4].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[5].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[6].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[7].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        state <= UInt<4>("h02") @[ControlUnit.scala 125:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_2 = eq(UInt<4>("h02"), state) @[Conditional.scala 37:30]
        when _T_2 : @[Conditional.scala 39:67]
          io.ena <= UInt<1>("h01") @[ControlUnit.scala 130:19]
          io.wr <= UInt<1>("h00") @[ControlUnit.scala 131:19]
          io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 132:19]
          node _io_addr_pos_T = add(n, UInt<6>("h020")) @[ControlUnit.scala 133:24]
          node _io_addr_pos_T_1 = tail(_io_addr_pos_T, 1) @[ControlUnit.scala 133:24]
          io.addr.pos <= _io_addr_pos_T_1 @[ControlUnit.scala 133:19]
          localCntrSels[0].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[1].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[2].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[3].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[4].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[5].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[6].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[7].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          state <= UInt<4>("h03") @[ControlUnit.scala 138:13]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<4>("h03"), state) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            io.ena <= UInt<1>("h01") @[ControlUnit.scala 143:19]
            io.wr <= UInt<1>("h00") @[ControlUnit.scala 144:19]
            io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 145:19]
            io.addr.pos <= UInt<2>("h02") @[ControlUnit.scala 146:19]
            node _a_T = add(a, UInt<1>("h01")) @[ControlUnit.scala 148:14]
            node _a_T_1 = tail(_a_T, 1) @[ControlUnit.scala 148:14]
            a <= _a_T_1 @[ControlUnit.scala 148:9]
            io.aEna <= UInt<1>("h01") @[ControlUnit.scala 149:15]
            localCntrSels[0].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[1].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[2].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[3].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[4].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[5].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[6].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[7].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            node _T_4 = eq(spikeCnt, UInt<1>("h00")) @[ControlUnit.scala 154:21]
            when _T_4 : @[ControlUnit.scala 154:30]
              state <= UInt<4>("h06") @[ControlUnit.scala 155:15]
              skip @[ControlUnit.scala 154:30]
            else : @[ControlUnit.scala 156:19]
              state <= UInt<4>("h04") @[ControlUnit.scala 157:15]
              skip @[ControlUnit.scala 156:19]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_5 = eq(UInt<4>("h04"), state) @[Conditional.scala 37:30]
            when _T_5 : @[Conditional.scala 39:67]
              io.ena <= UInt<1>("h01") @[ControlUnit.scala 163:19]
              io.wr <= UInt<1>("h00") @[ControlUnit.scala 164:19]
              io.addr.sel <= UInt<2>("h03") @[ControlUnit.scala 165:19]
              node _io_addr_pos_T_2 = mul(n, UInt<10>("h0300")) @[ControlUnit.scala 167:27]
              node _io_addr_pos_T_3 = add(_io_addr_pos_T_2, io.aData) @[ControlUnit.scala 167:40]
              node _io_addr_pos_T_4 = tail(_io_addr_pos_T_3, 1) @[ControlUnit.scala 167:40]
              io.addr.pos <= _io_addr_pos_T_4 @[ControlUnit.scala 167:21]
              io.aEna <= UInt<1>("h01") @[ControlUnit.scala 172:15]
              node _a_T_2 = add(a, UInt<1>("h01")) @[ControlUnit.scala 173:14]
              node _a_T_3 = tail(_a_T_2, 1) @[ControlUnit.scala 173:14]
              a <= _a_T_3 @[ControlUnit.scala 173:9]
              when io.refracIndi[0] : @[ControlUnit.scala 176:32]
                localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[0].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[1] : @[ControlUnit.scala 176:32]
                localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[1].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[2] : @[ControlUnit.scala 176:32]
                localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[2].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[3] : @[ControlUnit.scala 176:32]
                localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[3].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[4] : @[ControlUnit.scala 176:32]
                localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[4].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[5] : @[ControlUnit.scala 176:32]
                localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[5].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[6] : @[ControlUnit.scala 176:32]
                localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[6].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[7] : @[ControlUnit.scala 176:32]
                localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[7].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              node _T_6 = eq(spikeCnt, a) @[ControlUnit.scala 182:21]
              when _T_6 : @[ControlUnit.scala 182:28]
                state <= UInt<4>("h06") @[ControlUnit.scala 183:15]
                skip @[ControlUnit.scala 182:28]
              else : @[ControlUnit.scala 184:19]
                state <= UInt<4>("h05") @[ControlUnit.scala 185:15]
                skip @[ControlUnit.scala 184:19]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_7 = eq(UInt<4>("h05"), state) @[Conditional.scala 37:30]
              when _T_7 : @[Conditional.scala 39:67]
                io.ena <= UInt<1>("h01") @[ControlUnit.scala 191:19]
                io.wr <= UInt<1>("h00") @[ControlUnit.scala 192:19]
                io.addr.sel <= UInt<2>("h03") @[ControlUnit.scala 193:19]
                node _io_addr_pos_T_5 = mul(n, UInt<10>("h0300")) @[ControlUnit.scala 195:27]
                node _io_addr_pos_T_6 = add(_io_addr_pos_T_5, io.aData) @[ControlUnit.scala 195:40]
                node _io_addr_pos_T_7 = tail(_io_addr_pos_T_6, 1) @[ControlUnit.scala 195:40]
                io.addr.pos <= _io_addr_pos_T_7 @[ControlUnit.scala 195:21]
                node _a_T_4 = add(a, UInt<1>("h01")) @[ControlUnit.scala 200:14]
                node _a_T_5 = tail(_a_T_4, 1) @[ControlUnit.scala 200:14]
                a <= _a_T_5 @[ControlUnit.scala 200:9]
                io.aEna <= UInt<1>("h01") @[ControlUnit.scala 201:15]
                when io.refracIndi[0] : @[ControlUnit.scala 204:32]
                  localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[1] : @[ControlUnit.scala 204:32]
                  localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[2] : @[ControlUnit.scala 204:32]
                  localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[3] : @[ControlUnit.scala 204:32]
                  localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[4] : @[ControlUnit.scala 204:32]
                  localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[5] : @[ControlUnit.scala 204:32]
                  localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[6] : @[ControlUnit.scala 204:32]
                  localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[7] : @[ControlUnit.scala 204:32]
                  localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                node _T_8 = sub(a, UInt<1>("h01")) @[ControlUnit.scala 209:27]
                node _T_9 = tail(_T_8, 1) @[ControlUnit.scala 209:27]
                node _T_10 = eq(spikeCnt, _T_9) @[ControlUnit.scala 209:21]
                when _T_10 : @[ControlUnit.scala 209:34]
                  state <= UInt<4>("h06") @[ControlUnit.scala 210:15]
                  skip @[ControlUnit.scala 209:34]
                else : @[ControlUnit.scala 211:19]
                  state <= UInt<4>("h05") @[ControlUnit.scala 212:15]
                  skip @[ControlUnit.scala 211:19]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_11 = eq(UInt<4>("h06"), state) @[Conditional.scala 37:30]
                when _T_11 : @[Conditional.scala 39:67]
                  io.ena <= UInt<1>("h01") @[ControlUnit.scala 218:19]
                  io.wr <= UInt<1>("h00") @[ControlUnit.scala 219:19]
                  io.addr.sel <= UInt<2>("h02") @[ControlUnit.scala 220:19]
                  io.addr.pos <= n @[ControlUnit.scala 221:19]
                  node _T_12 = eq(spikeCnt, UInt<1>("h00")) @[ControlUnit.scala 223:21]
                  when _T_12 : @[ControlUnit.scala 223:30]
                    when io.refracIndi[0] : @[ControlUnit.scala 225:34]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[0].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[1] : @[ControlUnit.scala 225:34]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[1].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[2] : @[ControlUnit.scala 225:34]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[2].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[3] : @[ControlUnit.scala 225:34]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[3].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[4] : @[ControlUnit.scala 225:34]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[4].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[5] : @[ControlUnit.scala 225:34]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[5].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[6] : @[ControlUnit.scala 225:34]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[6].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[7] : @[ControlUnit.scala 225:34]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[7].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    skip @[ControlUnit.scala 223:30]
                  else : @[ControlUnit.scala 230:19]
                    when io.refracIndi[0] : @[ControlUnit.scala 232:34]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[1] : @[ControlUnit.scala 232:34]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[2] : @[ControlUnit.scala 232:34]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[3] : @[ControlUnit.scala 232:34]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[4] : @[ControlUnit.scala 232:34]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[5] : @[ControlUnit.scala 232:34]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[6] : @[ControlUnit.scala 232:34]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[7] : @[ControlUnit.scala 232:34]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    skip @[ControlUnit.scala 230:19]
                  state <= UInt<4>("h07") @[ControlUnit.scala 238:13]
                  skip @[Conditional.scala 39:67]
                else : @[Conditional.scala 39:67]
                  node _T_13 = eq(UInt<4>("h07"), state) @[Conditional.scala 37:30]
                  when _T_13 : @[Conditional.scala 39:67]
                    io.ena <= UInt<1>("h01") @[ControlUnit.scala 243:20]
                    io.wr <= UInt<1>("h00") @[ControlUnit.scala 244:20]
                    io.addr.sel <= UInt<2>("h02") @[ControlUnit.scala 245:20]
                    node _io_addr_pos_T_8 = add(n, UInt<6>("h020")) @[ControlUnit.scala 246:25]
                    node _io_addr_pos_T_9 = tail(_io_addr_pos_T_8, 1) @[ControlUnit.scala 246:25]
                    io.addr.pos <= _io_addr_pos_T_9 @[ControlUnit.scala 246:20]
                    when io.refracIndi[0] : @[ControlUnit.scala 249:32]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[1] : @[ControlUnit.scala 249:32]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[2] : @[ControlUnit.scala 249:32]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[3] : @[ControlUnit.scala 249:32]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[4] : @[ControlUnit.scala 249:32]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[5] : @[ControlUnit.scala 249:32]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[6] : @[ControlUnit.scala 249:32]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[7] : @[ControlUnit.scala 249:32]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    state <= UInt<4>("h08") @[ControlUnit.scala 254:13]
                    skip @[Conditional.scala 39:67]
                  else : @[Conditional.scala 39:67]
                    node _T_14 = eq(UInt<4>("h08"), state) @[Conditional.scala 37:30]
                    when _T_14 : @[Conditional.scala 39:67]
                      io.ena <= UInt<1>("h01") @[ControlUnit.scala 259:19]
                      io.wr <= UInt<1>("h00") @[ControlUnit.scala 260:19]
                      io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 261:19]
                      io.addr.pos <= UInt<2>("h01") @[ControlUnit.scala 262:19]
                      localCntrSels[0].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[1].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[2].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[3].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[4].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[5].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[6].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[7].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      state <= UInt<4>("h09") @[ControlUnit.scala 267:13]
                      skip @[Conditional.scala 39:67]
                    else : @[Conditional.scala 39:67]
                      node _T_15 = eq(UInt<4>("h09"), state) @[Conditional.scala 37:30]
                      when _T_15 : @[Conditional.scala 39:67]
                        io.ena <= UInt<1>("h01") @[ControlUnit.scala 272:19]
                        io.wr <= UInt<1>("h01") @[ControlUnit.scala 273:19]
                        io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 274:19]
                        io.addr.pos <= n @[ControlUnit.scala 275:19]
                        localCntrSels[0].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[0] <= io.spikeIndi[0] @[ControlUnit.scala 279:23]
                        localCntrSels[1].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[1] <= io.spikeIndi[1] @[ControlUnit.scala 279:23]
                        localCntrSels[2].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[2] <= io.spikeIndi[2] @[ControlUnit.scala 279:23]
                        localCntrSels[3].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[3] <= io.spikeIndi[3] @[ControlUnit.scala 279:23]
                        localCntrSels[4].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[4] <= io.spikeIndi[4] @[ControlUnit.scala 279:23]
                        localCntrSels[5].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[5] <= io.spikeIndi[5] @[ControlUnit.scala 279:23]
                        localCntrSels[6].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[6] <= io.spikeIndi[6] @[ControlUnit.scala 279:23]
                        localCntrSels[7].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[7] <= io.spikeIndi[7] @[ControlUnit.scala 279:23]
                        state <= UInt<4>("h0a") @[ControlUnit.scala 282:13]
                        skip @[Conditional.scala 39:67]
                      else : @[Conditional.scala 39:67]
                        node _T_16 = eq(UInt<4>("h0a"), state) @[Conditional.scala 37:30]
                        when _T_16 : @[Conditional.scala 39:67]
                          io.ena <= UInt<1>("h01") @[ControlUnit.scala 287:20]
                          io.wr <= UInt<1>("h00") @[ControlUnit.scala 288:20]
                          io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 289:19]
                          io.addr.pos <= UInt<2>("h00") @[ControlUnit.scala 290:19]
                          state <= UInt<4>("h0b") @[ControlUnit.scala 292:17]
                          skip @[Conditional.scala 39:67]
                        else : @[Conditional.scala 39:67]
                          node _T_17 = eq(UInt<4>("h0b"), state) @[Conditional.scala 37:30]
                          when _T_17 : @[Conditional.scala 39:67]
                            io.ena <= UInt<1>("h01") @[ControlUnit.scala 297:19]
                            io.wr <= UInt<1>("h01") @[ControlUnit.scala 298:19]
                            io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 299:19]
                            node _io_addr_pos_T_10 = add(n, UInt<6>("h020")) @[ControlUnit.scala 300:24]
                            node _io_addr_pos_T_11 = tail(_io_addr_pos_T_10, 1) @[ControlUnit.scala 300:24]
                            io.addr.pos <= _io_addr_pos_T_11 @[ControlUnit.scala 300:19]
                            localCntrSels[0].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[1].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[2].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[3].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[4].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[5].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[6].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[7].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            a <= UInt<1>("h00") @[ControlUnit.scala 305:9]
                            node _nNext_T = add(n, UInt<1>("h01")) @[ControlUnit.scala 306:21]
                            node nNext = tail(_nNext_T, 1) @[ControlUnit.scala 306:21]
                            n <= nNext @[ControlUnit.scala 307:9]
                            node _T_18 = shl(nNext, 3) @[ControlUnit.scala 308:19]
                            node _T_19 = geq(_T_18, nrNeuMapped) @[ControlUnit.scala 308:41]
                            when _T_19 : @[ControlUnit.scala 308:58]
                              state <= UInt<4>("h00") @[ControlUnit.scala 309:15]
                              skip @[ControlUnit.scala 308:58]
                            else : @[ControlUnit.scala 310:19]
                              state <= UInt<4>("h01") @[ControlUnit.scala 311:15]
                              skip @[ControlUnit.scala 310:19]
                            skip @[Conditional.scala 39:67]
    
  module NeuronEvaluator : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module EvaluationMemory : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<1>("h00")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<1>("h01")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<2>("h02")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<2>("h03")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<3>("h04")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<3>("h05")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<3>("h06")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h02"), UInt<3>("h07")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module Neurons : 
    input clock : Clock
    input reset : Reset
    output io : {done : UInt<1>, flip newTS : UInt<1>, inOut : UInt<1>, flip spikeCnt : UInt<10>, aAddr : UInt<10>, aEna : UInt<1>, flip aData : UInt<10>, n : UInt<5>, spikes : UInt<1>[8]}
    
    inst controlUnit of ControlUnit @[Neurons.scala 22:27]
    controlUnit.clock <= clock
    controlUnit.reset <= reset
    inst evalUnits_0 of NeuronEvaluator @[Neurons.scala 23:56]
    evalUnits_0.clock <= clock
    evalUnits_0.reset <= reset
    inst evalUnits_1 of NeuronEvaluator_1 @[Neurons.scala 23:56]
    evalUnits_1.clock <= clock
    evalUnits_1.reset <= reset
    inst evalUnits_2 of NeuronEvaluator_2 @[Neurons.scala 23:56]
    evalUnits_2.clock <= clock
    evalUnits_2.reset <= reset
    inst evalUnits_3 of NeuronEvaluator_3 @[Neurons.scala 23:56]
    evalUnits_3.clock <= clock
    evalUnits_3.reset <= reset
    inst evalUnits_4 of NeuronEvaluator_4 @[Neurons.scala 23:56]
    evalUnits_4.clock <= clock
    evalUnits_4.reset <= reset
    inst evalUnits_5 of NeuronEvaluator_5 @[Neurons.scala 23:56]
    evalUnits_5.clock <= clock
    evalUnits_5.reset <= reset
    inst evalUnits_6 of NeuronEvaluator_6 @[Neurons.scala 23:56]
    evalUnits_6.clock <= clock
    evalUnits_6.reset <= reset
    inst evalUnits_7 of NeuronEvaluator_7 @[Neurons.scala 23:56]
    evalUnits_7.clock <= clock
    evalUnits_7.reset <= reset
    inst evalMems_0 of EvaluationMemory @[Neurons.scala 24:56]
    evalMems_0.clock <= clock
    evalMems_0.reset <= reset
    inst evalMems_1 of EvaluationMemory_1 @[Neurons.scala 24:56]
    evalMems_1.clock <= clock
    evalMems_1.reset <= reset
    inst evalMems_2 of EvaluationMemory_2 @[Neurons.scala 24:56]
    evalMems_2.clock <= clock
    evalMems_2.reset <= reset
    inst evalMems_3 of EvaluationMemory_3 @[Neurons.scala 24:56]
    evalMems_3.clock <= clock
    evalMems_3.reset <= reset
    inst evalMems_4 of EvaluationMemory_4 @[Neurons.scala 24:56]
    evalMems_4.clock <= clock
    evalMems_4.reset <= reset
    inst evalMems_5 of EvaluationMemory_5 @[Neurons.scala 24:56]
    evalMems_5.clock <= clock
    evalMems_5.reset <= reset
    inst evalMems_6 of EvaluationMemory_6 @[Neurons.scala 24:56]
    evalMems_6.clock <= clock
    evalMems_6.reset <= reset
    inst evalMems_7 of EvaluationMemory_7 @[Neurons.scala 24:56]
    evalMems_7.clock <= clock
    evalMems_7.reset <= reset
    io.inOut <= controlUnit.io.inOut @[Neurons.scala 26:27]
    controlUnit.io.spikeCnt <= io.spikeCnt @[Neurons.scala 27:27]
    io.aAddr <= controlUnit.io.aAddr @[Neurons.scala 28:27]
    io.aEna <= controlUnit.io.aEna @[Neurons.scala 29:27]
    controlUnit.io.aData <= io.aData @[Neurons.scala 30:27]
    io.n <= controlUnit.io.n @[Neurons.scala 31:27]
    io.done <= controlUnit.io.done @[Neurons.scala 33:11]
    controlUnit.io.newTS <= io.newTS @[Neurons.scala 34:24]
    io.spikes[0] <= controlUnit.io.spikes[0] @[Neurons.scala 37:18]
    evalUnits_0.io.dataIn <= evalMems_0.io.readData @[Neurons.scala 39:43]
    evalMems_0.io.writeData <= evalUnits_0.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[0] <= evalUnits_0.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[0] <= evalUnits_0.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_0.io.cntrSels.potSel <= controlUnit.io.cntrSels[0].potSel @[Neurons.scala 43:43]
    evalUnits_0.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[0].spikeSel @[Neurons.scala 44:43]
    evalUnits_0.io.cntrSels.refracSel <= controlUnit.io.cntrSels[0].refracSel @[Neurons.scala 45:43]
    evalUnits_0.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[0].writeDataSel @[Neurons.scala 46:43]
    evalUnits_0.io.cntrSels.decaySel <= controlUnit.io.cntrSels[0].decaySel @[Neurons.scala 47:43]
    evalUnits_0.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_0.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_0.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_0.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_0.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[1] <= controlUnit.io.spikes[1] @[Neurons.scala 37:18]
    evalUnits_1.io.dataIn <= evalMems_1.io.readData @[Neurons.scala 39:43]
    evalMems_1.io.writeData <= evalUnits_1.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[1] <= evalUnits_1.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[1] <= evalUnits_1.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_1.io.cntrSels.potSel <= controlUnit.io.cntrSels[1].potSel @[Neurons.scala 43:43]
    evalUnits_1.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[1].spikeSel @[Neurons.scala 44:43]
    evalUnits_1.io.cntrSels.refracSel <= controlUnit.io.cntrSels[1].refracSel @[Neurons.scala 45:43]
    evalUnits_1.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[1].writeDataSel @[Neurons.scala 46:43]
    evalUnits_1.io.cntrSels.decaySel <= controlUnit.io.cntrSels[1].decaySel @[Neurons.scala 47:43]
    evalUnits_1.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_1.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_1.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_1.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_1.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[2] <= controlUnit.io.spikes[2] @[Neurons.scala 37:18]
    evalUnits_2.io.dataIn <= evalMems_2.io.readData @[Neurons.scala 39:43]
    evalMems_2.io.writeData <= evalUnits_2.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[2] <= evalUnits_2.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[2] <= evalUnits_2.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_2.io.cntrSels.potSel <= controlUnit.io.cntrSels[2].potSel @[Neurons.scala 43:43]
    evalUnits_2.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[2].spikeSel @[Neurons.scala 44:43]
    evalUnits_2.io.cntrSels.refracSel <= controlUnit.io.cntrSels[2].refracSel @[Neurons.scala 45:43]
    evalUnits_2.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[2].writeDataSel @[Neurons.scala 46:43]
    evalUnits_2.io.cntrSels.decaySel <= controlUnit.io.cntrSels[2].decaySel @[Neurons.scala 47:43]
    evalUnits_2.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_2.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_2.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_2.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_2.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[3] <= controlUnit.io.spikes[3] @[Neurons.scala 37:18]
    evalUnits_3.io.dataIn <= evalMems_3.io.readData @[Neurons.scala 39:43]
    evalMems_3.io.writeData <= evalUnits_3.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[3] <= evalUnits_3.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[3] <= evalUnits_3.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_3.io.cntrSels.potSel <= controlUnit.io.cntrSels[3].potSel @[Neurons.scala 43:43]
    evalUnits_3.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[3].spikeSel @[Neurons.scala 44:43]
    evalUnits_3.io.cntrSels.refracSel <= controlUnit.io.cntrSels[3].refracSel @[Neurons.scala 45:43]
    evalUnits_3.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[3].writeDataSel @[Neurons.scala 46:43]
    evalUnits_3.io.cntrSels.decaySel <= controlUnit.io.cntrSels[3].decaySel @[Neurons.scala 47:43]
    evalUnits_3.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_3.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_3.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_3.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_3.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[4] <= controlUnit.io.spikes[4] @[Neurons.scala 37:18]
    evalUnits_4.io.dataIn <= evalMems_4.io.readData @[Neurons.scala 39:43]
    evalMems_4.io.writeData <= evalUnits_4.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[4] <= evalUnits_4.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[4] <= evalUnits_4.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_4.io.cntrSels.potSel <= controlUnit.io.cntrSels[4].potSel @[Neurons.scala 43:43]
    evalUnits_4.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[4].spikeSel @[Neurons.scala 44:43]
    evalUnits_4.io.cntrSels.refracSel <= controlUnit.io.cntrSels[4].refracSel @[Neurons.scala 45:43]
    evalUnits_4.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[4].writeDataSel @[Neurons.scala 46:43]
    evalUnits_4.io.cntrSels.decaySel <= controlUnit.io.cntrSels[4].decaySel @[Neurons.scala 47:43]
    evalUnits_4.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_4.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_4.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_4.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_4.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[5] <= controlUnit.io.spikes[5] @[Neurons.scala 37:18]
    evalUnits_5.io.dataIn <= evalMems_5.io.readData @[Neurons.scala 39:43]
    evalMems_5.io.writeData <= evalUnits_5.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[5] <= evalUnits_5.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[5] <= evalUnits_5.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_5.io.cntrSels.potSel <= controlUnit.io.cntrSels[5].potSel @[Neurons.scala 43:43]
    evalUnits_5.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[5].spikeSel @[Neurons.scala 44:43]
    evalUnits_5.io.cntrSels.refracSel <= controlUnit.io.cntrSels[5].refracSel @[Neurons.scala 45:43]
    evalUnits_5.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[5].writeDataSel @[Neurons.scala 46:43]
    evalUnits_5.io.cntrSels.decaySel <= controlUnit.io.cntrSels[5].decaySel @[Neurons.scala 47:43]
    evalUnits_5.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_5.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_5.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_5.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_5.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[6] <= controlUnit.io.spikes[6] @[Neurons.scala 37:18]
    evalUnits_6.io.dataIn <= evalMems_6.io.readData @[Neurons.scala 39:43]
    evalMems_6.io.writeData <= evalUnits_6.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[6] <= evalUnits_6.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[6] <= evalUnits_6.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_6.io.cntrSels.potSel <= controlUnit.io.cntrSels[6].potSel @[Neurons.scala 43:43]
    evalUnits_6.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[6].spikeSel @[Neurons.scala 44:43]
    evalUnits_6.io.cntrSels.refracSel <= controlUnit.io.cntrSels[6].refracSel @[Neurons.scala 45:43]
    evalUnits_6.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[6].writeDataSel @[Neurons.scala 46:43]
    evalUnits_6.io.cntrSels.decaySel <= controlUnit.io.cntrSels[6].decaySel @[Neurons.scala 47:43]
    evalUnits_6.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_6.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_6.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_6.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_6.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[7] <= controlUnit.io.spikes[7] @[Neurons.scala 37:18]
    evalUnits_7.io.dataIn <= evalMems_7.io.readData @[Neurons.scala 39:43]
    evalMems_7.io.writeData <= evalUnits_7.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[7] <= evalUnits_7.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[7] <= evalUnits_7.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_7.io.cntrSels.potSel <= controlUnit.io.cntrSels[7].potSel @[Neurons.scala 43:43]
    evalUnits_7.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[7].spikeSel @[Neurons.scala 44:43]
    evalUnits_7.io.cntrSels.refracSel <= controlUnit.io.cntrSels[7].refracSel @[Neurons.scala 45:43]
    evalUnits_7.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[7].writeDataSel @[Neurons.scala 46:43]
    evalUnits_7.io.cntrSels.decaySel <= controlUnit.io.cntrSels[7].decaySel @[Neurons.scala 47:43]
    evalUnits_7.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_7.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_7.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_7.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_7.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    
  module NeuronCore : 
    input clock : Clock
    input reset : Reset
    output io : {pmClkEn : UInt<1>, flip newTS : UInt<1>, flip grant : UInt<1>, req : UInt<1>, tx : UInt<11>, flip rx : UInt<11>}
    
    inst interface of BusInterface_2 @[NeuronCore.scala 19:26]
    interface.clock <= clock
    interface.reset <= reset
    inst axonSystem of AxonSystem @[NeuronCore.scala 20:26]
    axonSystem.clock <= clock
    axonSystem.reset <= reset
    inst spikeTrans of TransmissionSystem_2 @[NeuronCore.scala 21:26]
    spikeTrans.clock <= clock
    spikeTrans.reset <= reset
    inst neurons of Neurons @[NeuronCore.scala 22:26]
    neurons.clock <= clock
    neurons.reset <= reset
    interface.io.grant <= io.grant @[NeuronCore.scala 24:27]
    io.req <= interface.io.reqOut @[NeuronCore.scala 25:27]
    io.tx <= interface.io.tx @[NeuronCore.scala 26:27]
    interface.io.rx <= io.rx @[NeuronCore.scala 27:27]
    axonSystem.io.axonIn <= interface.io.axonID @[NeuronCore.scala 28:27]
    axonSystem.io.axonValid <= interface.io.valid @[NeuronCore.scala 29:27]
    interface.io.spikeID <= spikeTrans.io.data @[NeuronCore.scala 30:27]
    spikeTrans.io.ready <= interface.io.ready @[NeuronCore.scala 31:27]
    interface.io.reqIn <= spikeTrans.io.valid @[NeuronCore.scala 32:27]
    axonSystem.io.inOut <= neurons.io.inOut @[NeuronCore.scala 34:27]
    neurons.io.spikeCnt <= axonSystem.io.spikeCnt @[NeuronCore.scala 35:27]
    axonSystem.io.rAddr <= neurons.io.aAddr @[NeuronCore.scala 36:27]
    axonSystem.io.rEna <= neurons.io.aEna @[NeuronCore.scala 37:27]
    neurons.io.aData <= axonSystem.io.rData @[NeuronCore.scala 38:27]
    spikeTrans.io.n <= neurons.io.n @[NeuronCore.scala 40:27]
    spikeTrans.io.spikes[0] <= neurons.io.spikes[0] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[1] <= neurons.io.spikes[1] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[2] <= neurons.io.spikes[2] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[3] <= neurons.io.spikes[3] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[4] <= neurons.io.spikes[4] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[5] <= neurons.io.spikes[5] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[6] <= neurons.io.spikes[6] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[7] <= neurons.io.spikes[7] @[NeuronCore.scala 41:27]
    node _io_pmClkEn_T = eq(neurons.io.done, UInt<1>("h00")) @[NeuronCore.scala 43:17]
    node _io_pmClkEn_T_1 = or(_io_pmClkEn_T, interface.io.reqOut) @[NeuronCore.scala 43:34]
    io.pmClkEn <= _io_pmClkEn_T_1 @[NeuronCore.scala 43:14]
    neurons.io.newTS <= io.newTS @[NeuronCore.scala 44:20]
    
  module BusInterface_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip grant : UInt<1>, reqOut : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, axonID : UInt<10>, valid : UInt<1>, flip spikeID : UInt<11>, ready : UInt<1>, flip reqIn : UInt<1>}
    
    wire filterROM : UInt<3>[5] @[BusInterface.scala 28:27]
    filterROM[0] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[1] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[2] <= UInt<3>("h04") @[BusInterface.scala 28:27]
    filterROM[3] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[4] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    node _io_tx_T = mux(io.grant, io.spikeID, UInt<1>("h00")) @[BusInterface.scala 31:15]
    io.tx <= _io_tx_T @[BusInterface.scala 31:9]
    node _io_reqOut_T = not(io.grant) @[BusInterface.scala 32:28]
    node _io_reqOut_T_1 = and(io.reqIn, _io_reqOut_T) @[BusInterface.scala 32:25]
    io.reqOut <= _io_reqOut_T_1 @[BusInterface.scala 32:13]
    io.ready <= io.grant @[BusInterface.scala 33:13]
    reg axonIDLSBReg : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[BusInterface.scala 36:29]
    node _axonIDLSBReg_T = bits(io.rx, 7, 0) @[BusInterface.scala 37:24]
    axonIDLSBReg <= _axonIDLSBReg_T @[BusInterface.scala 37:16]
    reg synROMReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[BusInterface.scala 39:27]
    node _synROMReg_T = orr(io.rx) @[BusInterface.scala 40:26]
    node _synROMReg_T_1 = bits(io.rx, 10, 8) @[BusInterface.scala 40:46]
    node _synROMReg_T_2 = mux(_synROMReg_T, filterROM[_synROMReg_T_1], UInt<1>("h00")) @[BusInterface.scala 40:19]
    synROMReg <= _synROMReg_T_2 @[BusInterface.scala 40:13]
    node _io_valid_T = bits(synROMReg, 2, 2) @[BusInterface.scala 42:25]
    io.valid <= _io_valid_T @[BusInterface.scala 42:13]
    node _io_axonID_T = bits(synROMReg, 1, 0) @[BusInterface.scala 43:25]
    node _io_axonID_T_1 = cat(_io_axonID_T, axonIDLSBReg) @[BusInterface.scala 43:47]
    io.axonID <= _io_axonID_T_1 @[BusInterface.scala 43:13]
    
  module AxonSystem_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip axonIn : UInt<10>, flip axonValid : UInt<1>, flip inOut : UInt<1>, spikeCnt : UInt<10>, flip rAddr : UInt<10>, flip rEna : UInt<1>, rData : UInt<10>}
    
    reg inOutReg : UInt<1>, clock @[AxonSystem.scala 21:25]
    inOutReg <= io.inOut @[AxonSystem.scala 21:25]
    reg spikeCntReg : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[AxonSystem.scala 22:28]
    node _T = neq(inOutReg, io.inOut) @[AxonSystem.scala 23:17]
    when _T : @[AxonSystem.scala 23:31]
      spikeCntReg <= UInt<1>("h00") @[AxonSystem.scala 24:17]
      skip @[AxonSystem.scala 23:31]
    else : @[AxonSystem.scala 25:28]
      when io.axonValid : @[AxonSystem.scala 25:28]
        node _spikeCntReg_T = add(spikeCntReg, UInt<1>("h01")) @[AxonSystem.scala 26:32]
        node _spikeCntReg_T_1 = tail(_spikeCntReg_T, 1) @[AxonSystem.scala 26:32]
        spikeCntReg <= _spikeCntReg_T_1 @[AxonSystem.scala 26:17]
        skip @[AxonSystem.scala 25:28]
    io.spikeCnt <= spikeCntReg @[AxonSystem.scala 28:15]
    wire ena0 : UInt<1> @[AxonSystem.scala 31:22]
    wire wr0 : UInt<1> @[AxonSystem.scala 32:22]
    wire rdata0 : UInt<10> @[AxonSystem.scala 33:22]
    wire wdata0 : UInt<10> @[AxonSystem.scala 34:22]
    wire addr0 : UInt<10> @[AxonSystem.scala 35:22]
    smem axonMem0 : UInt<10>[1024], undefined @[AxonSystem.scala 36:29]
    rdata0 is invalid @[AxonSystem.scala 38:10]
    when ena0 : @[AxonSystem.scala 39:14]
      when wr0 : @[AxonSystem.scala 40:15]
        infer mport MPORT = axonMem0[addr0], clock @[AxonSystem.scala 41:15]
        MPORT <= wdata0 @[AxonSystem.scala 41:23]
        skip @[AxonSystem.scala 40:15]
      else : @[AxonSystem.scala 42:17]
        infer mport rdata0_MPORT = axonMem0[addr0], clock @[AxonSystem.scala 43:25]
        rdata0 <= rdata0_MPORT @[AxonSystem.scala 43:14]
        skip @[AxonSystem.scala 42:17]
      skip @[AxonSystem.scala 39:14]
    wire ena1 : UInt<1> @[AxonSystem.scala 47:22]
    wire wr1 : UInt<1> @[AxonSystem.scala 48:22]
    wire rdata1 : UInt<10> @[AxonSystem.scala 49:22]
    wire wdata1 : UInt<10> @[AxonSystem.scala 50:22]
    wire addr1 : UInt<10> @[AxonSystem.scala 51:22]
    smem axonMem1 : UInt<10>[1024], undefined @[AxonSystem.scala 52:29]
    rdata1 is invalid @[AxonSystem.scala 54:10]
    when ena1 : @[AxonSystem.scala 55:14]
      when wr1 : @[AxonSystem.scala 56:15]
        infer mport MPORT_1 = axonMem1[addr1], clock @[AxonSystem.scala 57:15]
        MPORT_1 <= wdata1 @[AxonSystem.scala 57:23]
        skip @[AxonSystem.scala 56:15]
      else : @[AxonSystem.scala 58:17]
        infer mport rdata1_MPORT = axonMem1[addr1], clock @[AxonSystem.scala 59:25]
        rdata1 <= rdata1_MPORT @[AxonSystem.scala 59:14]
        skip @[AxonSystem.scala 58:17]
      skip @[AxonSystem.scala 55:14]
    node _T_1 = not(io.inOut) @[AxonSystem.scala 64:8]
    when _T_1 : @[AxonSystem.scala 64:19]
      ena0 <= io.axonValid @[AxonSystem.scala 65:12]
      wr0 <= UInt<1>("h01") @[AxonSystem.scala 66:12]
      wdata0 <= io.axonIn @[AxonSystem.scala 67:12]
      addr0 <= spikeCntReg @[AxonSystem.scala 68:12]
      ena1 <= io.rEna @[AxonSystem.scala 70:14]
      wr1 <= UInt<1>("h00") @[AxonSystem.scala 71:14]
      io.rData <= rdata1 @[AxonSystem.scala 72:14]
      wdata1 <= UInt<1>("h00") @[AxonSystem.scala 73:14]
      addr1 <= io.rAddr @[AxonSystem.scala 74:14]
      skip @[AxonSystem.scala 64:19]
    else : @[AxonSystem.scala 75:15]
      ena0 <= io.rEna @[AxonSystem.scala 76:14]
      wr0 <= UInt<1>("h00") @[AxonSystem.scala 77:14]
      io.rData <= rdata0 @[AxonSystem.scala 78:14]
      wdata0 <= UInt<1>("h00") @[AxonSystem.scala 79:14]
      addr0 <= io.rAddr @[AxonSystem.scala 80:14]
      ena1 <= io.axonValid @[AxonSystem.scala 82:14]
      wr1 <= UInt<1>("h01") @[AxonSystem.scala 83:14]
      wdata1 <= io.axonIn @[AxonSystem.scala 84:14]
      addr1 <= spikeCntReg @[AxonSystem.scala 85:14]
      skip @[AxonSystem.scala 75:15]
    
  module PriorityMaskRstEncoder_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip reqs : UInt<1>[8], value : UInt<3>, mask : UInt<1>[8], rst : UInt<1>[8], valid : UInt<1>}
    
    io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 16:12]
    io.valid <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 17:12]
    when io.reqs[0] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h00") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[1] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[2] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h02") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[3] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<2>("h03") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[4] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h04") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[5] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h05") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[6] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h06") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    when io.reqs[7] : @[PriorityMaskRstEncoder.scala 21:22]
      io.valid <= UInt<1>("h01") @[PriorityMaskRstEncoder.scala 22:16]
      io.value <= UInt<3>("h07") @[PriorityMaskRstEncoder.scala 23:16]
      skip @[PriorityMaskRstEncoder.scala 21:22]
    node _io_mask_0_T = or(io.mask[1], io.reqs[1]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[0] <= _io_mask_0_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_1_T = or(io.mask[2], io.reqs[2]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[1] <= _io_mask_1_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_2_T = or(io.mask[3], io.reqs[3]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[2] <= _io_mask_2_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_3_T = or(io.mask[4], io.reqs[4]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[3] <= _io_mask_3_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_4_T = or(io.mask[5], io.reqs[5]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[4] <= _io_mask_4_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_5_T = or(io.mask[6], io.reqs[6]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[5] <= _io_mask_5_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_6_T = or(io.mask[7], io.reqs[7]) @[PriorityMaskRstEncoder.scala 29:34]
    io.mask[6] <= _io_mask_6_T @[PriorityMaskRstEncoder.scala 29:16]
    node _io_mask_7_T = eq(io.value, UInt<1>("h00")) @[PriorityMaskRstEncoder.scala 30:38]
    io.mask[7] <= _io_mask_7_T @[PriorityMaskRstEncoder.scala 30:26]
    node _io_rst_0_T = eq(UInt<1>("h00"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_0_T_1 = and(_io_rst_0_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[0] <= _io_rst_0_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_1_T = eq(UInt<1>("h01"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_1_T_1 = and(_io_rst_1_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[1] <= _io_rst_1_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_2_T = eq(UInt<2>("h02"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_2_T_1 = and(_io_rst_2_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[2] <= _io_rst_2_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_3_T = eq(UInt<2>("h03"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_3_T_1 = and(_io_rst_3_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[3] <= _io_rst_3_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_4_T = eq(UInt<3>("h04"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_4_T_1 = and(_io_rst_4_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[4] <= _io_rst_4_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_5_T = eq(UInt<3>("h05"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_5_T_1 = and(_io_rst_5_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[5] <= _io_rst_5_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_6_T = eq(UInt<3>("h06"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_6_T_1 = and(_io_rst_6_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[6] <= _io_rst_6_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    node _io_rst_7_T = eq(UInt<3>("h07"), io.value) @[PriorityMaskRstEncoder.scala 34:22]
    node _io_rst_7_T_1 = and(_io_rst_7_T, io.valid) @[PriorityMaskRstEncoder.scala 34:35]
    io.rst[7] <= _io_rst_7_T_1 @[PriorityMaskRstEncoder.scala 34:15]
    
  module TransmissionSystem_3 : 
    input clock : Clock
    input reset : Reset
    output io : {data : UInt<11>, flip ready : UInt<1>, valid : UInt<1>, flip n : UInt<5>, flip spikes : UInt<1>[8]}
    
    wire _spikeRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[0] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[1] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[2] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[3] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[4] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[5] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[6] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    _spikeRegs_WIRE[7] <= UInt<1>("h00") @[TransmissionSystem.scala 18:37]
    reg spikeRegs : UInt<1>[8], clock with : (reset => (reset, _spikeRegs_WIRE)) @[TransmissionSystem.scala 18:29]
    wire _neuronIdMSB_WIRE : UInt<5>[8] @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[0] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[1] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[2] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[3] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[4] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[5] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[6] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    _neuronIdMSB_WIRE[7] <= UInt<5>("h00") @[TransmissionSystem.scala 19:37]
    reg neuronIdMSB : UInt<5>[8], clock with : (reset => (reset, _neuronIdMSB_WIRE)) @[TransmissionSystem.scala 19:29]
    wire _maskRegs_WIRE : UInt<1>[8] @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[0] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[1] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[2] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[3] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[4] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[5] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[6] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    _maskRegs_WIRE[7] <= UInt<1>("h01") @[TransmissionSystem.scala 20:37]
    reg maskRegs : UInt<1>[8], clock with : (reset => (reset, _maskRegs_WIRE)) @[TransmissionSystem.scala 20:29]
    inst spikeEncoder of PriorityMaskRstEncoder_3 @[TransmissionSystem.scala 22:28]
    spikeEncoder.clock <= clock
    spikeEncoder.reset <= reset
    wire encoderReqs : UInt<1>[8] @[TransmissionSystem.scala 23:26]
    wire rstReadySel : UInt<1>[8] @[TransmissionSystem.scala 24:26]
    wire spikeUpdate : UInt<1>[8] @[TransmissionSystem.scala 25:26]
    io.data <= UInt<1>("h00") @[TransmissionSystem.scala 28:12]
    io.valid <= spikeEncoder.io.valid @[TransmissionSystem.scala 29:12]
    spikeEncoder.io.reqs[0] <= encoderReqs[0] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[1] <= encoderReqs[1] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[2] <= encoderReqs[2] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[3] <= encoderReqs[3] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[4] <= encoderReqs[4] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[5] <= encoderReqs[5] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[6] <= encoderReqs[6] @[TransmissionSystem.scala 30:24]
    spikeEncoder.io.reqs[7] <= encoderReqs[7] @[TransmissionSystem.scala 30:24]
    node _encoderReqs_0_T = and(maskRegs[0], spikeRegs[0]) @[TransmissionSystem.scala 33:35]
    encoderReqs[0] <= _encoderReqs_0_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_0_T = and(spikeEncoder.io.rst[0], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_0_T_1 = not(_rstReadySel_0_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[0] <= _rstReadySel_0_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_0_T = and(rstReadySel[0], spikeRegs[0]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[0] <= _spikeUpdate_0_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[0] <= spikeEncoder.io.mask[0] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T : @[TransmissionSystem.scala 40:40]
        maskRegs[0] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_1 = not(spikeUpdate[0]) @[TransmissionSystem.scala 44:10]
    when _T_1 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[0] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[0] <= io.spikes[0] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_2 = eq(UInt<1>("h00"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_2 : @[TransmissionSystem.scala 49:41]
      node _io_data_T = cat(UInt<3>("h03"), neuronIdMSB[0]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_1 = cat(_io_data_T, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_1 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_1_T = and(maskRegs[1], spikeRegs[1]) @[TransmissionSystem.scala 33:35]
    encoderReqs[1] <= _encoderReqs_1_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_1_T = and(spikeEncoder.io.rst[1], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_1_T_1 = not(_rstReadySel_1_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[1] <= _rstReadySel_1_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_1_T = and(rstReadySel[1], spikeRegs[1]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[1] <= _spikeUpdate_1_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[1] <= spikeEncoder.io.mask[1] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_3 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_3 : @[TransmissionSystem.scala 40:40]
        maskRegs[1] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_4 = not(spikeUpdate[1]) @[TransmissionSystem.scala 44:10]
    when _T_4 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[1] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[1] <= io.spikes[1] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_5 = eq(UInt<1>("h01"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_5 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_2 = cat(UInt<3>("h03"), neuronIdMSB[1]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_3 = cat(_io_data_T_2, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_3 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_2_T = and(maskRegs[2], spikeRegs[2]) @[TransmissionSystem.scala 33:35]
    encoderReqs[2] <= _encoderReqs_2_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_2_T = and(spikeEncoder.io.rst[2], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_2_T_1 = not(_rstReadySel_2_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[2] <= _rstReadySel_2_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_2_T = and(rstReadySel[2], spikeRegs[2]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[2] <= _spikeUpdate_2_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[2] <= spikeEncoder.io.mask[2] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_6 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_6 : @[TransmissionSystem.scala 40:40]
        maskRegs[2] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_7 = not(spikeUpdate[2]) @[TransmissionSystem.scala 44:10]
    when _T_7 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[2] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[2] <= io.spikes[2] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_8 = eq(UInt<2>("h02"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_8 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_4 = cat(UInt<3>("h03"), neuronIdMSB[2]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_5 = cat(_io_data_T_4, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_5 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_3_T = and(maskRegs[3], spikeRegs[3]) @[TransmissionSystem.scala 33:35]
    encoderReqs[3] <= _encoderReqs_3_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_3_T = and(spikeEncoder.io.rst[3], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_3_T_1 = not(_rstReadySel_3_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[3] <= _rstReadySel_3_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_3_T = and(rstReadySel[3], spikeRegs[3]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[3] <= _spikeUpdate_3_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[3] <= spikeEncoder.io.mask[3] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_9 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_9 : @[TransmissionSystem.scala 40:40]
        maskRegs[3] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_10 = not(spikeUpdate[3]) @[TransmissionSystem.scala 44:10]
    when _T_10 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[3] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[3] <= io.spikes[3] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_11 = eq(UInt<2>("h03"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_11 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_6 = cat(UInt<3>("h03"), neuronIdMSB[3]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_7 = cat(_io_data_T_6, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_7 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_4_T = and(maskRegs[4], spikeRegs[4]) @[TransmissionSystem.scala 33:35]
    encoderReqs[4] <= _encoderReqs_4_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_4_T = and(spikeEncoder.io.rst[4], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_4_T_1 = not(_rstReadySel_4_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[4] <= _rstReadySel_4_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_4_T = and(rstReadySel[4], spikeRegs[4]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[4] <= _spikeUpdate_4_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[4] <= spikeEncoder.io.mask[4] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_12 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_12 : @[TransmissionSystem.scala 40:40]
        maskRegs[4] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_13 = not(spikeUpdate[4]) @[TransmissionSystem.scala 44:10]
    when _T_13 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[4] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[4] <= io.spikes[4] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_14 = eq(UInt<3>("h04"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_14 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_8 = cat(UInt<3>("h03"), neuronIdMSB[4]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_9 = cat(_io_data_T_8, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_9 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_5_T = and(maskRegs[5], spikeRegs[5]) @[TransmissionSystem.scala 33:35]
    encoderReqs[5] <= _encoderReqs_5_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_5_T = and(spikeEncoder.io.rst[5], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_5_T_1 = not(_rstReadySel_5_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[5] <= _rstReadySel_5_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_5_T = and(rstReadySel[5], spikeRegs[5]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[5] <= _spikeUpdate_5_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[5] <= spikeEncoder.io.mask[5] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_15 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_15 : @[TransmissionSystem.scala 40:40]
        maskRegs[5] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_16 = not(spikeUpdate[5]) @[TransmissionSystem.scala 44:10]
    when _T_16 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[5] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[5] <= io.spikes[5] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_17 = eq(UInt<3>("h05"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_17 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_10 = cat(UInt<3>("h03"), neuronIdMSB[5]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_11 = cat(_io_data_T_10, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_11 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_6_T = and(maskRegs[6], spikeRegs[6]) @[TransmissionSystem.scala 33:35]
    encoderReqs[6] <= _encoderReqs_6_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_6_T = and(spikeEncoder.io.rst[6], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_6_T_1 = not(_rstReadySel_6_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[6] <= _rstReadySel_6_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_6_T = and(rstReadySel[6], spikeRegs[6]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[6] <= _spikeUpdate_6_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[6] <= spikeEncoder.io.mask[6] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_18 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_18 : @[TransmissionSystem.scala 40:40]
        maskRegs[6] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_19 = not(spikeUpdate[6]) @[TransmissionSystem.scala 44:10]
    when _T_19 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[6] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[6] <= io.spikes[6] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_20 = eq(UInt<3>("h06"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_20 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_12 = cat(UInt<3>("h03"), neuronIdMSB[6]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_13 = cat(_io_data_T_12, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_13 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    node _encoderReqs_7_T = and(maskRegs[7], spikeRegs[7]) @[TransmissionSystem.scala 33:35]
    encoderReqs[7] <= _encoderReqs_7_T @[TransmissionSystem.scala 33:20]
    node _rstReadySel_7_T = and(spikeEncoder.io.rst[7], io.ready) @[TransmissionSystem.scala 35:48]
    node _rstReadySel_7_T_1 = not(_rstReadySel_7_T) @[TransmissionSystem.scala 35:23]
    rstReadySel[7] <= _rstReadySel_7_T_1 @[TransmissionSystem.scala 35:20]
    node _spikeUpdate_7_T = and(rstReadySel[7], spikeRegs[7]) @[TransmissionSystem.scala 36:38]
    spikeUpdate[7] <= _spikeUpdate_7_T @[TransmissionSystem.scala 36:20]
    when io.ready : @[TransmissionSystem.scala 38:20]
      maskRegs[7] <= spikeEncoder.io.mask[7] @[TransmissionSystem.scala 39:19]
      skip @[TransmissionSystem.scala 38:20]
    else : @[TransmissionSystem.scala 40:40]
      node _T_21 = eq(spikeEncoder.io.valid, UInt<1>("h00")) @[TransmissionSystem.scala 40:16]
      when _T_21 : @[TransmissionSystem.scala 40:40]
        maskRegs[7] <= UInt<1>("h01") @[TransmissionSystem.scala 41:19]
        skip @[TransmissionSystem.scala 40:40]
    node _T_22 = not(spikeUpdate[7]) @[TransmissionSystem.scala 44:10]
    when _T_22 : @[TransmissionSystem.scala 44:27]
      neuronIdMSB[7] <= io.n @[TransmissionSystem.scala 45:22]
      spikeRegs[7] <= io.spikes[7] @[TransmissionSystem.scala 46:20]
      skip @[TransmissionSystem.scala 44:27]
    node _T_23 = eq(UInt<3>("h07"), spikeEncoder.io.value) @[TransmissionSystem.scala 49:14]
    when _T_23 : @[TransmissionSystem.scala 49:41]
      node _io_data_T_14 = cat(UInt<3>("h03"), neuronIdMSB[7]) @[TransmissionSystem.scala 50:44]
      node _io_data_T_15 = cat(_io_data_T_14, spikeEncoder.io.value) @[TransmissionSystem.scala 50:62]
      io.data <= _io_data_T_15 @[TransmissionSystem.scala 50:15]
      skip @[TransmissionSystem.scala 49:41]
    
  module ControlUnit_1 : 
    input clock : Clock
    input reset : Reset
    output io : {done : UInt<1>, flip newTS : UInt<1>, addr : {sel : UInt<2>, pos : UInt<15>}, wr : UInt<1>, ena : UInt<1>, flip spikeIndi : UInt<1>[8], flip refracIndi : UInt<1>[8], cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}[8], evalEnable : UInt<1>, inOut : UInt<1>, flip spikeCnt : UInt<10>, aAddr : UInt<10>, aEna : UInt<1>, flip aData : UInt<10>, n : UInt<5>, spikes : UInt<1>[8]}
    
    reg state : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[ControlUnit.scala 36:22]
    wire _spikePulse_WIRE : UInt<1>[8] @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[0] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[1] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[2] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[3] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[4] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[5] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[6] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    _spikePulse_WIRE[7] <= UInt<1>("h00") @[ControlUnit.scala 42:35]
    reg spikePulse : UInt<1>[8], clock with : (reset => (reset, _spikePulse_WIRE)) @[ControlUnit.scala 42:27]
    reg n : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[ControlUnit.scala 45:22]
    io.n <= n @[ControlUnit.scala 46:12]
    reg a : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[ControlUnit.scala 47:22]
    io.aAddr <= a @[ControlUnit.scala 48:12]
    reg spikeCnt : UInt<10>, clock with : (reset => (reset, UInt<10>("h00"))) @[ControlUnit.scala 50:25]
    reg inOut : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[ControlUnit.scala 52:22]
    io.inOut <= inOut @[ControlUnit.scala 53:12]
    wire _evalUnitActive_WIRE : UInt<1>[8] @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[0] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[1] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[2] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[3] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[4] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[5] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[6] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    _evalUnitActive_WIRE[7] <= UInt<1>("h00") @[ControlUnit.scala 55:39]
    reg evalUnitActive : UInt<1>[8], clock with : (reset => (reset, _evalUnitActive_WIRE)) @[ControlUnit.scala 55:31]
    wire localCntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}[8] @[ControlUnit.scala 56:28]
    reg nrNeuMapped : UInt, clock with : (reset => (reset, UInt<8>("h0c8"))) @[ControlUnit.scala 58:28]
    spikePulse[0] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[0].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[0].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[0].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[0].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[0].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_0_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_0_T_1 = add(_evalUnitActive_0_T, UInt<1>("h00")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_0_T_2 = tail(_evalUnitActive_0_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_0_T_3 = gt(nrNeuMapped, _evalUnitActive_0_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[0] <= _evalUnitActive_0_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[0] : @[ControlUnit.scala 71:29]
      io.cntrSels[0].potSel <= localCntrSels[0].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[0].spikeSel <= localCntrSels[0].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[0].refracSel <= localCntrSels[0].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[0].writeDataSel <= localCntrSels[0].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[0].decaySel <= localCntrSels[0].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[0].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[0].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[0].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[0].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[0].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[0] <= spikePulse[0] @[ControlUnit.scala 86:18]
    spikePulse[1] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[1].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[1].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[1].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[1].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[1].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_1_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_1_T_1 = add(_evalUnitActive_1_T, UInt<1>("h01")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_1_T_2 = tail(_evalUnitActive_1_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_1_T_3 = gt(nrNeuMapped, _evalUnitActive_1_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[1] <= _evalUnitActive_1_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[1] : @[ControlUnit.scala 71:29]
      io.cntrSels[1].potSel <= localCntrSels[1].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[1].spikeSel <= localCntrSels[1].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[1].refracSel <= localCntrSels[1].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[1].writeDataSel <= localCntrSels[1].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[1].decaySel <= localCntrSels[1].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[1].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[1].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[1].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[1].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[1].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[1] <= spikePulse[1] @[ControlUnit.scala 86:18]
    spikePulse[2] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[2].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[2].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[2].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[2].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[2].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_2_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_2_T_1 = add(_evalUnitActive_2_T, UInt<2>("h02")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_2_T_2 = tail(_evalUnitActive_2_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_2_T_3 = gt(nrNeuMapped, _evalUnitActive_2_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[2] <= _evalUnitActive_2_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[2] : @[ControlUnit.scala 71:29]
      io.cntrSels[2].potSel <= localCntrSels[2].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[2].spikeSel <= localCntrSels[2].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[2].refracSel <= localCntrSels[2].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[2].writeDataSel <= localCntrSels[2].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[2].decaySel <= localCntrSels[2].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[2].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[2].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[2].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[2].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[2].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[2] <= spikePulse[2] @[ControlUnit.scala 86:18]
    spikePulse[3] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[3].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[3].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[3].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[3].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[3].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_3_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_3_T_1 = add(_evalUnitActive_3_T, UInt<2>("h03")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_3_T_2 = tail(_evalUnitActive_3_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_3_T_3 = gt(nrNeuMapped, _evalUnitActive_3_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[3] <= _evalUnitActive_3_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[3] : @[ControlUnit.scala 71:29]
      io.cntrSels[3].potSel <= localCntrSels[3].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[3].spikeSel <= localCntrSels[3].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[3].refracSel <= localCntrSels[3].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[3].writeDataSel <= localCntrSels[3].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[3].decaySel <= localCntrSels[3].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[3].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[3].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[3].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[3].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[3].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[3] <= spikePulse[3] @[ControlUnit.scala 86:18]
    spikePulse[4] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[4].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[4].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[4].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[4].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[4].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_4_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_4_T_1 = add(_evalUnitActive_4_T, UInt<3>("h04")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_4_T_2 = tail(_evalUnitActive_4_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_4_T_3 = gt(nrNeuMapped, _evalUnitActive_4_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[4] <= _evalUnitActive_4_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[4] : @[ControlUnit.scala 71:29]
      io.cntrSels[4].potSel <= localCntrSels[4].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[4].spikeSel <= localCntrSels[4].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[4].refracSel <= localCntrSels[4].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[4].writeDataSel <= localCntrSels[4].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[4].decaySel <= localCntrSels[4].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[4].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[4].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[4].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[4].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[4].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[4] <= spikePulse[4] @[ControlUnit.scala 86:18]
    spikePulse[5] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[5].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[5].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[5].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[5].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[5].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_5_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_5_T_1 = add(_evalUnitActive_5_T, UInt<3>("h05")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_5_T_2 = tail(_evalUnitActive_5_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_5_T_3 = gt(nrNeuMapped, _evalUnitActive_5_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[5] <= _evalUnitActive_5_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[5] : @[ControlUnit.scala 71:29]
      io.cntrSels[5].potSel <= localCntrSels[5].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[5].spikeSel <= localCntrSels[5].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[5].refracSel <= localCntrSels[5].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[5].writeDataSel <= localCntrSels[5].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[5].decaySel <= localCntrSels[5].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[5].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[5].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[5].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[5].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[5].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[5] <= spikePulse[5] @[ControlUnit.scala 86:18]
    spikePulse[6] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[6].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[6].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[6].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[6].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[6].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_6_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_6_T_1 = add(_evalUnitActive_6_T, UInt<3>("h06")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_6_T_2 = tail(_evalUnitActive_6_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_6_T_3 = gt(nrNeuMapped, _evalUnitActive_6_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[6] <= _evalUnitActive_6_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[6] : @[ControlUnit.scala 71:29]
      io.cntrSels[6].potSel <= localCntrSels[6].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[6].spikeSel <= localCntrSels[6].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[6].refracSel <= localCntrSels[6].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[6].writeDataSel <= localCntrSels[6].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[6].decaySel <= localCntrSels[6].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[6].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[6].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[6].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[6].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[6].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[6] <= spikePulse[6] @[ControlUnit.scala 86:18]
    spikePulse[7] <= UInt<1>("h00") @[ControlUnit.scala 62:35]
    localCntrSels[7].potSel <= UInt<2>("h02") @[ControlUnit.scala 63:35]
    localCntrSels[7].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 64:35]
    localCntrSels[7].refracSel <= UInt<1>("h01") @[ControlUnit.scala 65:35]
    localCntrSels[7].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 66:35]
    localCntrSels[7].decaySel <= UInt<1>("h00") @[ControlUnit.scala 67:35]
    node _evalUnitActive_7_T = shl(n, 3) @[ControlUnit.scala 70:44]
    node _evalUnitActive_7_T_1 = add(_evalUnitActive_7_T, UInt<3>("h07")) @[ControlUnit.scala 70:66]
    node _evalUnitActive_7_T_2 = tail(_evalUnitActive_7_T_1, 1) @[ControlUnit.scala 70:66]
    node _evalUnitActive_7_T_3 = gt(nrNeuMapped, _evalUnitActive_7_T_2) @[ControlUnit.scala 70:38]
    evalUnitActive[7] <= _evalUnitActive_7_T_3 @[ControlUnit.scala 70:23]
    when evalUnitActive[7] : @[ControlUnit.scala 71:29]
      io.cntrSels[7].potSel <= localCntrSels[7].potSel @[ControlUnit.scala 72:35]
      io.cntrSels[7].spikeSel <= localCntrSels[7].spikeSel @[ControlUnit.scala 73:35]
      io.cntrSels[7].refracSel <= localCntrSels[7].refracSel @[ControlUnit.scala 74:35]
      io.cntrSels[7].writeDataSel <= localCntrSels[7].writeDataSel @[ControlUnit.scala 75:35]
      io.cntrSels[7].decaySel <= localCntrSels[7].decaySel @[ControlUnit.scala 76:35]
      skip @[ControlUnit.scala 71:29]
    else : @[ControlUnit.scala 77:17]
      io.cntrSels[7].potSel <= UInt<2>("h02") @[ControlUnit.scala 78:35]
      io.cntrSels[7].spikeSel <= UInt<2>("h02") @[ControlUnit.scala 79:35]
      io.cntrSels[7].refracSel <= UInt<1>("h01") @[ControlUnit.scala 80:35]
      io.cntrSels[7].writeDataSel <= UInt<1>("h00") @[ControlUnit.scala 81:35]
      io.cntrSels[7].decaySel <= UInt<1>("h00") @[ControlUnit.scala 82:35]
      skip @[ControlUnit.scala 77:17]
    io.spikes[7] <= spikePulse[7] @[ControlUnit.scala 86:18]
    io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 89:15]
    io.addr.pos <= UInt<1>("h00") @[ControlUnit.scala 90:15]
    io.ena <= UInt<1>("h00") @[ControlUnit.scala 91:10]
    io.wr <= UInt<1>("h00") @[ControlUnit.scala 92:10]
    io.evalEnable <= UInt<1>("h01") @[ControlUnit.scala 94:17]
    io.aEna <= UInt<1>("h00") @[ControlUnit.scala 96:11]
    io.done <= UInt<1>("h00") @[ControlUnit.scala 99:11]
    node _T = eq(UInt<4>("h00"), state) @[Conditional.scala 37:30]
    when _T : @[Conditional.scala 40:58]
      io.done <= UInt<1>("h01") @[ControlUnit.scala 103:15]
      n <= UInt<1>("h00") @[ControlUnit.scala 104:9]
      a <= UInt<1>("h00") @[ControlUnit.scala 105:9]
      io.evalEnable <= UInt<1>("h00") @[ControlUnit.scala 106:21]
      when io.newTS : @[ControlUnit.scala 107:22]
        io.done <= UInt<1>("h00") @[ControlUnit.scala 108:18]
        spikeCnt <= io.spikeCnt @[ControlUnit.scala 109:18]
        node _inOut_T = not(inOut) @[ControlUnit.scala 110:21]
        inOut <= _inOut_T @[ControlUnit.scala 110:18]
        state <= UInt<4>("h01") @[ControlUnit.scala 111:18]
        skip @[ControlUnit.scala 107:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_1 = eq(UInt<4>("h01"), state) @[Conditional.scala 37:30]
      when _T_1 : @[Conditional.scala 39:67]
        io.ena <= UInt<1>("h01") @[ControlUnit.scala 117:19]
        io.wr <= UInt<1>("h00") @[ControlUnit.scala 118:19]
        io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 119:19]
        io.addr.pos <= n @[ControlUnit.scala 120:19]
        localCntrSels[0].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[1].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[2].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[3].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[4].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[5].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[6].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        localCntrSels[7].spikeSel <= UInt<1>("h01") @[ControlUnit.scala 123:35]
        state <= UInt<4>("h02") @[ControlUnit.scala 125:13]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_2 = eq(UInt<4>("h02"), state) @[Conditional.scala 37:30]
        when _T_2 : @[Conditional.scala 39:67]
          io.ena <= UInt<1>("h01") @[ControlUnit.scala 130:19]
          io.wr <= UInt<1>("h00") @[ControlUnit.scala 131:19]
          io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 132:19]
          node _io_addr_pos_T = add(n, UInt<6>("h020")) @[ControlUnit.scala 133:24]
          node _io_addr_pos_T_1 = tail(_io_addr_pos_T, 1) @[ControlUnit.scala 133:24]
          io.addr.pos <= _io_addr_pos_T_1 @[ControlUnit.scala 133:19]
          localCntrSels[0].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[1].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[2].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[3].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[4].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[5].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[6].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          localCntrSels[7].refracSel <= UInt<1>("h00") @[ControlUnit.scala 136:36]
          state <= UInt<4>("h03") @[ControlUnit.scala 138:13]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<4>("h03"), state) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            io.ena <= UInt<1>("h01") @[ControlUnit.scala 143:19]
            io.wr <= UInt<1>("h00") @[ControlUnit.scala 144:19]
            io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 145:19]
            io.addr.pos <= UInt<2>("h02") @[ControlUnit.scala 146:19]
            node _a_T = add(a, UInt<1>("h01")) @[ControlUnit.scala 148:14]
            node _a_T_1 = tail(_a_T, 1) @[ControlUnit.scala 148:14]
            a <= _a_T_1 @[ControlUnit.scala 148:9]
            io.aEna <= UInt<1>("h01") @[ControlUnit.scala 149:15]
            localCntrSels[0].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[1].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[2].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[3].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[4].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[5].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[6].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            localCntrSels[7].potSel <= UInt<1>("h00") @[ControlUnit.scala 152:33]
            node _T_4 = eq(spikeCnt, UInt<1>("h00")) @[ControlUnit.scala 154:21]
            when _T_4 : @[ControlUnit.scala 154:30]
              state <= UInt<4>("h06") @[ControlUnit.scala 155:15]
              skip @[ControlUnit.scala 154:30]
            else : @[ControlUnit.scala 156:19]
              state <= UInt<4>("h04") @[ControlUnit.scala 157:15]
              skip @[ControlUnit.scala 156:19]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_5 = eq(UInt<4>("h04"), state) @[Conditional.scala 37:30]
            when _T_5 : @[Conditional.scala 39:67]
              io.ena <= UInt<1>("h01") @[ControlUnit.scala 163:19]
              io.wr <= UInt<1>("h00") @[ControlUnit.scala 164:19]
              io.addr.sel <= UInt<2>("h03") @[ControlUnit.scala 165:19]
              node _io_addr_pos_T_2 = mul(n, UInt<10>("h0300")) @[ControlUnit.scala 167:27]
              node _io_addr_pos_T_3 = add(_io_addr_pos_T_2, io.aData) @[ControlUnit.scala 167:40]
              node _io_addr_pos_T_4 = tail(_io_addr_pos_T_3, 1) @[ControlUnit.scala 167:40]
              io.addr.pos <= _io_addr_pos_T_4 @[ControlUnit.scala 167:21]
              io.aEna <= UInt<1>("h01") @[ControlUnit.scala 172:15]
              node _a_T_2 = add(a, UInt<1>("h01")) @[ControlUnit.scala 173:14]
              node _a_T_3 = tail(_a_T_2, 1) @[ControlUnit.scala 173:14]
              a <= _a_T_3 @[ControlUnit.scala 173:9]
              when io.refracIndi[0] : @[ControlUnit.scala 176:32]
                localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[0].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[1] : @[ControlUnit.scala 176:32]
                localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[1].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[2] : @[ControlUnit.scala 176:32]
                localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[2].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[3] : @[ControlUnit.scala 176:32]
                localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[3].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[4] : @[ControlUnit.scala 176:32]
                localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[4].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[5] : @[ControlUnit.scala 176:32]
                localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[5].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[6] : @[ControlUnit.scala 176:32]
                localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[6].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              when io.refracIndi[7] : @[ControlUnit.scala 176:32]
                localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 177:37]
                localCntrSels[7].decaySel <= UInt<1>("h01") @[ControlUnit.scala 178:37]
                skip @[ControlUnit.scala 176:32]
              node _T_6 = eq(spikeCnt, a) @[ControlUnit.scala 182:21]
              when _T_6 : @[ControlUnit.scala 182:28]
                state <= UInt<4>("h06") @[ControlUnit.scala 183:15]
                skip @[ControlUnit.scala 182:28]
              else : @[ControlUnit.scala 184:19]
                state <= UInt<4>("h05") @[ControlUnit.scala 185:15]
                skip @[ControlUnit.scala 184:19]
              skip @[Conditional.scala 39:67]
            else : @[Conditional.scala 39:67]
              node _T_7 = eq(UInt<4>("h05"), state) @[Conditional.scala 37:30]
              when _T_7 : @[Conditional.scala 39:67]
                io.ena <= UInt<1>("h01") @[ControlUnit.scala 191:19]
                io.wr <= UInt<1>("h00") @[ControlUnit.scala 192:19]
                io.addr.sel <= UInt<2>("h03") @[ControlUnit.scala 193:19]
                node _io_addr_pos_T_5 = mul(n, UInt<10>("h0300")) @[ControlUnit.scala 195:27]
                node _io_addr_pos_T_6 = add(_io_addr_pos_T_5, io.aData) @[ControlUnit.scala 195:40]
                node _io_addr_pos_T_7 = tail(_io_addr_pos_T_6, 1) @[ControlUnit.scala 195:40]
                io.addr.pos <= _io_addr_pos_T_7 @[ControlUnit.scala 195:21]
                node _a_T_4 = add(a, UInt<1>("h01")) @[ControlUnit.scala 200:14]
                node _a_T_5 = tail(_a_T_4, 1) @[ControlUnit.scala 200:14]
                a <= _a_T_5 @[ControlUnit.scala 200:9]
                io.aEna <= UInt<1>("h01") @[ControlUnit.scala 201:15]
                when io.refracIndi[0] : @[ControlUnit.scala 204:32]
                  localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[1] : @[ControlUnit.scala 204:32]
                  localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[2] : @[ControlUnit.scala 204:32]
                  localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[3] : @[ControlUnit.scala 204:32]
                  localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[4] : @[ControlUnit.scala 204:32]
                  localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[5] : @[ControlUnit.scala 204:32]
                  localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[6] : @[ControlUnit.scala 204:32]
                  localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                when io.refracIndi[7] : @[ControlUnit.scala 204:32]
                  localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 205:35]
                  skip @[ControlUnit.scala 204:32]
                node _T_8 = sub(a, UInt<1>("h01")) @[ControlUnit.scala 209:27]
                node _T_9 = tail(_T_8, 1) @[ControlUnit.scala 209:27]
                node _T_10 = eq(spikeCnt, _T_9) @[ControlUnit.scala 209:21]
                when _T_10 : @[ControlUnit.scala 209:34]
                  state <= UInt<4>("h06") @[ControlUnit.scala 210:15]
                  skip @[ControlUnit.scala 209:34]
                else : @[ControlUnit.scala 211:19]
                  state <= UInt<4>("h05") @[ControlUnit.scala 212:15]
                  skip @[ControlUnit.scala 211:19]
                skip @[Conditional.scala 39:67]
              else : @[Conditional.scala 39:67]
                node _T_11 = eq(UInt<4>("h06"), state) @[Conditional.scala 37:30]
                when _T_11 : @[Conditional.scala 39:67]
                  io.ena <= UInt<1>("h01") @[ControlUnit.scala 218:19]
                  io.wr <= UInt<1>("h00") @[ControlUnit.scala 219:19]
                  io.addr.sel <= UInt<2>("h02") @[ControlUnit.scala 220:19]
                  io.addr.pos <= n @[ControlUnit.scala 221:19]
                  node _T_12 = eq(spikeCnt, UInt<1>("h00")) @[ControlUnit.scala 223:21]
                  when _T_12 : @[ControlUnit.scala 223:30]
                    when io.refracIndi[0] : @[ControlUnit.scala 225:34]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[0].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[1] : @[ControlUnit.scala 225:34]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[1].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[2] : @[ControlUnit.scala 225:34]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[2].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[3] : @[ControlUnit.scala 225:34]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[3].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[4] : @[ControlUnit.scala 225:34]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[4].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[5] : @[ControlUnit.scala 225:34]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[5].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[6] : @[ControlUnit.scala 225:34]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[6].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    when io.refracIndi[7] : @[ControlUnit.scala 225:34]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 226:39]
                      localCntrSels[7].decaySel <= UInt<1>("h01") @[ControlUnit.scala 227:39]
                      skip @[ControlUnit.scala 225:34]
                    skip @[ControlUnit.scala 223:30]
                  else : @[ControlUnit.scala 230:19]
                    when io.refracIndi[0] : @[ControlUnit.scala 232:34]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[1] : @[ControlUnit.scala 232:34]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[2] : @[ControlUnit.scala 232:34]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[3] : @[ControlUnit.scala 232:34]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[4] : @[ControlUnit.scala 232:34]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[5] : @[ControlUnit.scala 232:34]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[6] : @[ControlUnit.scala 232:34]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    when io.refracIndi[7] : @[ControlUnit.scala 232:34]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 233:37]
                      skip @[ControlUnit.scala 232:34]
                    skip @[ControlUnit.scala 230:19]
                  state <= UInt<4>("h07") @[ControlUnit.scala 238:13]
                  skip @[Conditional.scala 39:67]
                else : @[Conditional.scala 39:67]
                  node _T_13 = eq(UInt<4>("h07"), state) @[Conditional.scala 37:30]
                  when _T_13 : @[Conditional.scala 39:67]
                    io.ena <= UInt<1>("h01") @[ControlUnit.scala 243:20]
                    io.wr <= UInt<1>("h00") @[ControlUnit.scala 244:20]
                    io.addr.sel <= UInt<2>("h02") @[ControlUnit.scala 245:20]
                    node _io_addr_pos_T_8 = add(n, UInt<6>("h020")) @[ControlUnit.scala 246:25]
                    node _io_addr_pos_T_9 = tail(_io_addr_pos_T_8, 1) @[ControlUnit.scala 246:25]
                    io.addr.pos <= _io_addr_pos_T_9 @[ControlUnit.scala 246:20]
                    when io.refracIndi[0] : @[ControlUnit.scala 249:32]
                      localCntrSels[0].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[1] : @[ControlUnit.scala 249:32]
                      localCntrSels[1].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[2] : @[ControlUnit.scala 249:32]
                      localCntrSels[2].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[3] : @[ControlUnit.scala 249:32]
                      localCntrSels[3].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[4] : @[ControlUnit.scala 249:32]
                      localCntrSels[4].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[5] : @[ControlUnit.scala 249:32]
                      localCntrSels[5].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[6] : @[ControlUnit.scala 249:32]
                      localCntrSels[6].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    when io.refracIndi[7] : @[ControlUnit.scala 249:32]
                      localCntrSels[7].potSel <= UInt<1>("h01") @[ControlUnit.scala 250:35]
                      skip @[ControlUnit.scala 249:32]
                    state <= UInt<4>("h08") @[ControlUnit.scala 254:13]
                    skip @[Conditional.scala 39:67]
                  else : @[Conditional.scala 39:67]
                    node _T_14 = eq(UInt<4>("h08"), state) @[Conditional.scala 37:30]
                    when _T_14 : @[Conditional.scala 39:67]
                      io.ena <= UInt<1>("h01") @[ControlUnit.scala 259:19]
                      io.wr <= UInt<1>("h00") @[ControlUnit.scala 260:19]
                      io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 261:19]
                      io.addr.pos <= UInt<2>("h01") @[ControlUnit.scala 262:19]
                      localCntrSels[0].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[1].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[2].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[3].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[4].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[5].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[6].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      localCntrSels[7].spikeSel <= UInt<1>("h00") @[ControlUnit.scala 265:35]
                      state <= UInt<4>("h09") @[ControlUnit.scala 267:13]
                      skip @[Conditional.scala 39:67]
                    else : @[Conditional.scala 39:67]
                      node _T_15 = eq(UInt<4>("h09"), state) @[Conditional.scala 37:30]
                      when _T_15 : @[Conditional.scala 39:67]
                        io.ena <= UInt<1>("h01") @[ControlUnit.scala 272:19]
                        io.wr <= UInt<1>("h01") @[ControlUnit.scala 273:19]
                        io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 274:19]
                        io.addr.pos <= n @[ControlUnit.scala 275:19]
                        localCntrSels[0].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[0] <= io.spikeIndi[0] @[ControlUnit.scala 279:23]
                        localCntrSels[1].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[1] <= io.spikeIndi[1] @[ControlUnit.scala 279:23]
                        localCntrSels[2].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[2] <= io.spikeIndi[2] @[ControlUnit.scala 279:23]
                        localCntrSels[3].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[3] <= io.spikeIndi[3] @[ControlUnit.scala 279:23]
                        localCntrSels[4].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[4] <= io.spikeIndi[4] @[ControlUnit.scala 279:23]
                        localCntrSels[5].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[5] <= io.spikeIndi[5] @[ControlUnit.scala 279:23]
                        localCntrSels[6].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[6] <= io.spikeIndi[6] @[ControlUnit.scala 279:23]
                        localCntrSels[7].writeDataSel <= UInt<2>("h02") @[ControlUnit.scala 278:39]
                        spikePulse[7] <= io.spikeIndi[7] @[ControlUnit.scala 279:23]
                        state <= UInt<4>("h0a") @[ControlUnit.scala 282:13]
                        skip @[Conditional.scala 39:67]
                      else : @[Conditional.scala 39:67]
                        node _T_16 = eq(UInt<4>("h0a"), state) @[Conditional.scala 37:30]
                        when _T_16 : @[Conditional.scala 39:67]
                          io.ena <= UInt<1>("h01") @[ControlUnit.scala 287:20]
                          io.wr <= UInt<1>("h00") @[ControlUnit.scala 288:20]
                          io.addr.sel <= UInt<2>("h00") @[ControlUnit.scala 289:19]
                          io.addr.pos <= UInt<2>("h00") @[ControlUnit.scala 290:19]
                          state <= UInt<4>("h0b") @[ControlUnit.scala 292:17]
                          skip @[Conditional.scala 39:67]
                        else : @[Conditional.scala 39:67]
                          node _T_17 = eq(UInt<4>("h0b"), state) @[Conditional.scala 37:30]
                          when _T_17 : @[Conditional.scala 39:67]
                            io.ena <= UInt<1>("h01") @[ControlUnit.scala 297:19]
                            io.wr <= UInt<1>("h01") @[ControlUnit.scala 298:19]
                            io.addr.sel <= UInt<2>("h01") @[ControlUnit.scala 299:19]
                            node _io_addr_pos_T_10 = add(n, UInt<6>("h020")) @[ControlUnit.scala 300:24]
                            node _io_addr_pos_T_11 = tail(_io_addr_pos_T_10, 1) @[ControlUnit.scala 300:24]
                            io.addr.pos <= _io_addr_pos_T_11 @[ControlUnit.scala 300:19]
                            localCntrSels[0].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[1].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[2].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[3].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[4].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[5].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[6].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            localCntrSels[7].writeDataSel <= UInt<1>("h01") @[ControlUnit.scala 303:39]
                            a <= UInt<1>("h00") @[ControlUnit.scala 305:9]
                            node _nNext_T = add(n, UInt<1>("h01")) @[ControlUnit.scala 306:21]
                            node nNext = tail(_nNext_T, 1) @[ControlUnit.scala 306:21]
                            n <= nNext @[ControlUnit.scala 307:9]
                            node _T_18 = shl(nNext, 3) @[ControlUnit.scala 308:19]
                            node _T_19 = geq(_T_18, nrNeuMapped) @[ControlUnit.scala 308:41]
                            when _T_19 : @[ControlUnit.scala 308:58]
                              state <= UInt<4>("h00") @[ControlUnit.scala 309:15]
                              skip @[ControlUnit.scala 308:58]
                            else : @[ControlUnit.scala 310:19]
                              state <= UInt<4>("h01") @[ControlUnit.scala 311:15]
                              skip @[ControlUnit.scala 310:19]
                            skip @[Conditional.scala 39:67]
    
  module NeuronEvaluator_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module NeuronEvaluator_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip dataIn : SInt<17>, dataOut : SInt<17>, spikeIndi : UInt<1>, refracIndi : UInt<1>, flip cntrSels : {potSel : UInt<2>, spikeSel : UInt<2>, refracSel : UInt<1>, decaySel : UInt<1>, writeDataSel : UInt<2>}, flip evalEnable : UInt<1>}
    
    wire sum : SInt<18> @[NeuronEvaluator.scala 19:30]
    wire sumSat : SInt<17> @[NeuronEvaluator.scala 20:30]
    wire sumIn1 : SInt<18> @[NeuronEvaluator.scala 21:30]
    wire sumIn2 : SInt<18> @[NeuronEvaluator.scala 22:30]
    wire potDecay : SInt<17> @[NeuronEvaluator.scala 23:30]
    wire refracRegNext : SInt<17> @[NeuronEvaluator.scala 24:30]
    wire membPotRegNext : SInt<17> @[NeuronEvaluator.scala 25:30]
    wire spikeIndiRegNext : UInt<1> @[NeuronEvaluator.scala 26:30]
    reg membPotReg : SInt<17>, clock with : (reset => (reset, asSInt(UInt<17>("h00")))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      membPotReg <= membPotRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    reg refracCntReg : SInt<17>, clock @[Reg.scala 15:16]
    when io.evalEnable : @[Reg.scala 16:19]
      refracCntReg <= refracRegNext @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg spikeIndiReg : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Reg.scala 27:20]
    when io.evalEnable : @[Reg.scala 28:19]
      spikeIndiReg <= spikeIndiRegNext @[Reg.scala 28:23]
      skip @[Reg.scala 28:19]
    io.dataOut <= io.dataIn @[NeuronEvaluator.scala 33:14]
    sumIn1 <= membPotReg @[NeuronEvaluator.scala 34:14]
    node _sumIn2_T = sub(asSInt(UInt<1>("h00")), potDecay) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_1 = tail(_sumIn2_T, 1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_2 = asSInt(_sumIn2_T_1) @[NeuronEvaluator.scala 35:43]
    node _sumIn2_T_3 = mux(io.cntrSels.decaySel, _sumIn2_T_2, io.dataIn) @[NeuronEvaluator.scala 35:20]
    sumIn2 <= _sumIn2_T_3 @[NeuronEvaluator.scala 35:14]
    node _sum_T = add(sumIn1, sumIn2) @[NeuronEvaluator.scala 36:24]
    node _sum_T_1 = tail(_sum_T, 1) @[NeuronEvaluator.scala 36:24]
    node _sum_T_2 = asSInt(_sum_T_1) @[NeuronEvaluator.scala 36:24]
    sum <= _sum_T_2 @[NeuronEvaluator.scala 36:14]
    membPotRegNext <= membPotReg @[NeuronEvaluator.scala 38:20]
    spikeIndiRegNext <= spikeIndiReg @[NeuronEvaluator.scala 39:20]
    node _T = lt(sum, asSInt(UInt<17>("h010000"))) @[NeuronEvaluator.scala 42:12]
    when _T : @[NeuronEvaluator.scala 42:47]
      sumSat <= asSInt(UInt<17>("h010000")) @[NeuronEvaluator.scala 43:12]
      skip @[NeuronEvaluator.scala 42:47]
    else : @[NeuronEvaluator.scala 44:53]
      node _T_1 = gt(sum, asSInt(UInt<17>("h0ffff"))) @[NeuronEvaluator.scala 44:18]
      when _T_1 : @[NeuronEvaluator.scala 44:53]
        sumSat <= asSInt(UInt<17>("h0ffff")) @[NeuronEvaluator.scala 45:12]
        skip @[NeuronEvaluator.scala 44:53]
      else : @[NeuronEvaluator.scala 46:15]
        sumSat <= sum @[NeuronEvaluator.scala 47:12]
        skip @[NeuronEvaluator.scala 46:15]
    node _T_2 = eq(UInt<1>("h00"), io.cntrSels.potSel) @[Conditional.scala 37:30]
    when _T_2 : @[Conditional.scala 40:58]
      membPotRegNext <= io.dataIn @[NeuronEvaluator.scala 53:22]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_3 = eq(UInt<1>("h01"), io.cntrSels.potSel) @[Conditional.scala 37:30]
      when _T_3 : @[Conditional.scala 39:67]
        membPotRegNext <= sumSat @[NeuronEvaluator.scala 56:22]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_4 = eq(UInt<2>("h02"), io.cntrSels.potSel) @[Conditional.scala 37:30]
        when _T_4 : @[Conditional.scala 39:67]
          membPotRegNext <= membPotReg @[NeuronEvaluator.scala 59:22]
          skip @[Conditional.scala 39:67]
    node _potDecay_T = bits(io.dataIn, 2, 0) @[NeuronEvaluator.scala 73:38]
    node _potDecay_T_1 = dshr(membPotReg, _potDecay_T) @[NeuronEvaluator.scala 73:26]
    potDecay <= _potDecay_T_1 @[NeuronEvaluator.scala 73:12]
    node _refracRegNext_T = eq(io.cntrSels.refracSel, UInt<1>("h00")) @[NeuronEvaluator.scala 76:46]
    node _refracRegNext_T_1 = mux(_refracRegNext_T, io.dataIn, refracCntReg) @[NeuronEvaluator.scala 76:23]
    refracRegNext <= _refracRegNext_T_1 @[NeuronEvaluator.scala 76:17]
    node _T_5 = eq(UInt<1>("h00"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
    when _T_5 : @[Conditional.scala 40:58]
      node _spikeIndiRegNext_T = gt(membPotReg, io.dataIn) @[NeuronEvaluator.scala 81:38]
      spikeIndiRegNext <= _spikeIndiRegNext_T @[NeuronEvaluator.scala 81:24]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_6 = eq(UInt<1>("h01"), io.cntrSels.spikeSel) @[Conditional.scala 37:30]
      when _T_6 : @[Conditional.scala 39:67]
        spikeIndiRegNext <= UInt<1>("h00") @[NeuronEvaluator.scala 84:24]
        skip @[Conditional.scala 39:67]
    node _T_7 = eq(UInt<1>("h00"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
    when _T_7 : @[Conditional.scala 40:58]
      io.dataOut <= io.dataIn @[NeuronEvaluator.scala 91:18]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_8 = eq(UInt<1>("h01"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
      when _T_8 : @[Conditional.scala 39:67]
        node _T_9 = not(spikeIndiReg) @[NeuronEvaluator.scala 94:12]
        when _T_9 : @[NeuronEvaluator.scala 94:27]
          io.dataOut <= membPotReg @[NeuronEvaluator.scala 95:20]
          skip @[NeuronEvaluator.scala 94:27]
        else : @[NeuronEvaluator.scala 96:19]
          io.dataOut <= io.dataIn @[NeuronEvaluator.scala 97:20]
          skip @[NeuronEvaluator.scala 96:19]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_10 = eq(UInt<2>("h02"), io.cntrSels.writeDataSel) @[Conditional.scala 37:30]
        when _T_10 : @[Conditional.scala 39:67]
          when io.refracIndi : @[NeuronEvaluator.scala 101:27]
            when spikeIndiReg : @[NeuronEvaluator.scala 102:28]
              io.dataOut <= io.dataIn @[NeuronEvaluator.scala 103:22]
              skip @[NeuronEvaluator.scala 102:28]
            else : @[NeuronEvaluator.scala 104:21]
              io.dataOut <= refracCntReg @[NeuronEvaluator.scala 105:22]
              skip @[NeuronEvaluator.scala 104:21]
            skip @[NeuronEvaluator.scala 101:27]
          else : @[NeuronEvaluator.scala 107:19]
            node _io_dataOut_T = sub(refracCntReg, asSInt(UInt<2>("h01"))) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_1 = tail(_io_dataOut_T, 1) @[NeuronEvaluator.scala 108:36]
            node _io_dataOut_T_2 = asSInt(_io_dataOut_T_1) @[NeuronEvaluator.scala 108:36]
            io.dataOut <= _io_dataOut_T_2 @[NeuronEvaluator.scala 108:20]
            skip @[NeuronEvaluator.scala 107:19]
          skip @[Conditional.scala 39:67]
    node _io_refracIndi_T = eq(refracRegNext, asSInt(UInt<1>("h00"))) @[NeuronEvaluator.scala 113:34]
    io.refracIndi <= _io_refracIndi_T @[NeuronEvaluator.scala 113:17]
    io.spikeIndi <= spikeIndiReg @[NeuronEvaluator.scala 114:17]
    
  module EvaluationMemory_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<1>("h00")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<1>("h01")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<2>("h02")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<2>("h03")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<3>("h04")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<3>("h05")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<3>("h06")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module EvaluationMemory_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip addr : {sel : UInt<2>, pos : UInt<15>}, flip ena : UInt<1>, flip wr : UInt<1>, readData : SInt<17>, flip writeData : SInt<17>, nothing : UInt<6>}
    
    smem constmem : UInt<5>[4], undefined @[EvaluationMemory.scala 24:29]
    smem dynamem : SInt<17>[64], undefined @[EvaluationMemory.scala 25:29]
    smem btmem : SInt<17>[64], undefined @[EvaluationMemory.scala 26:29]
    smem wghtmem : UInt<11>[24576], undefined @[EvaluationMemory.scala 27:29]
    node _io_nothing_T = cat(UInt<2>("h03"), UInt<3>("h07")) @[EvaluationMemory.scala 48:26]
    io.nothing <= _io_nothing_T @[EvaluationMemory.scala 48:14]
    reg selPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      selPipe <= io.addr.sel @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _addrPipe_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 52:40]
    reg addrPipe : UInt<2>, clock @[Reg.scala 15:16]
    when io.ena : @[Reg.scala 16:19]
      addrPipe <= _addrPipe_T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    wire constRead : UInt<5>
    constRead is invalid
    wire dynaRead : SInt<17>
    dynaRead is invalid
    wire btRead : SInt<17>
    btRead is invalid
    wire wghtRead : UInt<11>
    wghtRead is invalid
    wire memRead : SInt<17>
    memRead is invalid
    when io.ena : @[EvaluationMemory.scala 58:16]
      node _T = eq(UInt<2>("h00"), io.addr.sel) @[Conditional.scala 37:30]
      when _T : @[Conditional.scala 40:58]
        node _constRead_T = bits(io.addr.pos, 1, 0) @[EvaluationMemory.scala 61:30]
        infer mport constRead_MPORT = constmem[_constRead_T], clock @[EvaluationMemory.scala 61:30]
        constRead <= constRead_MPORT @[EvaluationMemory.scala 61:19]
        skip @[Conditional.scala 40:58]
      else : @[Conditional.scala 39:67]
        node _T_1 = eq(UInt<2>("h01"), io.addr.sel) @[Conditional.scala 37:30]
        when _T_1 : @[Conditional.scala 39:67]
          when io.wr : @[EvaluationMemory.scala 64:21]
            node _T_2 = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 65:18]
            infer mport MPORT = dynamem[_T_2], clock @[EvaluationMemory.scala 65:18]
            MPORT <= io.writeData @[EvaluationMemory.scala 65:32]
            skip @[EvaluationMemory.scala 64:21]
          else : @[EvaluationMemory.scala 66:21]
            node _dynaRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 67:30]
            infer mport dynaRead_MPORT = dynamem[_dynaRead_T], clock @[EvaluationMemory.scala 67:30]
            dynaRead <= dynaRead_MPORT @[EvaluationMemory.scala 67:20]
            skip @[EvaluationMemory.scala 66:21]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_3 = eq(UInt<2>("h02"), io.addr.sel) @[Conditional.scala 37:30]
          when _T_3 : @[Conditional.scala 39:67]
            node _btRead_T = bits(io.addr.pos, 5, 0) @[EvaluationMemory.scala 71:24]
            infer mport btRead_MPORT = btmem[_btRead_T], clock @[EvaluationMemory.scala 71:24]
            btRead <= btRead_MPORT @[EvaluationMemory.scala 71:16]
            skip @[Conditional.scala 39:67]
          else : @[Conditional.scala 39:67]
            node _T_4 = eq(UInt<2>("h03"), io.addr.sel) @[Conditional.scala 37:30]
            when _T_4 : @[Conditional.scala 39:67]
              when io.wr : @[EvaluationMemory.scala 75:21]
                infer mport MPORT_1 = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 76:18]
                node _T_5 = bits(io.writeData, 10, 0) @[EvaluationMemory.scala 76:47]
                MPORT_1 <= _T_5 @[EvaluationMemory.scala 76:32]
                skip @[EvaluationMemory.scala 75:21]
              else : @[EvaluationMemory.scala 77:21]
                infer mport wghtRead_MPORT = wghtmem[io.addr.pos], clock @[EvaluationMemory.scala 78:30]
                wghtRead <= wghtRead_MPORT @[EvaluationMemory.scala 78:20]
                skip @[EvaluationMemory.scala 77:21]
              skip @[Conditional.scala 39:67]
      skip @[EvaluationMemory.scala 58:16]
    node _T_6 = eq(UInt<2>("h00"), selPipe) @[Conditional.scala 37:30]
    when _T_6 : @[Conditional.scala 40:58]
      node _res_T = cat(constRead, UInt<10>("h00")) @[EvaluationMemory.scala 85:28]
      node _res_T_1 = asSInt(_res_T) @[EvaluationMemory.scala 85:42]
      node res = pad(_res_T_1, 17) @[EvaluationMemory.scala 85:52]
      node _oth_T = pad(constRead, 17) @[EvaluationMemory.scala 86:30]
      node oth = asSInt(_oth_T) @[EvaluationMemory.scala 86:45]
      node _memRead_T = orr(addrPipe) @[EvaluationMemory.scala 87:32]
      node _memRead_T_1 = eq(_memRead_T, UInt<1>("h00")) @[EvaluationMemory.scala 87:22]
      node _memRead_T_2 = mux(_memRead_T_1, res, oth) @[EvaluationMemory.scala 87:21]
      memRead <= _memRead_T_2 @[EvaluationMemory.scala 87:15]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_7 = eq(UInt<2>("h01"), selPipe) @[Conditional.scala 37:30]
      when _T_7 : @[Conditional.scala 39:67]
        memRead <= dynaRead @[EvaluationMemory.scala 90:15]
        skip @[Conditional.scala 39:67]
      else : @[Conditional.scala 39:67]
        node _T_8 = eq(UInt<2>("h02"), selPipe) @[Conditional.scala 37:30]
        when _T_8 : @[Conditional.scala 39:67]
          memRead <= btRead @[EvaluationMemory.scala 93:15]
          skip @[Conditional.scala 39:67]
        else : @[Conditional.scala 39:67]
          node _T_9 = eq(UInt<2>("h03"), selPipe) @[Conditional.scala 37:30]
          when _T_9 : @[Conditional.scala 39:67]
            node _res_T_2 = bits(wghtRead, 9, 0) @[EvaluationMemory.scala 97:26]
            node _res_T_3 = cat(_res_T_2, UInt<6>("h00")) @[EvaluationMemory.scala 97:51]
            node _res_T_4 = asSInt(_res_T_3) @[EvaluationMemory.scala 97:64]
            node res_1 = pad(_res_T_4, 17) @[EvaluationMemory.scala 97:74]
            node _oth_T_1 = pad(wghtRead, 17) @[EvaluationMemory.scala 98:29]
            node oth_1 = asSInt(_oth_T_1) @[EvaluationMemory.scala 98:44]
            node _memRead_T_3 = bits(wghtRead, 10, 10) @[EvaluationMemory.scala 99:30]
            node _memRead_T_4 = mux(_memRead_T_3, res_1, oth_1) @[EvaluationMemory.scala 99:21]
            memRead <= _memRead_T_4 @[EvaluationMemory.scala 99:15]
            skip @[Conditional.scala 39:67]
    io.readData <= memRead @[EvaluationMemory.scala 102:15]
    
  module Neurons_1 : 
    input clock : Clock
    input reset : Reset
    output io : {done : UInt<1>, flip newTS : UInt<1>, inOut : UInt<1>, flip spikeCnt : UInt<10>, aAddr : UInt<10>, aEna : UInt<1>, flip aData : UInt<10>, n : UInt<5>, spikes : UInt<1>[8]}
    
    inst controlUnit of ControlUnit_1 @[Neurons.scala 22:27]
    controlUnit.clock <= clock
    controlUnit.reset <= reset
    inst evalUnits_0 of NeuronEvaluator_8 @[Neurons.scala 23:56]
    evalUnits_0.clock <= clock
    evalUnits_0.reset <= reset
    inst evalUnits_1 of NeuronEvaluator_9 @[Neurons.scala 23:56]
    evalUnits_1.clock <= clock
    evalUnits_1.reset <= reset
    inst evalUnits_2 of NeuronEvaluator_10 @[Neurons.scala 23:56]
    evalUnits_2.clock <= clock
    evalUnits_2.reset <= reset
    inst evalUnits_3 of NeuronEvaluator_11 @[Neurons.scala 23:56]
    evalUnits_3.clock <= clock
    evalUnits_3.reset <= reset
    inst evalUnits_4 of NeuronEvaluator_12 @[Neurons.scala 23:56]
    evalUnits_4.clock <= clock
    evalUnits_4.reset <= reset
    inst evalUnits_5 of NeuronEvaluator_13 @[Neurons.scala 23:56]
    evalUnits_5.clock <= clock
    evalUnits_5.reset <= reset
    inst evalUnits_6 of NeuronEvaluator_14 @[Neurons.scala 23:56]
    evalUnits_6.clock <= clock
    evalUnits_6.reset <= reset
    inst evalUnits_7 of NeuronEvaluator_15 @[Neurons.scala 23:56]
    evalUnits_7.clock <= clock
    evalUnits_7.reset <= reset
    inst evalMems_0 of EvaluationMemory_8 @[Neurons.scala 24:56]
    evalMems_0.clock <= clock
    evalMems_0.reset <= reset
    inst evalMems_1 of EvaluationMemory_9 @[Neurons.scala 24:56]
    evalMems_1.clock <= clock
    evalMems_1.reset <= reset
    inst evalMems_2 of EvaluationMemory_10 @[Neurons.scala 24:56]
    evalMems_2.clock <= clock
    evalMems_2.reset <= reset
    inst evalMems_3 of EvaluationMemory_11 @[Neurons.scala 24:56]
    evalMems_3.clock <= clock
    evalMems_3.reset <= reset
    inst evalMems_4 of EvaluationMemory_12 @[Neurons.scala 24:56]
    evalMems_4.clock <= clock
    evalMems_4.reset <= reset
    inst evalMems_5 of EvaluationMemory_13 @[Neurons.scala 24:56]
    evalMems_5.clock <= clock
    evalMems_5.reset <= reset
    inst evalMems_6 of EvaluationMemory_14 @[Neurons.scala 24:56]
    evalMems_6.clock <= clock
    evalMems_6.reset <= reset
    inst evalMems_7 of EvaluationMemory_15 @[Neurons.scala 24:56]
    evalMems_7.clock <= clock
    evalMems_7.reset <= reset
    io.inOut <= controlUnit.io.inOut @[Neurons.scala 26:27]
    controlUnit.io.spikeCnt <= io.spikeCnt @[Neurons.scala 27:27]
    io.aAddr <= controlUnit.io.aAddr @[Neurons.scala 28:27]
    io.aEna <= controlUnit.io.aEna @[Neurons.scala 29:27]
    controlUnit.io.aData <= io.aData @[Neurons.scala 30:27]
    io.n <= controlUnit.io.n @[Neurons.scala 31:27]
    io.done <= controlUnit.io.done @[Neurons.scala 33:11]
    controlUnit.io.newTS <= io.newTS @[Neurons.scala 34:24]
    io.spikes[0] <= controlUnit.io.spikes[0] @[Neurons.scala 37:18]
    evalUnits_0.io.dataIn <= evalMems_0.io.readData @[Neurons.scala 39:43]
    evalMems_0.io.writeData <= evalUnits_0.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[0] <= evalUnits_0.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[0] <= evalUnits_0.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_0.io.cntrSels.potSel <= controlUnit.io.cntrSels[0].potSel @[Neurons.scala 43:43]
    evalUnits_0.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[0].spikeSel @[Neurons.scala 44:43]
    evalUnits_0.io.cntrSels.refracSel <= controlUnit.io.cntrSels[0].refracSel @[Neurons.scala 45:43]
    evalUnits_0.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[0].writeDataSel @[Neurons.scala 46:43]
    evalUnits_0.io.cntrSels.decaySel <= controlUnit.io.cntrSels[0].decaySel @[Neurons.scala 47:43]
    evalUnits_0.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_0.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_0.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_0.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_0.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[1] <= controlUnit.io.spikes[1] @[Neurons.scala 37:18]
    evalUnits_1.io.dataIn <= evalMems_1.io.readData @[Neurons.scala 39:43]
    evalMems_1.io.writeData <= evalUnits_1.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[1] <= evalUnits_1.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[1] <= evalUnits_1.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_1.io.cntrSels.potSel <= controlUnit.io.cntrSels[1].potSel @[Neurons.scala 43:43]
    evalUnits_1.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[1].spikeSel @[Neurons.scala 44:43]
    evalUnits_1.io.cntrSels.refracSel <= controlUnit.io.cntrSels[1].refracSel @[Neurons.scala 45:43]
    evalUnits_1.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[1].writeDataSel @[Neurons.scala 46:43]
    evalUnits_1.io.cntrSels.decaySel <= controlUnit.io.cntrSels[1].decaySel @[Neurons.scala 47:43]
    evalUnits_1.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_1.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_1.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_1.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_1.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[2] <= controlUnit.io.spikes[2] @[Neurons.scala 37:18]
    evalUnits_2.io.dataIn <= evalMems_2.io.readData @[Neurons.scala 39:43]
    evalMems_2.io.writeData <= evalUnits_2.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[2] <= evalUnits_2.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[2] <= evalUnits_2.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_2.io.cntrSels.potSel <= controlUnit.io.cntrSels[2].potSel @[Neurons.scala 43:43]
    evalUnits_2.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[2].spikeSel @[Neurons.scala 44:43]
    evalUnits_2.io.cntrSels.refracSel <= controlUnit.io.cntrSels[2].refracSel @[Neurons.scala 45:43]
    evalUnits_2.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[2].writeDataSel @[Neurons.scala 46:43]
    evalUnits_2.io.cntrSels.decaySel <= controlUnit.io.cntrSels[2].decaySel @[Neurons.scala 47:43]
    evalUnits_2.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_2.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_2.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_2.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_2.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[3] <= controlUnit.io.spikes[3] @[Neurons.scala 37:18]
    evalUnits_3.io.dataIn <= evalMems_3.io.readData @[Neurons.scala 39:43]
    evalMems_3.io.writeData <= evalUnits_3.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[3] <= evalUnits_3.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[3] <= evalUnits_3.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_3.io.cntrSels.potSel <= controlUnit.io.cntrSels[3].potSel @[Neurons.scala 43:43]
    evalUnits_3.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[3].spikeSel @[Neurons.scala 44:43]
    evalUnits_3.io.cntrSels.refracSel <= controlUnit.io.cntrSels[3].refracSel @[Neurons.scala 45:43]
    evalUnits_3.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[3].writeDataSel @[Neurons.scala 46:43]
    evalUnits_3.io.cntrSels.decaySel <= controlUnit.io.cntrSels[3].decaySel @[Neurons.scala 47:43]
    evalUnits_3.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_3.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_3.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_3.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_3.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[4] <= controlUnit.io.spikes[4] @[Neurons.scala 37:18]
    evalUnits_4.io.dataIn <= evalMems_4.io.readData @[Neurons.scala 39:43]
    evalMems_4.io.writeData <= evalUnits_4.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[4] <= evalUnits_4.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[4] <= evalUnits_4.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_4.io.cntrSels.potSel <= controlUnit.io.cntrSels[4].potSel @[Neurons.scala 43:43]
    evalUnits_4.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[4].spikeSel @[Neurons.scala 44:43]
    evalUnits_4.io.cntrSels.refracSel <= controlUnit.io.cntrSels[4].refracSel @[Neurons.scala 45:43]
    evalUnits_4.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[4].writeDataSel @[Neurons.scala 46:43]
    evalUnits_4.io.cntrSels.decaySel <= controlUnit.io.cntrSels[4].decaySel @[Neurons.scala 47:43]
    evalUnits_4.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_4.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_4.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_4.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_4.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[5] <= controlUnit.io.spikes[5] @[Neurons.scala 37:18]
    evalUnits_5.io.dataIn <= evalMems_5.io.readData @[Neurons.scala 39:43]
    evalMems_5.io.writeData <= evalUnits_5.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[5] <= evalUnits_5.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[5] <= evalUnits_5.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_5.io.cntrSels.potSel <= controlUnit.io.cntrSels[5].potSel @[Neurons.scala 43:43]
    evalUnits_5.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[5].spikeSel @[Neurons.scala 44:43]
    evalUnits_5.io.cntrSels.refracSel <= controlUnit.io.cntrSels[5].refracSel @[Neurons.scala 45:43]
    evalUnits_5.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[5].writeDataSel @[Neurons.scala 46:43]
    evalUnits_5.io.cntrSels.decaySel <= controlUnit.io.cntrSels[5].decaySel @[Neurons.scala 47:43]
    evalUnits_5.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_5.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_5.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_5.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_5.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[6] <= controlUnit.io.spikes[6] @[Neurons.scala 37:18]
    evalUnits_6.io.dataIn <= evalMems_6.io.readData @[Neurons.scala 39:43]
    evalMems_6.io.writeData <= evalUnits_6.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[6] <= evalUnits_6.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[6] <= evalUnits_6.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_6.io.cntrSels.potSel <= controlUnit.io.cntrSels[6].potSel @[Neurons.scala 43:43]
    evalUnits_6.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[6].spikeSel @[Neurons.scala 44:43]
    evalUnits_6.io.cntrSels.refracSel <= controlUnit.io.cntrSels[6].refracSel @[Neurons.scala 45:43]
    evalUnits_6.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[6].writeDataSel @[Neurons.scala 46:43]
    evalUnits_6.io.cntrSels.decaySel <= controlUnit.io.cntrSels[6].decaySel @[Neurons.scala 47:43]
    evalUnits_6.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_6.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_6.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_6.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_6.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    io.spikes[7] <= controlUnit.io.spikes[7] @[Neurons.scala 37:18]
    evalUnits_7.io.dataIn <= evalMems_7.io.readData @[Neurons.scala 39:43]
    evalMems_7.io.writeData <= evalUnits_7.io.dataOut @[Neurons.scala 40:43]
    controlUnit.io.spikeIndi[7] <= evalUnits_7.io.spikeIndi @[Neurons.scala 41:43]
    controlUnit.io.refracIndi[7] <= evalUnits_7.io.refracIndi @[Neurons.scala 42:43]
    evalUnits_7.io.cntrSels.potSel <= controlUnit.io.cntrSels[7].potSel @[Neurons.scala 43:43]
    evalUnits_7.io.cntrSels.spikeSel <= controlUnit.io.cntrSels[7].spikeSel @[Neurons.scala 44:43]
    evalUnits_7.io.cntrSels.refracSel <= controlUnit.io.cntrSels[7].refracSel @[Neurons.scala 45:43]
    evalUnits_7.io.cntrSels.writeDataSel <= controlUnit.io.cntrSels[7].writeDataSel @[Neurons.scala 46:43]
    evalUnits_7.io.cntrSels.decaySel <= controlUnit.io.cntrSels[7].decaySel @[Neurons.scala 47:43]
    evalUnits_7.io.evalEnable <= controlUnit.io.evalEnable @[Neurons.scala 48:43]
    evalMems_7.io.addr.pos <= controlUnit.io.addr.pos @[Neurons.scala 50:43]
    evalMems_7.io.addr.sel <= controlUnit.io.addr.sel @[Neurons.scala 50:43]
    evalMems_7.io.wr <= controlUnit.io.wr @[Neurons.scala 51:43]
    evalMems_7.io.ena <= controlUnit.io.ena @[Neurons.scala 52:43]
    
  module NeuronCore_1 : 
    input clock : Clock
    input reset : Reset
    output io : {pmClkEn : UInt<1>, flip newTS : UInt<1>, flip grant : UInt<1>, req : UInt<1>, tx : UInt<11>, flip rx : UInt<11>}
    
    inst interface of BusInterface_3 @[NeuronCore.scala 19:26]
    interface.clock <= clock
    interface.reset <= reset
    inst axonSystem of AxonSystem_1 @[NeuronCore.scala 20:26]
    axonSystem.clock <= clock
    axonSystem.reset <= reset
    inst spikeTrans of TransmissionSystem_3 @[NeuronCore.scala 21:26]
    spikeTrans.clock <= clock
    spikeTrans.reset <= reset
    inst neurons of Neurons_1 @[NeuronCore.scala 22:26]
    neurons.clock <= clock
    neurons.reset <= reset
    interface.io.grant <= io.grant @[NeuronCore.scala 24:27]
    io.req <= interface.io.reqOut @[NeuronCore.scala 25:27]
    io.tx <= interface.io.tx @[NeuronCore.scala 26:27]
    interface.io.rx <= io.rx @[NeuronCore.scala 27:27]
    axonSystem.io.axonIn <= interface.io.axonID @[NeuronCore.scala 28:27]
    axonSystem.io.axonValid <= interface.io.valid @[NeuronCore.scala 29:27]
    interface.io.spikeID <= spikeTrans.io.data @[NeuronCore.scala 30:27]
    spikeTrans.io.ready <= interface.io.ready @[NeuronCore.scala 31:27]
    interface.io.reqIn <= spikeTrans.io.valid @[NeuronCore.scala 32:27]
    axonSystem.io.inOut <= neurons.io.inOut @[NeuronCore.scala 34:27]
    neurons.io.spikeCnt <= axonSystem.io.spikeCnt @[NeuronCore.scala 35:27]
    axonSystem.io.rAddr <= neurons.io.aAddr @[NeuronCore.scala 36:27]
    axonSystem.io.rEna <= neurons.io.aEna @[NeuronCore.scala 37:27]
    neurons.io.aData <= axonSystem.io.rData @[NeuronCore.scala 38:27]
    spikeTrans.io.n <= neurons.io.n @[NeuronCore.scala 40:27]
    spikeTrans.io.spikes[0] <= neurons.io.spikes[0] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[1] <= neurons.io.spikes[1] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[2] <= neurons.io.spikes[2] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[3] <= neurons.io.spikes[3] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[4] <= neurons.io.spikes[4] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[5] <= neurons.io.spikes[5] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[6] <= neurons.io.spikes[6] @[NeuronCore.scala 41:27]
    spikeTrans.io.spikes[7] <= neurons.io.spikes[7] @[NeuronCore.scala 41:27]
    node _io_pmClkEn_T = eq(neurons.io.done, UInt<1>("h00")) @[NeuronCore.scala 43:17]
    node _io_pmClkEn_T_1 = or(_io_pmClkEn_T, interface.io.reqOut) @[NeuronCore.scala 43:34]
    io.pmClkEn <= _io_pmClkEn_T_1 @[NeuronCore.scala 43:14]
    neurons.io.newTS <= io.newTS @[NeuronCore.scala 44:20]
    
  module BusInterface_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip grant : UInt<1>, reqOut : UInt<1>, tx : UInt<11>, flip rx : UInt<11>, axonID : UInt<10>, valid : UInt<1>, flip spikeID : UInt<11>, ready : UInt<1>, flip reqIn : UInt<1>}
    
    wire filterROM : UInt<3>[5] @[BusInterface.scala 28:27]
    filterROM[0] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[1] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[2] <= UInt<3>("h04") @[BusInterface.scala 28:27]
    filterROM[3] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    filterROM[4] <= UInt<3>("h00") @[BusInterface.scala 28:27]
    node _io_tx_T = mux(io.grant, io.spikeID, UInt<1>("h00")) @[BusInterface.scala 31:15]
    io.tx <= _io_tx_T @[BusInterface.scala 31:9]
    node _io_reqOut_T = not(io.grant) @[BusInterface.scala 32:28]
    node _io_reqOut_T_1 = and(io.reqIn, _io_reqOut_T) @[BusInterface.scala 32:25]
    io.reqOut <= _io_reqOut_T_1 @[BusInterface.scala 32:13]
    io.ready <= io.grant @[BusInterface.scala 33:13]
    reg axonIDLSBReg : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[BusInterface.scala 36:29]
    node _axonIDLSBReg_T = bits(io.rx, 7, 0) @[BusInterface.scala 37:24]
    axonIDLSBReg <= _axonIDLSBReg_T @[BusInterface.scala 37:16]
    reg synROMReg : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[BusInterface.scala 39:27]
    node _synROMReg_T = orr(io.rx) @[BusInterface.scala 40:26]
    node _synROMReg_T_1 = bits(io.rx, 10, 8) @[BusInterface.scala 40:46]
    node _synROMReg_T_2 = mux(_synROMReg_T, filterROM[_synROMReg_T_1], UInt<1>("h00")) @[BusInterface.scala 40:19]
    synROMReg <= _synROMReg_T_2 @[BusInterface.scala 40:13]
    node _io_valid_T = bits(synROMReg, 2, 2) @[BusInterface.scala 42:25]
    io.valid <= _io_valid_T @[BusInterface.scala 42:13]
    node _io_axonID_T = bits(synROMReg, 1, 0) @[BusInterface.scala 43:25]
    node _io_axonID_T_1 = cat(_io_axonID_T, axonIDLSBReg) @[BusInterface.scala 43:47]
    io.axonID <= _io_axonID_T_1 @[BusInterface.scala 43:13]
    
  module OutputCore : 
    input clock : Clock
    input reset : Reset
    output io : {pmClkEn : UInt<1>, qWe : UInt<1>, qDi : UInt<8>, flip qFull : UInt<1>, flip grant : UInt<1>, req : UInt<1>, tx : UInt<11>, flip rx : UInt<11>}
    
    inst interface of BusInterface_4 @[OutputCore.scala 23:25]
    interface.clock <= clock
    interface.reset <= reset
    interface.io.grant <= io.grant @[OutputCore.scala 24:24]
    io.req <= interface.io.reqOut @[OutputCore.scala 25:24]
    io.tx <= interface.io.tx @[OutputCore.scala 26:24]
    interface.io.rx <= io.rx @[OutputCore.scala 27:24]
    interface.io.reqIn <= UInt<1>("h00") @[OutputCore.scala 28:24]
    interface.io.spikeID <= UInt<1>("h00") @[OutputCore.scala 29:24]
    io.qWe <= UInt<1>("h00") @[OutputCore.scala 32:10]
    node _io_qDi_T = bits(interface.io.axonID, 7, 0) @[OutputCore.scala 33:32]
    io.qDi <= _io_qDi_T @[OutputCore.scala 33:10]
    node _T = eq(io.qFull, UInt<1>("h00")) @[OutputCore.scala 34:30]
    node _T_1 = and(interface.io.valid, _T) @[OutputCore.scala 34:27]
    when _T_1 : @[OutputCore.scala 34:41]
      io.qWe <= UInt<1>("h01") @[OutputCore.scala 35:12]
      skip @[OutputCore.scala 34:41]
    node _io_pmClkEn_T = orr(io.rx) @[OutputCore.scala 39:23]
    node _io_pmClkEn_T_1 = or(_io_pmClkEn_T, interface.io.valid) @[OutputCore.scala 39:27]
    io.pmClkEn <= _io_pmClkEn_T_1 @[OutputCore.scala 39:14]
    
  module NeuromorphicProcessor : 
    input clock : Clock
    input reset : UInt<1>
    output io : {uartTx : UInt<1>, flip uartRx : UInt<1>}
    
    wire clkEn : UInt<1> @[NeuromorphicProcessor.scala 13:20]
    wire newTS : UInt<1> @[NeuromorphicProcessor.scala 14:19]
    reg enCnt : UInt, clock with : (reset => (reset, UInt<6>("h032"))) @[NeuromorphicProcessor.scala 23:23]
    node _T = neq(enCnt, UInt<6>("h032")) @[NeuromorphicProcessor.scala 24:23]
    node _T_1 = and(clkEn, _T) @[NeuromorphicProcessor.scala 24:14]
    when _T_1 : @[NeuromorphicProcessor.scala 24:35]
      enCnt <= UInt<6>("h032") @[NeuromorphicProcessor.scala 25:11]
      skip @[NeuromorphicProcessor.scala 24:35]
    else : @[NeuromorphicProcessor.scala 26:39]
      node _T_2 = eq(clkEn, UInt<1>("h00")) @[NeuromorphicProcessor.scala 26:14]
      node _T_3 = neq(enCnt, UInt<1>("h00")) @[NeuromorphicProcessor.scala 26:30]
      node _T_4 = and(_T_2, _T_3) @[NeuromorphicProcessor.scala 26:21]
      when _T_4 : @[NeuromorphicProcessor.scala 26:39]
        node _enCnt_T = sub(enCnt, UInt<1>("h01")) @[NeuromorphicProcessor.scala 27:20]
        node _enCnt_T_1 = tail(_enCnt_T, 1) @[NeuromorphicProcessor.scala 27:20]
        enCnt <= _enCnt_T_1 @[NeuromorphicProcessor.scala 27:11]
        skip @[NeuromorphicProcessor.scala 26:39]
    node _coreEn_T = neq(enCnt, UInt<1>("h00")) @[NeuromorphicProcessor.scala 29:31]
    node coreEn = or(newTS, _coreEn_T) @[NeuromorphicProcessor.scala 29:22]
    wire topClock : Clock @[NeuromorphicProcessor.scala 31:22]
    inst cBufTop of ClockBufferVerilog @[NeuromorphicProcessor.scala 32:24]
    cBufTop.clock <= clock
    cBufTop.reset <= reset
    cBufTop.io.CE <= UInt<1>("h01") @[NeuromorphicProcessor.scala 33:17]
    cBufTop.io.I <= clock @[NeuromorphicProcessor.scala 34:17]
    topClock <= cBufTop.io.O @[NeuromorphicProcessor.scala 35:12]
    wire coreClock : Clock @[NeuromorphicProcessor.scala 37:23]
    inst cBufCore of ClockBufferVerilog_1 @[NeuromorphicProcessor.scala 38:25]
    cBufCore.clock <= clock
    cBufCore.reset <= reset
    cBufCore.io.CE <= coreEn @[NeuromorphicProcessor.scala 39:18]
    cBufCore.io.I <= clock @[NeuromorphicProcessor.scala 40:18]
    coreClock <= cBufCore.io.O @[NeuromorphicProcessor.scala 41:13]
    inst inC0Mem of TrueDualPortMemory @[NeuromorphicProcessor.scala 44:23]
    inC0Mem.io.clka <= topClock @[NeuromorphicProcessor.scala 45:19]
    inC0Mem.io.clkb <= coreClock @[NeuromorphicProcessor.scala 46:19]
    inC0Mem.io.web <= UInt<1>("h00") @[NeuromorphicProcessor.scala 47:19]
    inC0Mem.io.dib <= UInt<1>("h00") @[NeuromorphicProcessor.scala 48:19]
    inst inC1Mem of TrueDualPortMemory_1 @[NeuromorphicProcessor.scala 50:23]
    inC1Mem.io.clka <= topClock @[NeuromorphicProcessor.scala 51:19]
    inC1Mem.io.clkb <= coreClock @[NeuromorphicProcessor.scala 52:19]
    inC1Mem.io.web <= UInt<1>("h00") @[NeuromorphicProcessor.scala 53:19]
    inC1Mem.io.dib <= UInt<1>("h00") @[NeuromorphicProcessor.scala 54:19]
    inst outMem of TrueDualPortFIFO @[NeuromorphicProcessor.scala 56:22]
    outMem.io.clki <= coreClock @[NeuromorphicProcessor.scala 57:18]
    outMem.io.clko <= topClock @[NeuromorphicProcessor.scala 58:18]
    node _outMem_io_rst_T = bits(reset, 0, 0) @[NeuromorphicProcessor.scala 59:27]
    outMem.io.rst <= _outMem_io_rst_T @[NeuromorphicProcessor.scala 59:18]
    wire inC0HSin : UInt<1> @[NeuromorphicProcessor.scala 62:22]
    wire inC1HSin : UInt<1> @[NeuromorphicProcessor.scala 63:22]
    wire offCCHSin0 : UInt<1> @[NeuromorphicProcessor.scala 64:24]
    wire offCCHSin1 : UInt<1> @[NeuromorphicProcessor.scala 65:24]
    reg tsCycleCnt : UInt, topClock with : (reset => (reset, UInt<17>("h013880"))) @[NeuromorphicProcessor.scala 70:29]
    node _newTS_T = eq(tsCycleCnt, UInt<1>("h00")) @[NeuromorphicProcessor.scala 71:25]
    newTS <= _newTS_T @[NeuromorphicProcessor.scala 71:11]
    node _tsCycleCnt_T = sub(tsCycleCnt, UInt<1>("h01")) @[NeuromorphicProcessor.scala 72:57]
    node _tsCycleCnt_T_1 = tail(_tsCycleCnt_T, 1) @[NeuromorphicProcessor.scala 72:57]
    node _tsCycleCnt_T_2 = mux(newTS, UInt<17>("h013880"), _tsCycleCnt_T_1) @[NeuromorphicProcessor.scala 72:22]
    tsCycleCnt <= _tsCycleCnt_T_2 @[NeuromorphicProcessor.scala 72:16]
    inst offCC of OffChipCom @[NeuromorphicProcessor.scala 75:23]
    offCC.clock <= topClock
    offCC.reset <= reset
    io.uartTx <= offCC.io.tx @[NeuromorphicProcessor.scala 76:15]
    offCC.io.rx <= io.uartRx @[NeuromorphicProcessor.scala 77:17]
    offCC.io.inC0HSin <= inC0HSin @[NeuromorphicProcessor.scala 78:23]
    offCC.io.inC1HSin <= inC1HSin @[NeuromorphicProcessor.scala 79:23]
    offCCHSin0 <= offCC.io.inC0HSout @[NeuromorphicProcessor.scala 80:16]
    offCCHSin1 <= offCC.io.inC1HSout @[NeuromorphicProcessor.scala 81:16]
    inC0Mem.io.dia <= offCC.io.inC0Di @[NeuromorphicProcessor.scala 84:20]
    inC0Mem.io.ena <= offCC.io.inC0We @[NeuromorphicProcessor.scala 85:20]
    inC0Mem.io.wea <= offCC.io.inC0We @[NeuromorphicProcessor.scala 86:20]
    inC0Mem.io.addra <= offCC.io.inC0Addr @[NeuromorphicProcessor.scala 87:22]
    inC1Mem.io.dia <= offCC.io.inC1Di @[NeuromorphicProcessor.scala 89:20]
    inC1Mem.io.ena <= offCC.io.inC1We @[NeuromorphicProcessor.scala 90:20]
    inC1Mem.io.wea <= offCC.io.inC1We @[NeuromorphicProcessor.scala 91:20]
    inC1Mem.io.addra <= offCC.io.inC1Addr @[NeuromorphicProcessor.scala 92:22]
    outMem.io.en <= offCC.io.qEn @[NeuromorphicProcessor.scala 94:22]
    offCC.io.qData <= outMem.io.datao @[NeuromorphicProcessor.scala 95:22]
    offCC.io.qEmpty <= outMem.io.empty @[NeuromorphicProcessor.scala 96:22]
    inst arbiter of BusArbiter @[NeuromorphicProcessor.scala 104:25]
    arbiter.clock <= coreClock
    arbiter.reset <= reset
    wire txVec : UInt<11>[5] @[NeuromorphicProcessor.scala 105:21]
    wire busTx : UInt<11> @[NeuromorphicProcessor.scala 106:21]
    wire enVec : UInt<1>[5] @[NeuromorphicProcessor.scala 107:21]
    inst inCores_0 of InputCore @[NeuromorphicProcessor.scala 110:46]
    inCores_0.clock <= coreClock
    inCores_0.reset <= reset
    inst inCores_1 of InputCore_1 @[NeuromorphicProcessor.scala 110:46]
    inCores_1.clock <= coreClock
    inCores_1.reset <= reset
    inst neuCores_0 of NeuronCore @[NeuromorphicProcessor.scala 111:47]
    neuCores_0.clock <= coreClock
    neuCores_0.reset <= reset
    inst neuCores_1 of NeuronCore_1 @[NeuromorphicProcessor.scala 111:47]
    neuCores_1.clock <= coreClock
    neuCores_1.reset <= reset
    inst outCore of OutputCore @[NeuromorphicProcessor.scala 112:25]
    outCore.clock <= coreClock
    outCore.reset <= reset
    inC0HSin <= inCores_0.io.offCCHSout @[NeuromorphicProcessor.scala 115:14]
    inC0Mem.io.enb <= inCores_0.io.memEn @[NeuromorphicProcessor.scala 116:25]
    inC0Mem.io.addrb <= inCores_0.io.memAddr @[NeuromorphicProcessor.scala 117:25]
    inCores_0.io.memDo <= inC0Mem.io.dob @[NeuromorphicProcessor.scala 118:25]
    inCores_0.io.newTS <= newTS @[NeuromorphicProcessor.scala 119:25]
    inCores_0.io.offCCHSin <= offCCHSin0 @[NeuromorphicProcessor.scala 120:29]
    inC1HSin <= inCores_1.io.offCCHSout @[NeuromorphicProcessor.scala 122:14]
    inC1Mem.io.enb <= inCores_1.io.memEn @[NeuromorphicProcessor.scala 123:25]
    inC1Mem.io.addrb <= inCores_1.io.memAddr @[NeuromorphicProcessor.scala 124:25]
    inCores_1.io.memDo <= inC1Mem.io.dob @[NeuromorphicProcessor.scala 125:25]
    inCores_1.io.newTS <= newTS @[NeuromorphicProcessor.scala 126:25]
    inCores_1.io.offCCHSin <= offCCHSin1 @[NeuromorphicProcessor.scala 127:29]
    neuCores_0.io.newTS <= newTS @[NeuromorphicProcessor.scala 129:26]
    neuCores_1.io.newTS <= newTS @[NeuromorphicProcessor.scala 131:26]
    outMem.io.we <= outCore.io.qWe @[NeuromorphicProcessor.scala 133:22]
    outMem.io.datai <= outCore.io.qDi @[NeuromorphicProcessor.scala 134:22]
    outCore.io.qFull <= outMem.io.full @[NeuromorphicProcessor.scala 135:22]
    inCores_0.io.rx <= busTx @[NeuromorphicProcessor.scala 142:19]
    arbiter.io.reqs[0] <= inCores_0.io.req @[NeuromorphicProcessor.scala 143:33]
    inCores_0.io.grant <= arbiter.io.grants[0] @[NeuromorphicProcessor.scala 144:22]
    txVec[0] <= inCores_0.io.tx @[NeuromorphicProcessor.scala 145:23]
    enVec[0] <= inCores_0.io.pmClkEn @[NeuromorphicProcessor.scala 146:23]
    inCores_1.io.rx <= busTx @[NeuromorphicProcessor.scala 142:19]
    arbiter.io.reqs[1] <= inCores_1.io.req @[NeuromorphicProcessor.scala 143:33]
    inCores_1.io.grant <= arbiter.io.grants[1] @[NeuromorphicProcessor.scala 144:22]
    txVec[1] <= inCores_1.io.tx @[NeuromorphicProcessor.scala 145:23]
    enVec[1] <= inCores_1.io.pmClkEn @[NeuromorphicProcessor.scala 146:23]
    neuCores_0.io.rx <= busTx @[NeuromorphicProcessor.scala 148:19]
    arbiter.io.reqs[2] <= neuCores_0.io.req @[NeuromorphicProcessor.scala 149:33]
    neuCores_0.io.grant <= arbiter.io.grants[2] @[NeuromorphicProcessor.scala 150:22]
    txVec[2] <= neuCores_0.io.tx @[NeuromorphicProcessor.scala 151:23]
    enVec[2] <= neuCores_0.io.pmClkEn @[NeuromorphicProcessor.scala 152:23]
    neuCores_1.io.rx <= busTx @[NeuromorphicProcessor.scala 148:19]
    arbiter.io.reqs[3] <= neuCores_1.io.req @[NeuromorphicProcessor.scala 149:33]
    neuCores_1.io.grant <= arbiter.io.grants[3] @[NeuromorphicProcessor.scala 150:22]
    txVec[3] <= neuCores_1.io.tx @[NeuromorphicProcessor.scala 151:23]
    enVec[3] <= neuCores_1.io.pmClkEn @[NeuromorphicProcessor.scala 152:23]
    outCore.io.rx <= busTx @[NeuromorphicProcessor.scala 154:19]
    arbiter.io.reqs[4] <= outCore.io.req @[NeuromorphicProcessor.scala 155:33]
    outCore.io.grant <= arbiter.io.grants[4] @[NeuromorphicProcessor.scala 156:22]
    txVec[4] <= outCore.io.tx @[NeuromorphicProcessor.scala 157:23]
    enVec[4] <= outCore.io.pmClkEn @[NeuromorphicProcessor.scala 158:23]
    node _busTx_T = or(txVec[0], txVec[1]) @[NeuromorphicProcessor.scala 161:33]
    node _busTx_T_1 = or(txVec[2], txVec[3]) @[NeuromorphicProcessor.scala 161:33]
    wire _busTx_WIRE : UInt<11>[3] @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE[0] <= _busTx_T @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE[1] <= _busTx_T_1 @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE[2] <= txVec[4] @[NeuromorphicProcessor.scala 161:30]
    node _busTx_T_2 = or(_busTx_WIRE[0], _busTx_WIRE[1]) @[NeuromorphicProcessor.scala 161:33]
    wire _busTx_WIRE_1 : UInt<11>[2] @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE_1[0] <= _busTx_T_2 @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE_1[1] <= _busTx_WIRE[2] @[NeuromorphicProcessor.scala 161:30]
    node _busTx_T_3 = or(_busTx_WIRE_1[0], _busTx_WIRE_1[1]) @[NeuromorphicProcessor.scala 161:33]
    wire _busTx_WIRE_2 : UInt<11>[1] @[NeuromorphicProcessor.scala 161:30]
    _busTx_WIRE_2[0] <= _busTx_T_3 @[NeuromorphicProcessor.scala 161:30]
    busTx <= _busTx_WIRE_2[0] @[NeuromorphicProcessor.scala 161:11]
    node _clkEn_T = or(enVec[0], enVec[1]) @[NeuromorphicProcessor.scala 162:33]
    node _clkEn_T_1 = or(enVec[2], enVec[3]) @[NeuromorphicProcessor.scala 162:33]
    wire _clkEn_WIRE : UInt<1>[3] @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE[0] <= _clkEn_T @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE[1] <= _clkEn_T_1 @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE[2] <= enVec[4] @[NeuromorphicProcessor.scala 162:30]
    node _clkEn_T_2 = or(_clkEn_WIRE[0], _clkEn_WIRE[1]) @[NeuromorphicProcessor.scala 162:33]
    wire _clkEn_WIRE_1 : UInt<1>[2] @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE_1[0] <= _clkEn_T_2 @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE_1[1] <= _clkEn_WIRE[2] @[NeuromorphicProcessor.scala 162:30]
    node _clkEn_T_3 = or(_clkEn_WIRE_1[0], _clkEn_WIRE_1[1]) @[NeuromorphicProcessor.scala 162:33]
    wire _clkEn_WIRE_2 : UInt<1>[1] @[NeuromorphicProcessor.scala 162:30]
    _clkEn_WIRE_2[0] <= _clkEn_T_3 @[NeuromorphicProcessor.scala 162:30]
    clkEn <= _clkEn_WIRE_2[0] @[NeuromorphicProcessor.scala 162:11]
    
