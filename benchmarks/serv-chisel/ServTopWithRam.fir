;buildInfoPackage: chisel3, version: 3.5-SNAPSHOT, scalaVersion: 2.12.13, sbtVersion: 1.5.2
circuit ServTopWithRam : 
  module State : 
    input clock : Clock
    input reset : Reset
    output io : {csr : {flip newIrq : UInt<1>, trapTaken : UInt<1>, pendingIrq : UInt<1>}, dbus : {flip ack : UInt<1>, cyc : UInt<1>}, ibus : {flip ack : UInt<1>}, ram : {writeRequest : UInt<1>, readRequest : UInt<1>, flip ready : UInt<1>}, rf : {writeEnable : UInt<1>}, flip decode : {takeBranch : UInt<1>, eOp : UInt<1>, eBreak : UInt<1>, branchOp : UInt<1>, memOp : UInt<1>, shiftOp : UInt<1>, sltOp : UInt<1>, rdOp : UInt<1>}, flip count : {flip enabled : UInt<1>, flip init : UInt<1>, flip count0 : UInt<1>, flip count0To3 : UInt<1>, flip count12To31 : UInt<1>, flip count1 : UInt<1>, flip count2 : UInt<1>, flip count3 : UInt<1>, flip count7 : UInt<1>, flip done : UInt<1>}, bufreg : {hold : UInt<1>}, control : {pcEnable : UInt<1>, jump : UInt<1>, trap : UInt<1>}, alu : {shiftAmountEnable : UInt<1>, flip shiftDone : UInt<1>}, mem : {byteCount : UInt<2>, flip misaligned : UInt<1>}, flip lsb1 : UInt<1>}
    
    reg init : UInt<1>, clock @[State.scala 17:17]
    io.count.init <= init @[State.scala 18:17]
    reg countDone : UInt<1>, clock @[State.scala 21:22]
    io.count.done <= countDone @[State.scala 22:17]
    reg countEnabled : UInt<1>, clock @[State.scala 23:25]
    io.count.enabled <= countEnabled @[State.scala 24:20]
    when io.ram.ready : @[State.scala 25:22]
      countEnabled <= UInt<1>("h01") @[State.scala 25:37]
      skip @[State.scala 25:22]
    when countDone : @[State.scala 26:19]
      countEnabled <= UInt<1>("h00") @[State.scala 26:34]
      skip @[State.scala 26:19]
    reg count : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[State.scala 28:22]
    reg countR : UInt<4>, clock with : (reset => (reset, UInt<4>("h01"))) @[State.scala 29:23]
    node _T = bits(countR, 3, 3) @[State.scala 31:26]
    node _T_1 = add(count, _T) @[State.scala 31:18]
    node _T_2 = tail(_T_1, 1) @[State.scala 31:18]
    count <= _T_2 @[State.scala 31:9]
    when countEnabled : @[State.scala 33:22]
      node _T_3 = bits(countR, 2, 0) @[State.scala 33:40]
      node _T_4 = bits(countR, 3, 3) @[State.scala 33:55]
      node _T_5 = cat(_T_3, _T_4) @[State.scala 33:46]
      countR <= _T_5 @[State.scala 33:31]
      skip @[State.scala 33:22]
    node _T_6 = eq(count, UInt<3>("h07")) @[State.scala 34:23]
    node _T_7 = bits(countR, 2, 2) @[State.scala 34:41]
    node _T_8 = and(_T_6, _T_7) @[State.scala 34:32]
    countDone <= _T_8 @[State.scala 34:13]
    node _T_9 = and(countDone, init) @[State.scala 37:43]
    reg stageTwoRequest : UInt<1>, clock @[State.scala 37:32]
    stageTwoRequest <= _T_9 @[State.scala 37:32]
    node _T_10 = eq(init, UInt<1>("h00")) @[State.scala 40:41]
    node _T_11 = and(countEnabled, _T_10) @[State.scala 40:39]
    io.control.pcEnable <= _T_11 @[State.scala 40:23]
    node _T_12 = bits(count, 2, 1) @[State.scala 42:28]
    io.mem.byteCount <= _T_12 @[State.scala 42:20]
    node _T_13 = eq(count, UInt<1>("h00")) @[State.scala 44:31]
    io.count.count0To3 <= _T_13 @[State.scala 44:22]
    node _T_14 = bits(count, 2, 2) @[State.scala 45:32]
    node _T_15 = bits(count, 1, 0) @[State.scala 45:45]
    node _T_16 = eq(_T_15, UInt<2>("h03")) @[State.scala 45:51]
    node _T_17 = or(_T_14, _T_16) @[State.scala 45:36]
    io.count.count12To31 <= _T_17 @[State.scala 45:24]
    node _T_18 = eq(count, UInt<1>("h00")) @[State.scala 46:29]
    node _T_19 = bits(countR, 0, 0) @[State.scala 46:47]
    node _T_20 = and(_T_18, _T_19) @[State.scala 46:38]
    io.count.count0 <= _T_20 @[State.scala 46:19]
    node _T_21 = eq(count, UInt<1>("h00")) @[State.scala 47:29]
    node _T_22 = bits(countR, 1, 1) @[State.scala 47:47]
    node _T_23 = and(_T_21, _T_22) @[State.scala 47:38]
    io.count.count1 <= _T_23 @[State.scala 47:19]
    node _T_24 = eq(count, UInt<1>("h00")) @[State.scala 48:29]
    node _T_25 = bits(countR, 2, 2) @[State.scala 48:47]
    node _T_26 = and(_T_24, _T_25) @[State.scala 48:38]
    io.count.count2 <= _T_26 @[State.scala 48:19]
    node _T_27 = eq(count, UInt<1>("h00")) @[State.scala 49:29]
    node _T_28 = bits(countR, 3, 3) @[State.scala 49:47]
    node _T_29 = and(_T_27, _T_28) @[State.scala 49:38]
    io.count.count3 <= _T_29 @[State.scala 49:19]
    node _T_30 = eq(count, UInt<1>("h01")) @[State.scala 50:23]
    node _T_31 = bits(countR, 0, 0) @[State.scala 50:41]
    node count4 = and(_T_30, _T_31) @[State.scala 50:32]
    node _T_32 = eq(count, UInt<1>("h01")) @[State.scala 51:29]
    node _T_33 = bits(countR, 3, 3) @[State.scala 51:47]
    node _T_34 = and(_T_32, _T_33) @[State.scala 51:38]
    io.count.count7 <= _T_34 @[State.scala 51:19]
    node _T_35 = or(io.count.count0To3, count4) @[State.scala 53:51]
    node _T_36 = and(_T_35, init) @[State.scala 53:62]
    io.alu.shiftAmountEnable <= _T_36 @[State.scala 53:28]
    node _T_37 = or(io.decode.sltOp, io.decode.memOp) @[State.scala 56:36]
    node _T_38 = or(_T_37, io.decode.branchOp) @[State.scala 56:55]
    node twoStageOp = or(_T_38, io.decode.shiftOp) @[State.scala 56:77]
    reg stageTwoPending : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[State.scala 58:32]
    when countEnabled : @[State.scala 59:22]
      stageTwoPending <= init @[State.scala 59:40]
      skip @[State.scala 59:22]
    node _T_39 = eq(countEnabled, UInt<1>("h00")) @[State.scala 61:18]
    node _T_40 = and(_T_39, stageTwoPending) @[State.scala 61:32]
    node _T_41 = and(_T_40, io.decode.memOp) @[State.scala 61:51]
    node _T_42 = eq(io.mem.misaligned, UInt<1>("h00")) @[State.scala 61:73]
    node _T_43 = and(_T_41, _T_42) @[State.scala 61:70]
    io.dbus.cyc <= _T_43 @[State.scala 61:15]
    node _T_44 = bits(io.lsb1, 0, 0) @[State.scala 63:69]
    node _T_45 = and(io.control.jump, _T_44) @[State.scala 63:52]
    node _T_46 = or(_T_45, io.mem.misaligned) @[State.scala 63:73]
    node trapPending = and(UInt<1>("h01"), _T_46) @[State.scala 63:31]
    node _T_47 = and(stageTwoRequest, trapPending) @[State.scala 67:57]
    node _T_48 = or(io.ibus.ack, _T_47) @[State.scala 67:37]
    io.ram.readRequest <= _T_48 @[State.scala 67:22]
    node _T_49 = and(io.decode.shiftOp, io.alu.shiftDone) @[State.scala 71:24]
    node _T_50 = and(_T_49, stageTwoPending) @[State.scala 71:44]
    node _T_51 = and(io.decode.memOp, io.dbus.ack) @[State.scala 72:22]
    node _T_52 = or(_T_50, _T_51) @[State.scala 71:64]
    node _T_53 = or(io.decode.sltOp, io.decode.branchOp) @[State.scala 73:42]
    node _T_54 = and(stageTwoRequest, _T_53) @[State.scala 73:22]
    node _T_55 = eq(trapPending, UInt<1>("h00")) @[State.scala 73:68]
    node _T_56 = and(_T_54, _T_55) @[State.scala 73:65]
    node _T_57 = or(_T_52, _T_56) @[State.scala 72:38]
    io.ram.writeRequest <= _T_57 @[State.scala 70:23]
    node _T_58 = and(io.decode.rdOp, countEnabled) @[State.scala 75:39]
    node _T_59 = eq(init, UInt<1>("h00")) @[State.scala 75:58]
    node _T_60 = and(_T_58, _T_59) @[State.scala 75:55]
    io.rf.writeEnable <= _T_60 @[State.scala 75:21]
    node _T_61 = eq(countEnabled, UInt<1>("h00")) @[State.scala 78:21]
    node _T_62 = eq(io.decode.shiftOp, UInt<1>("h00")) @[State.scala 78:58]
    node _T_63 = or(stageTwoRequest, _T_62) @[State.scala 78:55]
    node _T_64 = and(_T_61, _T_63) @[State.scala 78:35]
    io.bufreg.hold <= _T_64 @[State.scala 78:18]
    reg controlJump : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[State.scala 81:28]
    when countDone : @[State.scala 82:19]
      node _T_65 = and(init, io.decode.takeBranch) @[State.scala 82:41]
      controlJump <= _T_65 @[State.scala 82:33]
      skip @[State.scala 82:19]
    io.control.jump <= controlJump @[State.scala 83:19]
    reg pendingIrq : UInt<1>, clock @[State.scala 85:23]
    io.csr.pendingIrq <= pendingIrq @[State.scala 86:21]
    node _T_66 = eq(stageTwoPending, UInt<1>("h00")) @[State.scala 89:24]
    node _T_67 = and(io.ram.ready, _T_66) @[State.scala 89:21]
    when _T_67 : @[State.scala 89:42]
      node _T_68 = eq(pendingIrq, UInt<1>("h00")) @[State.scala 90:27]
      node _T_69 = and(twoStageOp, _T_68) @[State.scala 90:24]
      init <= _T_69 @[State.scala 90:10]
      skip @[State.scala 89:42]
    when countDone : @[State.scala 92:19]
      init <= UInt<1>("h00") @[State.scala 92:26]
      skip @[State.scala 92:19]
    reg REG : UInt<1>, clock @[State.scala 95:22]
    reg REG_1 : UInt<1>, clock @[State.scala 96:33]
    node _T_70 = or(io.decode.eOp, pendingIrq) @[State.scala 97:38]
    node _T_71 = or(_T_70, REG_1) @[State.scala 97:51]
    io.control.trap <= _T_71 @[State.scala 97:21]
    node _T_72 = and(io.ibus.ack, io.control.trap) @[State.scala 98:37]
    io.csr.trapTaken <= _T_72 @[State.scala 98:22]
    when io.ibus.ack : @[State.scala 100:23]
      REG <= UInt<1>("h00") @[State.scala 100:33]
      skip @[State.scala 100:23]
    when io.csr.newIrq : @[State.scala 101:25]
      REG <= UInt<1>("h01") @[State.scala 101:35]
      skip @[State.scala 101:25]
    when io.ibus.ack : @[State.scala 103:23]
      pendingIrq <= REG @[State.scala 103:36]
      skip @[State.scala 103:23]
    when stageTwoRequest : @[State.scala 105:27]
      REG_1 <= trapPending @[State.scala 105:48]
      skip @[State.scala 105:27]
    when io.ibus.ack : @[State.scala 106:23]
      REG_1 <= UInt<1>("h00") @[State.scala 106:44]
      skip @[State.scala 106:23]
    
  module Decode : 
    input clock : Clock
    input reset : Reset
    output io : {count : {flip enabled : UInt<1>, flip init : UInt<1>, flip count0 : UInt<1>, flip count0To3 : UInt<1>, flip count12To31 : UInt<1>, flip count1 : UInt<1>, flip count2 : UInt<1>, flip count3 : UInt<1>, flip count7 : UInt<1>, flip done : UInt<1>}, state : {takeBranch : UInt<1>, eOp : UInt<1>, eBreak : UInt<1>, branchOp : UInt<1>, memOp : UInt<1>, shiftOp : UInt<1>, sltOp : UInt<1>, rdOp : UInt<1>}, bufreg : {loop : UInt<1>, rs1En : UInt<1>, immEn : UInt<1>, clearLsb : UInt<1>}, control : {jalOrJalr : UInt<1>, uType : UInt<1>, pcRel : UInt<1>, mRet : UInt<1>}, alu : {doSubtract : UInt<1>, boolOp : UInt<2>, cmpEqual : UInt<1>, cmpUnsigned : UInt<1>, shiftSigned : UInt<1>, shiftRight : UInt<1>, rdSelect : UInt<4>, opBIsRS2 : UInt<1>, flip cmpResult : UInt<1>}, rf : {rdAddress : UInt<5>, rs1Address : UInt<5>, rs2Address : UInt<5>, csrAddress : UInt<2>, csrEnable : UInt<1>}, mem : {memOp : UInt<1>, signed : UInt<1>, word : UInt<1>, half : UInt<1>, cmd : UInt<1>}, csr : {mStatusEn : UInt<1>, mieEn : UInt<1>, mcauseEn : UInt<1>, source : UInt<2>, dSel : UInt<1>, imm : UInt<1>, eOp : UInt<1>, eBreak : UInt<1>, mRet : UInt<1>}, top : {flip wbRdt : UInt<32>, flip wbEn : UInt<1>, imm : UInt<1>, rdCsrEn : UInt<1>, rdAluEn : UInt<1>}}
    
    node _T = bits(io.top.wbRdt, 11, 7) @[Decode.scala 15:45]
    reg r : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      r <= _T @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    io.rf.rdAddress <= r @[Decode.scala 15:20]
    node _T_1 = bits(io.top.wbRdt, 19, 15) @[Decode.scala 16:42]
    reg rs1Address : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      rs1Address <= _T_1 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    io.rf.rs1Address <= rs1Address @[Decode.scala 17:20]
    node _T_2 = bits(io.top.wbRdt, 24, 20) @[Decode.scala 18:45]
    reg r_1 : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      r_1 <= _T_2 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    io.rf.rs2Address <= r_1 @[Decode.scala 18:20]
    node _T_3 = bits(io.top.wbRdt, 14, 12) @[Decode.scala 20:38]
    reg funct3 : UInt<3>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      funct3 <= _T_3 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_4 = bits(io.top.wbRdt, 30, 30) @[Decode.scala 21:38]
    reg imm30 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm30 <= _T_4 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_5 = bits(io.top.wbRdt, 6, 2) @[Decode.scala 22:38]
    reg opcode : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      opcode <= _T_5 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_6 = bits(io.top.wbRdt, 20, 20) @[Decode.scala 23:36]
    reg op20 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      op20 <= _T_6 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_7 = bits(io.top.wbRdt, 21, 21) @[Decode.scala 24:36]
    reg op21 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      op21 <= _T_7 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_8 = bits(io.top.wbRdt, 22, 22) @[Decode.scala 25:36]
    reg op22 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      op22 <= _T_8 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_9 = bits(io.top.wbRdt, 26, 26) @[Decode.scala 26:36]
    reg op26 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      op26 <= _T_9 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_10 = bits(io.top.wbRdt, 31, 31) @[Decode.scala 29:39]
    reg signbit : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      signbit <= _T_10 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_11 = bits(io.top.wbRdt, 19, 12) @[Decode.scala 30:43]
    node _T_12 = bits(io.top.wbRdt, 20, 20) @[Decode.scala 30:66]
    node _T_13 = cat(_T_11, _T_12) @[Decode.scala 30:51]
    reg imm19_12_20 : UInt<9>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm19_12_20 <= _T_13 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_14 = bits(io.top.wbRdt, 7, 7) @[Decode.scala 31:36]
    reg imm7 : UInt<1>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm7 <= _T_14 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_15 = bits(io.top.wbRdt, 30, 25) @[Decode.scala 32:40]
    reg imm30_25 : UInt<6>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm30_25 <= _T_15 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_16 = bits(io.top.wbRdt, 24, 20) @[Decode.scala 33:40]
    reg imm24_20 : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm24_20 <= _T_16 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_17 = bits(io.top.wbRdt, 11, 7) @[Decode.scala 34:40]
    reg imm11_7 : UInt<5>, clock @[Reg.scala 15:16]
    when io.top.wbEn : @[Reg.scala 16:19]
      imm11_7 <= _T_17 @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node m3 = bits(opcode, 4, 4) @[Decode.scala 35:18]
    node _T_18 = bits(opcode, 4, 4) @[Decode.scala 36:19]
    node _T_19 = bits(opcode, 0, 0) @[Decode.scala 36:32]
    node _T_20 = eq(_T_19, UInt<1>("h00")) @[Decode.scala 36:25]
    node _T_21 = and(_T_18, _T_20) @[Decode.scala 36:23]
    node _T_22 = bits(opcode, 1, 0) @[Decode.scala 36:48]
    node _T_23 = eq(_T_22, UInt<1>("h00")) @[Decode.scala 36:54]
    node _T_24 = bits(opcode, 2, 1) @[Decode.scala 36:72]
    node _T_25 = eq(_T_24, UInt<1>("h00")) @[Decode.scala 36:78]
    node _T_26 = or(_T_23, _T_25) @[Decode.scala 36:63]
    node m2 = cat(_T_21, _T_26) @[Decode.scala 36:37]
    node _T_27 = bits(opcode, 4, 4) @[Decode.scala 37:21]
    node _T_28 = bits(opcode, 2, 2) @[Decode.scala 37:34]
    node _T_29 = and(_T_27, _T_28) @[Decode.scala 37:25]
    node _T_30 = orr(funct3) @[Decode.scala 37:51]
    node csrOp = and(_T_29, _T_30) @[Decode.scala 37:38]
    when io.count.enabled : @[Decode.scala 38:26]
      node _r_T = bits(imm24_20, 0, 0) @[Decode.scala 39:45]
      node _r_T_1 = mux(m3, signbit, _r_T) @[Decode.scala 39:23]
      node _r_T_2 = bits(imm19_12_20, 8, 1) @[Decode.scala 39:64]
      node _r_T_3 = cat(_r_T_1, _r_T_2) @[Decode.scala 39:50]
      imm19_12_20 <= _r_T_3 @[Decode.scala 39:17]
      imm7 <= signbit @[Decode.scala 40:17]
      node _r_T_4 = bits(m2, 1, 1) @[Decode.scala 41:26]
      node _r_T_5 = bits(m2, 0, 0) @[Decode.scala 41:43]
      node _r_T_6 = bits(imm19_12_20, 0, 0) @[Decode.scala 41:68]
      node _r_T_7 = mux(_r_T_5, signbit, _r_T_6) @[Decode.scala 41:40]
      node _r_T_8 = mux(_r_T_4, imm7, _r_T_7) @[Decode.scala 41:23]
      node _r_T_9 = bits(imm30_25, 5, 1) @[Decode.scala 41:85]
      node _r_T_10 = cat(_r_T_8, _r_T_9) @[Decode.scala 41:74]
      imm30_25 <= _r_T_10 @[Decode.scala 41:17]
      node _r_T_11 = bits(imm30_25, 0, 0) @[Decode.scala 42:28]
      node _r_T_12 = bits(imm24_20, 4, 1) @[Decode.scala 42:43]
      node _r_T_13 = cat(_r_T_11, _r_T_12) @[Decode.scala 42:32]
      imm24_20 <= _r_T_13 @[Decode.scala 42:17]
      node _r_T_14 = bits(imm30_25, 0, 0) @[Decode.scala 43:28]
      node _r_T_15 = bits(imm11_7, 4, 1) @[Decode.scala 43:42]
      node _r_T_16 = cat(_r_T_14, _r_T_15) @[Decode.scala 43:32]
      imm11_7 <= _r_T_16 @[Decode.scala 43:17]
      node _T_31 = and(csrOp, io.csr.dSel) @[Decode.scala 44:16]
      when _T_31 : @[Decode.scala 44:32]
        node _r_T_17 = bits(rs1Address, 4, 1) @[Decode.scala 45:43]
        node _r_T_18 = cat(UInt<1>("h00"), _r_T_17) @[Decode.scala 45:30]
        rs1Address <= _r_T_18 @[Decode.scala 45:18]
        skip @[Decode.scala 44:32]
      skip @[Decode.scala 38:26]
    node _T_32 = bits(opcode, 4, 4) @[Decode.scala 49:28]
    node _T_33 = eq(_T_32, UInt<1>("h00")) @[Decode.scala 49:21]
    node _T_34 = bits(opcode, 2, 2) @[Decode.scala 49:42]
    node _T_35 = and(_T_33, _T_34) @[Decode.scala 49:32]
    node _T_36 = bits(opcode, 0, 0) @[Decode.scala 49:56]
    node _T_37 = eq(_T_36, UInt<1>("h00")) @[Decode.scala 49:49]
    node opOrOpimm = and(_T_35, _T_37) @[Decode.scala 49:46]
    node _T_38 = bits(opcode, 4, 4) @[Decode.scala 50:28]
    node _T_39 = eq(_T_38, UInt<1>("h00")) @[Decode.scala 50:21]
    node _T_40 = bits(opcode, 2, 2) @[Decode.scala 50:42]
    node _T_41 = eq(_T_40, UInt<1>("h00")) @[Decode.scala 50:35]
    node _T_42 = and(_T_39, _T_41) @[Decode.scala 50:32]
    node _T_43 = bits(opcode, 0, 0) @[Decode.scala 50:56]
    node _T_44 = eq(_T_43, UInt<1>("h00")) @[Decode.scala 50:49]
    node _T_45 = and(_T_42, _T_44) @[Decode.scala 50:46]
    io.state.memOp <= _T_45 @[Decode.scala 50:18]
    io.mem.memOp <= io.state.memOp @[Decode.scala 51:18]
    node _T_46 = bits(funct3, 1, 0) @[Decode.scala 52:44]
    node _T_47 = eq(_T_46, UInt<1>("h01")) @[Decode.scala 52:50]
    node _T_48 = and(opOrOpimm, _T_47) @[Decode.scala 52:34]
    io.state.shiftOp <= _T_48 @[Decode.scala 52:21]
    node _T_49 = bits(funct3, 2, 1) @[Decode.scala 53:44]
    node _T_50 = eq(_T_49, UInt<1>("h01")) @[Decode.scala 53:50]
    node _T_51 = and(opOrOpimm, _T_50) @[Decode.scala 53:34]
    io.state.sltOp <= _T_51 @[Decode.scala 53:21]
    node _T_52 = bits(opcode, 4, 4) @[Decode.scala 54:30]
    node _T_53 = bits(opcode, 2, 2) @[Decode.scala 54:43]
    node _T_54 = eq(_T_53, UInt<1>("h00")) @[Decode.scala 54:36]
    node _T_55 = and(_T_52, _T_54) @[Decode.scala 54:34]
    io.state.branchOp <= _T_55 @[Decode.scala 54:21]
    node _T_56 = bits(opcode, 4, 4) @[Decode.scala 58:25]
    node _T_57 = bits(opcode, 2, 2) @[Decode.scala 58:37]
    node _T_58 = and(_T_56, _T_57) @[Decode.scala 58:29]
    node _T_59 = eq(op21, UInt<1>("h00")) @[Decode.scala 58:43]
    node _T_60 = and(_T_58, _T_59) @[Decode.scala 58:41]
    node _T_61 = orr(funct3) @[Decode.scala 58:63]
    node _T_62 = eq(_T_61, UInt<1>("h00")) @[Decode.scala 58:51]
    node _T_63 = and(_T_60, _T_62) @[Decode.scala 58:49]
    io.state.eOp <= _T_63 @[Decode.scala 58:16]
    io.csr.eOp <= io.state.eOp @[Decode.scala 59:14]
    io.state.eBreak <= op20 @[Decode.scala 61:19]
    io.csr.eBreak <= io.state.eBreak @[Decode.scala 62:17]
    node _T_64 = bits(opcode, 4, 4) @[Decode.scala 68:29]
    node _T_65 = eq(_T_64, UInt<1>("h00")) @[Decode.scala 68:22]
    node _T_66 = bits(opcode, 1, 1) @[Decode.scala 68:44]
    node _T_67 = eq(_T_66, UInt<1>("h00")) @[Decode.scala 68:37]
    node _T_68 = bits(opcode, 0, 0) @[Decode.scala 68:57]
    node _T_69 = and(_T_67, _T_68) @[Decode.scala 68:48]
    node _T_70 = or(_T_65, _T_69) @[Decode.scala 68:33]
    io.bufreg.rs1En <= _T_70 @[Decode.scala 68:19]
    node _T_71 = bits(opcode, 2, 2) @[Decode.scala 69:29]
    node _T_72 = eq(_T_71, UInt<1>("h00")) @[Decode.scala 69:22]
    io.bufreg.immEn <= _T_72 @[Decode.scala 69:19]
    io.bufreg.loop <= opOrOpimm @[Decode.scala 72:18]
    node _T_73 = bits(opcode, 4, 4) @[Decode.scala 77:31]
    node _T_74 = bits(opcode, 1, 0) @[Decode.scala 77:46]
    node _T_75 = eq(_T_74, UInt<1>("h00")) @[Decode.scala 77:52]
    node _T_76 = bits(opcode, 1, 0) @[Decode.scala 77:71]
    node _T_77 = eq(_T_76, UInt<2>("h03")) @[Decode.scala 77:77]
    node _T_78 = or(_T_75, _T_77) @[Decode.scala 77:61]
    node _T_79 = and(_T_73, _T_78) @[Decode.scala 77:35]
    io.bufreg.clearLsb <= _T_79 @[Decode.scala 77:22]
    node _T_80 = bits(opcode, 4, 4) @[Decode.scala 85:32]
    node _T_81 = bits(opcode, 2, 2) @[Decode.scala 85:46]
    node _T_82 = eq(_T_81, UInt<1>("h00")) @[Decode.scala 85:39]
    node _T_83 = and(_T_80, _T_82) @[Decode.scala 85:36]
    node _T_84 = bits(opcode, 0, 0) @[Decode.scala 85:60]
    node _T_85 = bits(funct3, 0, 0) @[Decode.scala 85:93]
    node _T_86 = xor(io.alu.cmpResult, _T_85) @[Decode.scala 85:85]
    node _T_87 = or(_T_84, _T_86) @[Decode.scala 85:64]
    node _T_88 = and(_T_83, _T_87) @[Decode.scala 85:50]
    io.state.takeBranch <= _T_88 @[Decode.scala 85:23]
    node _T_89 = bits(opcode, 4, 4) @[Decode.scala 87:34]
    node _T_90 = eq(_T_89, UInt<1>("h00")) @[Decode.scala 87:27]
    node _T_91 = bits(opcode, 2, 2) @[Decode.scala 87:47]
    node _T_92 = and(_T_90, _T_91) @[Decode.scala 87:38]
    node _T_93 = bits(opcode, 0, 0) @[Decode.scala 87:60]
    node _T_94 = and(_T_92, _T_93) @[Decode.scala 87:51]
    io.control.uType <= _T_94 @[Decode.scala 87:24]
    node _T_95 = bits(opcode, 4, 4) @[Decode.scala 88:34]
    node _T_96 = bits(opcode, 0, 0) @[Decode.scala 88:60]
    node _T_97 = and(_T_95, _T_96) @[Decode.scala 88:38]
    io.control.jalOrJalr <= _T_97 @[Decode.scala 88:24]
    node _T_98 = bits(opcode, 2, 0) @[Decode.scala 92:30]
    node _T_99 = eq(_T_98, UInt<1>("h00")) @[Decode.scala 92:36]
    node _T_100 = bits(opcode, 1, 0) @[Decode.scala 92:55]
    node _T_101 = eq(_T_100, UInt<2>("h03")) @[Decode.scala 92:61]
    node _T_102 = or(_T_99, _T_101) @[Decode.scala 92:45]
    node _T_103 = bits(opcode, 4, 3) @[Decode.scala 92:80]
    node _T_104 = eq(_T_103, UInt<1>("h00")) @[Decode.scala 92:86]
    node _T_105 = or(_T_102, _T_104) @[Decode.scala 92:70]
    io.control.pcRel <= _T_105 @[Decode.scala 92:20]
    node _T_106 = bits(opcode, 4, 4) @[Decode.scala 94:28]
    node _T_107 = bits(opcode, 2, 2) @[Decode.scala 94:41]
    node _T_108 = and(_T_106, _T_107) @[Decode.scala 94:32]
    node _T_109 = and(_T_108, op21) @[Decode.scala 94:45]
    node _T_110 = orr(funct3) @[Decode.scala 94:67]
    node _T_111 = eq(_T_110, UInt<1>("h00")) @[Decode.scala 94:56]
    node _T_112 = and(_T_109, _T_111) @[Decode.scala 94:53]
    io.control.mRet <= _T_112 @[Decode.scala 94:19]
    io.csr.mRet <= io.control.mRet @[Decode.scala 95:15]
    node _T_113 = bits(opcode, 2, 2) @[Decode.scala 100:27]
    node _T_114 = bits(opcode, 2, 2) @[Decode.scala 101:29]
    node _T_115 = eq(_T_114, UInt<1>("h00")) @[Decode.scala 101:22]
    node _T_116 = bits(opcode, 4, 4) @[Decode.scala 101:42]
    node _T_117 = and(_T_115, _T_116) @[Decode.scala 101:33]
    node _T_118 = bits(opcode, 0, 0) @[Decode.scala 101:55]
    node _T_119 = and(_T_117, _T_118) @[Decode.scala 101:46]
    node _T_120 = or(_T_113, _T_119) @[Decode.scala 100:31]
    node _T_121 = bits(opcode, 2, 2) @[Decode.scala 102:29]
    node _T_122 = eq(_T_121, UInt<1>("h00")) @[Decode.scala 102:22]
    node _T_123 = bits(opcode, 3, 3) @[Decode.scala 102:43]
    node _T_124 = eq(_T_123, UInt<1>("h00")) @[Decode.scala 102:36]
    node _T_125 = and(_T_122, _T_124) @[Decode.scala 102:33]
    node _T_126 = bits(opcode, 0, 0) @[Decode.scala 102:57]
    node _T_127 = eq(_T_126, UInt<1>("h00")) @[Decode.scala 102:50]
    node _T_128 = and(_T_125, _T_127) @[Decode.scala 102:47]
    node _T_129 = or(_T_120, _T_128) @[Decode.scala 101:60]
    node _T_130 = orr(io.rf.rdAddress) @[Decode.scala 102:85]
    node _T_131 = and(_T_129, _T_130) @[Decode.scala 102:63]
    io.state.rdOp <= _T_131 @[Decode.scala 100:17]
    node _T_132 = bits(opcode, 3, 3) @[Decode.scala 103:30]
    node _T_133 = and(_T_132, imm30) @[Decode.scala 103:34]
    io.alu.doSubtract <= _T_133 @[Decode.scala 103:21]
    node _T_134 = eq(op22, UInt<1>("h00")) @[Decode.scala 118:35]
    node _T_135 = and(op26, _T_134) @[Decode.scala 118:32]
    node _T_136 = eq(op21, UInt<1>("h00")) @[Decode.scala 118:44]
    node _T_137 = and(_T_135, _T_136) @[Decode.scala 118:41]
    node csrValid = or(op20, _T_137) @[Decode.scala 118:23]
    io.top.rdCsrEn <= csrOp @[Decode.scala 121:18]
    node _T_138 = and(csrOp, csrValid) @[Decode.scala 123:28]
    io.rf.csrEnable <= _T_138 @[Decode.scala 123:19]
    node _T_139 = eq(op26, UInt<1>("h00")) @[Decode.scala 124:32]
    node _T_140 = and(csrOp, _T_139) @[Decode.scala 124:29]
    node _T_141 = eq(op22, UInt<1>("h00")) @[Decode.scala 124:41]
    node _T_142 = and(_T_140, _T_141) @[Decode.scala 124:38]
    io.csr.mStatusEn <= _T_142 @[Decode.scala 124:20]
    node _T_143 = eq(op26, UInt<1>("h00")) @[Decode.scala 125:32]
    node _T_144 = and(csrOp, _T_143) @[Decode.scala 125:29]
    node _T_145 = and(_T_144, op22) @[Decode.scala 125:38]
    node _T_146 = eq(op20, UInt<1>("h00")) @[Decode.scala 125:50]
    node _T_147 = and(_T_145, _T_146) @[Decode.scala 125:47]
    io.csr.mieEn <= _T_147 @[Decode.scala 125:20]
    node _T_148 = and(csrOp, op21) @[Decode.scala 126:38]
    node _T_149 = eq(op20, UInt<1>("h00")) @[Decode.scala 126:50]
    node _T_150 = and(_T_148, _T_149) @[Decode.scala 126:47]
    io.csr.mcauseEn <= _T_150 @[Decode.scala 126:20]
    node _T_151 = bits(funct3, 1, 0) @[Decode.scala 127:26]
    io.csr.source <= _T_151 @[Decode.scala 127:17]
    node _T_152 = bits(funct3, 2, 2) @[Decode.scala 128:24]
    io.csr.dSel <= _T_152 @[Decode.scala 128:15]
    node _T_153 = bits(rs1Address, 0, 0) @[Decode.scala 129:27]
    io.csr.imm <= _T_153 @[Decode.scala 129:14]
    node _T_154 = eq(op20, UInt<1>("h00")) @[Decode.scala 131:14]
    node _T_155 = and(op26, _T_154) @[Decode.scala 131:11]
    node _T_156 = eq(op21, UInt<1>("h00")) @[Decode.scala 132:14]
    node _T_157 = and(op26, _T_156) @[Decode.scala 132:11]
    node _T_158 = mux(op26, UInt<2>("h03"), UInt<2>("h01")) @[Mux.scala 98:16]
    node _T_159 = mux(_T_157, UInt<2>("h02"), _T_158) @[Mux.scala 98:16]
    node _T_160 = mux(_T_155, UInt<2>("h00"), _T_159) @[Mux.scala 98:16]
    io.rf.csrAddress <= _T_160 @[Decode.scala 130:20]
    node _T_161 = bits(funct3, 2, 1) @[Decode.scala 135:28]
    node _T_162 = eq(_T_161, UInt<1>("h00")) @[Decode.scala 135:34]
    io.alu.cmpEqual <= _T_162 @[Decode.scala 135:19]
    node _T_163 = bits(funct3, 0, 0) @[Decode.scala 136:32]
    node _T_164 = bits(funct3, 1, 1) @[Decode.scala 136:45]
    node _T_165 = and(_T_163, _T_164) @[Decode.scala 136:36]
    node _T_166 = bits(funct3, 1, 1) @[Decode.scala 136:60]
    node _T_167 = bits(funct3, 2, 2) @[Decode.scala 136:73]
    node _T_168 = and(_T_166, _T_167) @[Decode.scala 136:64]
    node _T_169 = or(_T_165, _T_168) @[Decode.scala 136:50]
    io.alu.cmpUnsigned <= _T_169 @[Decode.scala 136:22]
    io.alu.shiftSigned <= imm30 @[Decode.scala 137:22]
    node _T_170 = bits(funct3, 2, 2) @[Decode.scala 138:30]
    io.alu.shiftRight <= _T_170 @[Decode.scala 138:21]
    node _T_171 = bits(funct3, 1, 0) @[Decode.scala 139:43]
    wire _WIRE : UInt<2> @[Decode.scala 139:36]
    _WIRE <= _T_171 @[Decode.scala 139:36]
    wire _WIRE_1 : UInt<2> @[Decode.scala 139:36]
    _WIRE_1 <= _WIRE @[Decode.scala 139:36]
    io.alu.boolOp <= _WIRE_1 @[Decode.scala 139:17]
    node _T_172 = bits(funct3, 2, 2) @[Decode.scala 141:23]
    node _T_173 = bits(funct3, 1, 0) @[Decode.scala 141:38]
    node _T_174 = eq(_T_173, UInt<1>("h01")) @[Decode.scala 141:44]
    node _T_175 = eq(_T_174, UInt<1>("h00")) @[Decode.scala 141:30]
    node aluBool = and(_T_172, _T_175) @[Decode.scala 141:27]
    node _T_176 = bits(funct3, 2, 1) @[Decode.scala 142:22]
    node aluSlt = eq(_T_176, UInt<1>("h01")) @[Decode.scala 142:28]
    node _T_177 = bits(funct3, 1, 0) @[Decode.scala 143:24]
    node aluShift = eq(_T_177, UInt<1>("h01")) @[Decode.scala 143:30]
    node aluAddSub = eq(funct3, UInt<1>("h00")) @[Decode.scala 144:26]
    node _T_178 = cat(aluBool, aluSlt) @[Decode.scala 145:37]
    node _T_179 = cat(_T_178, aluShift) @[Decode.scala 145:47]
    node _T_180 = cat(_T_179, aluAddSub) @[Decode.scala 145:59]
    wire _WIRE_2 : UInt<4> @[Decode.scala 145:28]
    _WIRE_2 <= _T_180 @[Decode.scala 145:28]
    wire _WIRE_3 : UInt<4> @[Decode.scala 145:28]
    _WIRE_3 <= _WIRE_2 @[Decode.scala 145:28]
    io.alu.rdSelect <= _WIRE_3 @[Decode.scala 145:19]
    node _T_181 = bits(opcode, 3, 3) @[Decode.scala 147:23]
    io.mem.cmd <= _T_181 @[Decode.scala 147:14]
    node _T_182 = bits(funct3, 2, 2) @[Decode.scala 148:27]
    node _T_183 = eq(_T_182, UInt<1>("h00")) @[Decode.scala 148:20]
    io.mem.signed <= _T_183 @[Decode.scala 148:17]
    node _T_184 = bits(funct3, 1, 1) @[Decode.scala 149:24]
    io.mem.word <= _T_184 @[Decode.scala 149:15]
    node _T_185 = bits(funct3, 0, 0) @[Decode.scala 150:24]
    io.mem.half <= _T_185 @[Decode.scala 150:15]
    node _T_186 = bits(opcode, 3, 0) @[Decode.scala 154:18]
    node m1 = eq(_T_186, UInt<4>("h08")) @[Decode.scala 154:24]
    node _T_187 = bits(imm11_7, 0, 0) @[Decode.scala 155:60]
    node _T_188 = bits(imm24_20, 0, 0) @[Decode.scala 155:73]
    node _T_189 = mux(m1, _T_187, _T_188) @[Decode.scala 155:48]
    node _T_190 = mux(io.count.done, signbit, _T_189) @[Decode.scala 155:20]
    io.top.imm <= _T_190 @[Decode.scala 155:14]
    node _T_191 = bits(opcode, 3, 3) @[Decode.scala 159:28]
    io.alu.opBIsRS2 <= _T_191 @[Decode.scala 159:19]
    node _T_192 = bits(opcode, 0, 0) @[Decode.scala 161:28]
    node _T_193 = eq(_T_192, UInt<1>("h00")) @[Decode.scala 161:21]
    node _T_194 = bits(opcode, 2, 2) @[Decode.scala 161:41]
    node _T_195 = and(_T_193, _T_194) @[Decode.scala 161:32]
    node _T_196 = bits(opcode, 4, 4) @[Decode.scala 161:55]
    node _T_197 = eq(_T_196, UInt<1>("h00")) @[Decode.scala 161:48]
    node _T_198 = and(_T_195, _T_197) @[Decode.scala 161:45]
    io.top.rdAluEn <= _T_198 @[Decode.scala 161:18]
    
  module BufReg : 
    input clock : Clock
    input reset : Reset
    output io : {flip count : {enabled : UInt<1>, init : UInt<1>, count0 : UInt<1>, count0To3 : UInt<1>, count12To31 : UInt<1>, count1 : UInt<1>, count2 : UInt<1>, count3 : UInt<1>, count7 : UInt<1>, done : UInt<1>}, flip decode : {loop : UInt<1>, rs1En : UInt<1>, immEn : UInt<1>, clearLsb : UInt<1>}, flip state : {hold : UInt<1>}, flip imm : UInt<1>, flip rs1 : UInt<1>, lsb : UInt<2>, dataBusAddress : UInt<32>, dataOut : UInt<1>}
    
    node enabled = eq(io.state.hold, UInt<1>("h00")) @[BufReg.scala 13:17]
    node clearLsb = and(io.count.count0, io.decode.clearLsb) @[BufReg.scala 15:34]
    reg carry : UInt<1>, clock @[BufReg.scala 17:18]
    node _T = and(io.rs1, io.decode.rs1En) @[BufReg.scala 18:21]
    node _T_1 = and(io.imm, io.decode.immEn) @[BufReg.scala 18:51]
    node _T_2 = eq(clearLsb, UInt<1>("h00")) @[BufReg.scala 18:71]
    node _T_3 = and(_T_1, _T_2) @[BufReg.scala 18:69]
    node _T_4 = add(_T, _T_3) @[BufReg.scala 18:40]
    node _T_5 = add(_T_4, carry) @[BufReg.scala 18:82]
    node c_q = tail(_T_5, 1) @[BufReg.scala 18:82]
    node q = bits(c_q, 0, 0) @[BufReg.scala 19:14]
    node _T_6 = bits(c_q, 1, 1) @[BufReg.scala 21:15]
    node _T_7 = and(_T_6, io.count.init) @[BufReg.scala 21:19]
    carry <= _T_7 @[BufReg.scala 21:9]
    reg data : UInt<32>, clock @[BufReg.scala 23:17]
    node _T_8 = eq(io.count.init, UInt<1>("h00")) @[BufReg.scala 24:39]
    node _T_9 = and(io.decode.loop, _T_8) @[BufReg.scala 24:36]
    node _T_10 = bits(data, 0, 0) @[BufReg.scala 24:59]
    node newData = mux(_T_9, _T_10, q) @[BufReg.scala 24:20]
    when enabled : @[BufReg.scala 25:17]
      node _T_11 = bits(data, 31, 1) @[BufReg.scala 25:42]
      node _T_12 = cat(newData, _T_11) @[BufReg.scala 25:35]
      data <= _T_12 @[BufReg.scala 25:24]
      skip @[BufReg.scala 25:17]
    node _T_13 = bits(data, 0, 0) @[BufReg.scala 26:21]
    io.dataOut <= _T_13 @[BufReg.scala 26:14]
    node _T_14 = bits(data, 31, 2) @[BufReg.scala 27:28]
    node _T_15 = cat(_T_14, UInt<2>("h00")) @[BufReg.scala 27:35]
    io.dataBusAddress <= _T_15 @[BufReg.scala 27:21]
    reg lsb_1 : UInt<1>, clock @[BufReg.scala 29:28]
    reg lsb_0 : UInt<1>, clock @[BufReg.scala 29:44]
    node _T_16 = cat(lsb_1, lsb_0) @[BufReg.scala 30:19]
    io.lsb <= _T_16 @[BufReg.scala 30:10]
    when io.count.count0 : @[BufReg.scala 31:25]
      lsb_0 <= q @[BufReg.scala 32:11]
      skip @[BufReg.scala 31:25]
    when io.count.count1 : @[BufReg.scala 34:25]
      lsb_1 <= q @[BufReg.scala 35:11]
      skip @[BufReg.scala 34:25]
    
  module Control : 
    input clock : Clock
    input reset : Reset
    output io : {flip state : {pcEnable : UInt<1>, jump : UInt<1>, trap : UInt<1>}, count : {flip enabled : UInt<1>, flip init : UInt<1>, flip count0 : UInt<1>, flip count0To3 : UInt<1>, flip count12To31 : UInt<1>, flip count1 : UInt<1>, flip count2 : UInt<1>, flip count3 : UInt<1>, flip count7 : UInt<1>, flip done : UInt<1>}, flip decode : {jalOrJalr : UInt<1>, uType : UInt<1>, pcRel : UInt<1>, mRet : UInt<1>}, ibus : {address : UInt<32>, cyc : UInt<1>, flip ack : UInt<1>}, data : {flip imm : UInt<1>, flip buf : UInt<1>, flip csrPc : UInt<1>, rd : UInt<1>, badPc : UInt<1>}}
    
    node trap = or(io.state.trap, io.decode.mRet) @[Control.scala 14:28]
    reg enablePc : UInt<1>, clock with : (reset => (reset, UInt<1>("h01"))) @[Control.scala 16:25]
    reg pc : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Control.scala 17:19]
    node offsetA = and(io.decode.pcRel, pc) @[Control.scala 19:33]
    node _T = and(io.data.imm, io.count.count12To31) @[Control.scala 20:50]
    node offsetB = mux(io.decode.uType, _T, io.data.buf) @[Control.scala 20:20]
    reg pcPlusOffsetCarry : UInt<1>, clock @[Control.scala 21:30]
    node _T_1 = add(offsetA, offsetB) @[Control.scala 22:30]
    node _T_2 = add(_T_1, pcPlusOffsetCarry) @[Control.scala 22:41]
    node pcPlusOffset = tail(_T_2, 1) @[Control.scala 22:41]
    node _T_3 = bits(pcPlusOffset, 1, 1) @[Control.scala 23:56]
    node _T_4 = and(io.state.pcEnable, _T_3) @[Control.scala 23:42]
    pcPlusOffsetCarry <= _T_4 @[Control.scala 23:21]
    node _T_5 = bits(pcPlusOffset, 0, 0) @[Control.scala 24:41]
    node pcPlusOffsetAligned = and(_T_5, enablePc) @[Control.scala 24:45]
    io.data.badPc <= pcPlusOffsetAligned @[Control.scala 25:17]
    reg pcPlus4Carry : UInt<1>, clock @[Control.scala 28:25]
    node _T_6 = bits(pc, 0, 0) @[Control.scala 29:19]
    node _T_7 = add(_T_6, io.count.count2) @[Control.scala 29:23]
    node _T_8 = add(_T_7, pcPlus4Carry) @[Control.scala 29:32]
    node pcPlus4 = tail(_T_8, 1) @[Control.scala 29:32]
    node _T_9 = bits(pcPlus4, 1, 1) @[Control.scala 30:46]
    node _T_10 = and(io.state.pcEnable, _T_9) @[Control.scala 30:37]
    pcPlus4Carry <= _T_10 @[Control.scala 30:16]
    wire newPc : UInt<1> @[Control.scala 32:19]
    when io.state.trap : @[Control.scala 34:25]
      node _T_11 = and(io.data.csrPc, enablePc) @[Control.scala 35:30]
      newPc <= _T_11 @[Control.scala 35:13]
      skip @[Control.scala 34:25]
    else : @[Control.scala 36:32]
      when io.state.jump : @[Control.scala 36:32]
        newPc <= pcPlusOffsetAligned @[Control.scala 37:13]
        skip @[Control.scala 36:32]
      else : @[Control.scala 38:18]
        node _T_12 = bits(pcPlus4, 0, 0) @[Control.scala 39:23]
        newPc <= _T_12 @[Control.scala 39:13]
        skip @[Control.scala 38:18]
    node _T_13 = and(io.decode.uType, pcPlusOffsetAligned) @[Control.scala 49:34]
    node _T_14 = bits(pcPlus4, 0, 0) @[Control.scala 49:67]
    node _T_15 = and(_T_14, io.decode.jalOrJalr) @[Control.scala 49:71]
    node _T_16 = or(_T_13, _T_15) @[Control.scala 49:57]
    io.data.rd <= _T_16 @[Control.scala 49:14]
    node _T_17 = eq(io.state.pcEnable, UInt<1>("h00")) @[Control.scala 51:30]
    node _T_18 = and(enablePc, _T_17) @[Control.scala 51:27]
    io.ibus.cyc <= _T_18 @[Control.scala 51:15]
    io.ibus.address <= pc @[Control.scala 52:19]
    when io.state.pcEnable : @[Control.scala 54:27]
      enablePc <= UInt<1>("h01") @[Control.scala 55:14]
      node _T_19 = bits(pc, 31, 1) @[Control.scala 56:22]
      node _T_20 = cat(newPc, _T_19) @[Control.scala 56:17]
      pc <= _T_20 @[Control.scala 56:8]
      skip @[Control.scala 54:27]
    else : @[Control.scala 57:43]
      node _T_21 = and(io.ibus.cyc, io.ibus.ack) @[Control.scala 57:27]
      when _T_21 : @[Control.scala 57:43]
        enablePc <= UInt<1>("h00") @[Control.scala 58:14]
        skip @[Control.scala 57:43]
    
  module SerialShift : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip shiftAmount : UInt<5>, flip shamt_msb : UInt<1>, flip signbit : UInt<1>, flip right : UInt<1>, done : UInt<1>, flip d : UInt<1>, q : UInt<1>}
    
    reg cnt : UInt<6>, clock @[Alu.scala 121:16]
    reg signbit : UInt<1>, clock @[Alu.scala 122:20]
    node _T = head(cnt, 1) @[Alu.scala 123:33]
    node _T_1 = eq(io.right, UInt<1>("h00")) @[Alu.scala 123:54]
    node _T_2 = and(io.shamt_msb, _T_1) @[Alu.scala 123:52]
    node _T_3 = or(_T, _T_2) @[Alu.scala 123:37]
    reg wrapped : UInt, clock @[Alu.scala 123:24]
    wrapped <= _T_3 @[Alu.scala 123:24]
    when io.load : @[Alu.scala 125:17]
      cnt <= UInt<1>("h00") @[Alu.scala 126:9]
      node _T_4 = and(io.signbit, io.right) @[Alu.scala 127:27]
      signbit <= _T_4 @[Alu.scala 127:13]
      skip @[Alu.scala 125:17]
    else : @[Alu.scala 128:15]
      node _T_5 = add(cnt, UInt<1>("h01")) @[Alu.scala 129:16]
      node _T_6 = tail(_T_5, 1) @[Alu.scala 129:16]
      cnt <= _T_6 @[Alu.scala 129:9]
      skip @[Alu.scala 128:15]
    node _T_7 = bits(cnt, 4, 0) @[Alu.scala 132:17]
    node _T_8 = eq(_T_7, io.shiftAmount) @[Alu.scala 132:24]
    io.done <= _T_8 @[Alu.scala 132:11]
    node _T_9 = neq(io.right, wrapped) @[Alu.scala 133:24]
    node _T_10 = mux(_T_9, io.d, signbit) @[Alu.scala 133:14]
    io.q <= _T_10 @[Alu.scala 133:8]
    
  module Alu : 
    input clock : Clock
    input reset : Reset
    output io : {flip decode : {doSubtract : UInt<1>, boolOp : UInt<2>, cmpEqual : UInt<1>, cmpUnsigned : UInt<1>, shiftSigned : UInt<1>, shiftRight : UInt<1>, rdSelect : UInt<4>, opBIsRS2 : UInt<1>, flip cmpResult : UInt<1>}, data : {flip rs1 : UInt<1>, flip rs2 : UInt<1>, flip imm : UInt<1>, flip buffer : UInt<1>, rd : UInt<1>}, count : {flip enabled : UInt<1>, flip init : UInt<1>, flip count0 : UInt<1>, flip count0To3 : UInt<1>, flip count12To31 : UInt<1>, flip count1 : UInt<1>, flip count2 : UInt<1>, flip count3 : UInt<1>, flip count7 : UInt<1>, flip done : UInt<1>}, flip state : {shiftAmountEnable : UInt<1>, flip shiftDone : UInt<1>}}
    
    node operandB = mux(io.decode.opBIsRS2, io.data.rs2, io.data.imm) @[Alu.scala 46:21]
    reg negativeBCarry : UInt<1>, clock @[Alu.scala 50:27]
    node _T = not(operandB) @[Alu.scala 51:33]
    node _T_1 = add(_T, io.count.count0) @[Alu.scala 51:43]
    node _T_2 = add(_T_1, negativeBCarry) @[Alu.scala 51:52]
    node negativeBCarryAndResult = tail(_T_2, 1) @[Alu.scala 51:52]
    node _T_3 = bits(negativeBCarryAndResult, 1, 1) @[Alu.scala 52:63]
    node _T_4 = and(io.count.enabled, _T_3) @[Alu.scala 52:38]
    negativeBCarry <= _T_4 @[Alu.scala 52:18]
    node negativeB = bits(negativeBCarryAndResult, 0, 0) @[Alu.scala 53:42]
    node addB = mux(io.decode.doSubtract, negativeB, operandB) @[Alu.scala 57:17]
    reg addCarry : UInt<1>, clock @[Alu.scala 58:21]
    node _T_5 = add(io.data.rs1, addB) @[Alu.scala 59:43]
    node _T_6 = add(_T_5, addCarry) @[Alu.scala 59:51]
    node addCarryNextAndResult = tail(_T_6, 1) @[Alu.scala 59:51]
    node _T_7 = bits(addCarryNextAndResult, 1, 1) @[Alu.scala 60:55]
    node _T_8 = and(io.count.enabled, _T_7) @[Alu.scala 60:32]
    addCarry <= _T_8 @[Alu.scala 60:12]
    node resultAdd = bits(addCarryNextAndResult, 0, 0) @[Alu.scala 61:40]
    node shiftAmountSerial = mux(io.decode.shiftRight, operandB, negativeB) @[Alu.scala 64:30]
    reg shiftAmount : UInt<5>, clock @[Alu.scala 65:24]
    inst shift of SerialShift @[Alu.scala 66:21]
    shift.clock <= clock
    shift.reset <= reset
    shift.io.load <= io.count.init @[Alu.scala 67:17]
    shift.io.shiftAmount <= shiftAmount @[Alu.scala 68:24]
    reg shiftAmountMSB : UInt<1>, clock @[Alu.scala 69:27]
    when io.state.shiftAmountEnable : @[Alu.scala 70:36]
      shiftAmountMSB <= negativeB @[Alu.scala 71:20]
      node _T_9 = bits(shiftAmount, 4, 1) @[Alu.scala 72:52]
      node _T_10 = cat(shiftAmountSerial, _T_9) @[Alu.scala 72:38]
      shiftAmount <= _T_10 @[Alu.scala 72:17]
      skip @[Alu.scala 70:36]
    shift.io.shamt_msb <= shiftAmountMSB @[Alu.scala 74:22]
    node _T_11 = and(io.decode.shiftSigned, io.data.rs1) @[Alu.scala 75:45]
    shift.io.signbit <= _T_11 @[Alu.scala 75:20]
    shift.io.right <= io.decode.shiftRight @[Alu.scala 76:18]
    shift.io.d <= io.data.buffer @[Alu.scala 77:14]
    io.state.shiftDone <= shift.io.done @[Alu.scala 78:22]
    node equal = eq(io.data.rs1, operandB) @[Alu.scala 82:27]
    reg equalBuf : UInt<1>, clock @[Alu.scala 83:21]
    node resultEqual = and(equal, equalBuf) @[Alu.scala 84:27]
    node _T_12 = not(io.count.enabled) @[Alu.scala 85:29]
    node _T_13 = or(resultEqual, _T_12) @[Alu.scala 85:27]
    equalBuf <= _T_13 @[Alu.scala 85:12]
    reg ltBuf : UInt<1>, clock @[Alu.scala 88:18]
    node _T_14 = eq(io.decode.cmpUnsigned, UInt<1>("h00")) @[Alu.scala 89:32]
    node ltSign = and(io.count.done, _T_14) @[Alu.scala 89:30]
    node _T_15 = xor(operandB, ltSign) @[Alu.scala 90:45]
    node resultLt = mux(equal, ltBuf, _T_15) @[Alu.scala 90:21]
    node _T_16 = and(resultLt, io.count.enabled) @[Alu.scala 91:21]
    ltBuf <= _T_16 @[Alu.scala 91:9]
    reg resultLtBuf : UInt<1>, clock @[Alu.scala 92:24]
    when io.count.enabled : @[Alu.scala 93:26]
      resultLtBuf <= resultLt @[Alu.scala 93:40]
      skip @[Alu.scala 93:26]
    node _T_17 = mux(io.decode.cmpEqual, resultEqual, resultLt) @[Alu.scala 95:29]
    io.decode.cmpResult <= _T_17 @[Alu.scala 95:23]
    node _T_18 = asUInt(io.decode.boolOp) @[Alu.scala 99:59]
    node _T_19 = cat(_T_18, io.data.rs1) @[Alu.scala 99:62]
    node _T_20 = cat(_T_19, operandB) @[Alu.scala 99:77]
    node _T_21 = dshr(UInt<16>("h08e96"), _T_20) @[Alu.scala 99:35]
    node resultBool = bits(_T_21, 0, 0) @[Alu.scala 99:35]
    node _T_22 = asUInt(io.decode.rdSelect) @[Alu.scala 103:31]
    node _T_23 = bits(_T_22, 0, 0) @[Alu.scala 103:33]
    node _T_24 = and(_T_23, resultAdd) @[Alu.scala 103:37]
    node _T_25 = asUInt(io.decode.rdSelect) @[Alu.scala 104:31]
    node _T_26 = bits(_T_25, 1, 1) @[Alu.scala 104:33]
    node _T_27 = and(_T_26, shift.io.q) @[Alu.scala 104:37]
    node _T_28 = or(_T_24, _T_27) @[Alu.scala 103:60]
    node _T_29 = asUInt(io.decode.rdSelect) @[Alu.scala 105:31]
    node _T_30 = bits(_T_29, 2, 2) @[Alu.scala 105:33]
    node _T_31 = and(_T_30, resultLtBuf) @[Alu.scala 105:37]
    node _T_32 = and(_T_31, io.count.count0) @[Alu.scala 105:51]
    node _T_33 = or(_T_28, _T_32) @[Alu.scala 104:60]
    node _T_34 = asUInt(io.decode.rdSelect) @[Alu.scala 106:31]
    node _T_35 = bits(_T_34, 3, 3) @[Alu.scala 106:33]
    node _T_36 = and(_T_35, resultBool) @[Alu.scala 106:37]
    node _T_37 = or(_T_33, _T_36) @[Alu.scala 105:60]
    io.data.rd <= _T_37 @[Alu.scala 102:14]
    
  module RegisterFileInterface : 
    input clock : Clock
    input reset : Reset
    output io : {flip rf : {write0 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, write1 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, read0 : {flip addr : UInt<6>, data : UInt<1>}, read1 : {flip addr : UInt<6>, data : UInt<1>}}, trap : {flip doTrap : UInt<1>, flip mRet : UInt<1>, flip mePC : UInt<1>, flip memMisaligned : UInt<1>, flip bufRegData : UInt<1>, flip badPC : UInt<1>, csrPC : UInt<1>}, csr : {readData : UInt<1>, flip writeData : UInt<1>}, rd : {flip writeEnable : UInt<1>, flip controlData : UInt<1>, flip aluData : UInt<1>, flip aluEnable : UInt<1>, flip csrData : UInt<1>, flip csrEnable : UInt<1>, flip memData : UInt<1>}, rs1Data : UInt<1>, rs2Data : UInt<1>, flip decode : {rdAddress : UInt<5>, rs1Address : UInt<5>, rs2Address : UInt<5>, csrAddress : UInt<2>, csrEnable : UInt<1>}}
    
    node MepcAddress = cat(UInt<4>("h08"), UInt<2>("h02")) @[RegisterFileInterface.scala 22:31]
    node MtvalAddress = cat(UInt<4>("h08"), UInt<2>("h03")) @[RegisterFileInterface.scala 23:32]
    node MtvecAddress = cat(UInt<4>("h08"), UInt<2>("h01")) @[RegisterFileInterface.scala 24:32]
    node _T = and(io.rd.aluData, io.rd.aluEnable) @[RegisterFileInterface.scala 30:22]
    node _T_1 = or(io.rd.controlData, _T) @[RegisterFileInterface.scala 29:32]
    node _T_2 = and(io.rd.csrData, io.rd.csrEnable) @[RegisterFileInterface.scala 31:22]
    node _T_3 = or(_T_1, _T_2) @[RegisterFileInterface.scala 30:41]
    node _T_4 = or(_T_3, io.rd.memData) @[RegisterFileInterface.scala 31:41]
    node _T_5 = mux(io.trap.memMisaligned, io.trap.bufRegData, io.trap.badPC) @[RegisterFileInterface.scala 35:20]
    node _T_6 = mux(io.trap.doTrap, _T_5, _T_4) @[RegisterFileInterface.scala 36:29]
    io.rf.write0.data <= _T_6 @[RegisterFileInterface.scala 36:23]
    node _T_7 = mux(io.trap.doTrap, MtvalAddress, io.decode.rdAddress) @[RegisterFileInterface.scala 37:29]
    io.rf.write0.addr <= _T_7 @[RegisterFileInterface.scala 37:23]
    node _T_8 = or(io.trap.doTrap, io.rd.writeEnable) @[RegisterFileInterface.scala 38:43]
    io.rf.write0.enable <= _T_8 @[RegisterFileInterface.scala 38:25]
    node _T_9 = mux(io.trap.doTrap, io.trap.mePC, io.csr.writeData) @[RegisterFileInterface.scala 41:29]
    io.rf.write1.data <= _T_9 @[RegisterFileInterface.scala 41:23]
    node _T_10 = mux(io.trap.doTrap, MepcAddress, io.decode.csrAddress) @[RegisterFileInterface.scala 42:29]
    io.rf.write1.addr <= _T_10 @[RegisterFileInterface.scala 42:23]
    node _T_11 = or(io.trap.doTrap, io.decode.csrEnable) @[RegisterFileInterface.scala 43:43]
    io.rf.write1.enable <= _T_11 @[RegisterFileInterface.scala 43:25]
    io.rf.read0.addr <= io.decode.rs1Address @[RegisterFileInterface.scala 48:22]
    io.rs1Data <= io.rf.read0.data @[RegisterFileInterface.scala 49:16]
    node _T_12 = cat(UInt<4>("h08"), io.decode.csrAddress) @[RegisterFileInterface.scala 55:40]
    node _T_13 = mux(io.decode.csrEnable, _T_12, io.decode.rs2Address) @[Mux.scala 98:16]
    node _T_14 = mux(io.trap.mRet, MepcAddress, _T_13) @[Mux.scala 98:16]
    node _T_15 = mux(io.trap.doTrap, MtvecAddress, _T_14) @[Mux.scala 98:16]
    io.rf.read1.addr <= _T_15 @[RegisterFileInterface.scala 52:22]
    io.rs2Data <= io.rf.read1.data @[RegisterFileInterface.scala 57:16]
    node _T_16 = and(io.rf.read1.data, io.decode.csrEnable) @[RegisterFileInterface.scala 58:41]
    io.csr.readData <= _T_16 @[RegisterFileInterface.scala 58:21]
    io.trap.csrPC <= io.rf.read1.data @[RegisterFileInterface.scala 59:19]
    
  module MemoryInterface : 
    input clock : Clock
    input reset : Reset
    output io : {flip enabled : UInt<1>, flip decode : {memOp : UInt<1>, signed : UInt<1>, word : UInt<1>, half : UInt<1>, cmd : UInt<1>}, flip state : {byteCount : UInt<2>, flip misaligned : UInt<1>}, flip lsb : UInt<2>, flip rs2 : UInt<1>, rd : UInt<1>, dbus : {flip rdt : UInt<32>, flip ack : UInt<1>, dat : UInt<32>, sel : UInt<4>}}
    
    node byteCountPlusLsb = add(io.state.byteCount, io.lsb) @[MemoryInterface.scala 17:45]
    reg data : UInt<32>, clock @[MemoryInterface.scala 19:17]
    node _T = bits(byteCountPlusLsb, 2, 2) @[MemoryInterface.scala 20:52]
    node _T_1 = eq(_T, UInt<1>("h00")) @[MemoryInterface.scala 20:35]
    node dataEnabled = and(io.enabled, _T_1) @[MemoryInterface.scala 20:32]
    when dataEnabled : @[MemoryInterface.scala 21:21]
      node _T_2 = bits(data, 31, 1) @[MemoryInterface.scala 21:45]
      node _T_3 = cat(io.rs2, _T_2) @[MemoryInterface.scala 21:38]
      data <= _T_3 @[MemoryInterface.scala 21:28]
      skip @[MemoryInterface.scala 21:21]
    when io.dbus.ack : @[MemoryInterface.scala 22:21]
      data <= io.dbus.rdt @[MemoryInterface.scala 22:28]
      skip @[MemoryInterface.scala 22:21]
    node _T_4 = eq(io.lsb, UInt<2>("h03")) @[MemoryInterface.scala 25:14]
    node _T_5 = bits(data, 24, 24) @[MemoryInterface.scala 25:30]
    node _T_6 = and(_T_4, _T_5) @[MemoryInterface.scala 25:23]
    node _T_7 = eq(io.lsb, UInt<2>("h02")) @[MemoryInterface.scala 26:14]
    node _T_8 = bits(data, 16, 16) @[MemoryInterface.scala 26:30]
    node _T_9 = and(_T_7, _T_8) @[MemoryInterface.scala 26:23]
    node _T_10 = or(_T_6, _T_9) @[MemoryInterface.scala 25:36]
    node _T_11 = eq(io.lsb, UInt<1>("h01")) @[MemoryInterface.scala 27:14]
    node _T_12 = bits(data, 8, 8) @[MemoryInterface.scala 27:30]
    node _T_13 = and(_T_11, _T_12) @[MemoryInterface.scala 27:23]
    node _T_14 = or(_T_10, _T_13) @[MemoryInterface.scala 26:36]
    node _T_15 = eq(io.lsb, UInt<1>("h00")) @[MemoryInterface.scala 28:14]
    node _T_16 = bits(data, 0, 0) @[MemoryInterface.scala 28:30]
    node _T_17 = and(_T_15, _T_16) @[MemoryInterface.scala 28:23]
    node dataCur = or(_T_14, _T_17) @[MemoryInterface.scala 27:36]
    node _T_18 = eq(io.state.byteCount, UInt<1>("h00")) @[MemoryInterface.scala 29:57]
    node _T_19 = or(io.decode.word, _T_18) @[MemoryInterface.scala 29:34]
    node _T_20 = bits(io.state.byteCount, 1, 1) @[MemoryInterface.scala 29:107]
    node _T_21 = eq(_T_20, UInt<1>("h00")) @[MemoryInterface.scala 29:88]
    node _T_22 = and(io.decode.half, _T_21) @[MemoryInterface.scala 29:85]
    node dataValid = or(_T_19, _T_22) @[MemoryInterface.scala 29:66]
    reg signBit : UInt<1>, clock @[Reg.scala 15:16]
    when dataValid : @[Reg.scala 16:19]
      signBit <= dataCur @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_23 = and(signBit, io.decode.signed) @[MemoryInterface.scala 32:62]
    node _T_24 = mux(dataValid, dataCur, _T_23) @[MemoryInterface.scala 32:33]
    node _T_25 = and(io.decode.memOp, _T_24) @[MemoryInterface.scala 32:28]
    io.rd <= _T_25 @[MemoryInterface.scala 32:9]
    node _T_26 = eq(io.lsb, UInt<2>("h03")) @[MemoryInterface.scala 33:23]
    node _T_27 = or(_T_26, io.decode.word) @[MemoryInterface.scala 33:32]
    node _T_28 = bits(io.lsb, 1, 1) @[MemoryInterface.scala 33:78]
    node _T_29 = and(io.decode.half, _T_28) @[MemoryInterface.scala 33:69]
    node sel_3 = or(_T_27, _T_29) @[MemoryInterface.scala 33:50]
    node _T_30 = eq(io.lsb, UInt<2>("h02")) @[MemoryInterface.scala 34:23]
    node sel_2 = or(_T_30, io.decode.word) @[MemoryInterface.scala 34:32]
    node _T_31 = eq(io.lsb, UInt<1>("h01")) @[MemoryInterface.scala 35:23]
    node _T_32 = or(_T_31, io.decode.word) @[MemoryInterface.scala 35:32]
    node _T_33 = bits(io.lsb, 1, 1) @[MemoryInterface.scala 35:79]
    node _T_34 = eq(_T_33, UInt<1>("h00")) @[MemoryInterface.scala 35:72]
    node _T_35 = and(io.decode.half, _T_34) @[MemoryInterface.scala 35:69]
    node sel_1 = or(_T_32, _T_35) @[MemoryInterface.scala 35:50]
    node sel_0 = eq(io.lsb, UInt<1>("h00")) @[MemoryInterface.scala 36:23]
    node _T_36 = cat(sel_3, sel_2) @[MemoryInterface.scala 37:24]
    node _T_37 = cat(_T_36, sel_1) @[MemoryInterface.scala 37:33]
    node _T_38 = cat(_T_37, sel_0) @[MemoryInterface.scala 37:42]
    io.dbus.sel <= _T_38 @[MemoryInterface.scala 37:15]
    io.dbus.dat <= data @[MemoryInterface.scala 39:15]
    node _T_39 = bits(io.lsb, 0, 0) @[MemoryInterface.scala 42:35]
    node _T_40 = or(io.decode.word, io.decode.half) @[MemoryInterface.scala 42:58]
    node _T_41 = and(_T_39, _T_40) @[MemoryInterface.scala 42:39]
    node _T_42 = bits(io.lsb, 1, 1) @[MemoryInterface.scala 42:88]
    node _T_43 = and(_T_42, io.decode.word) @[MemoryInterface.scala 42:92]
    node _T_44 = or(_T_41, _T_43) @[MemoryInterface.scala 42:78]
    reg REG : UInt<1>, clock @[MemoryInterface.scala 42:27]
    REG <= _T_44 @[MemoryInterface.scala 42:27]
    node _T_45 = and(REG, io.decode.memOp) @[MemoryInterface.scala 43:37]
    io.state.misaligned <= _T_45 @[MemoryInterface.scala 43:25]
    
  module Csr : 
    input clock : Clock
    input reset : Reset
    output io : {count : {flip enabled : UInt<1>, flip init : UInt<1>, flip count0 : UInt<1>, flip count0To3 : UInt<1>, flip count12To31 : UInt<1>, flip count1 : UInt<1>, flip count2 : UInt<1>, flip count3 : UInt<1>, flip count7 : UInt<1>, flip done : UInt<1>}, flip decode : {mStatusEn : UInt<1>, mieEn : UInt<1>, mcauseEn : UInt<1>, source : UInt<2>, dSel : UInt<1>, imm : UInt<1>, eOp : UInt<1>, eBreak : UInt<1>, mRet : UInt<1>}, flip memCmd : UInt<1>, flip memMisaligned : UInt<1>, flip state : {flip newIrq : UInt<1>, trapTaken : UInt<1>, pendingIrq : UInt<1>}, flip rf : {readData : UInt<1>, flip writeData : UInt<1>}, flip dataIn : UInt<1>, dataOut : UInt<1>, flip timerInterrupt : UInt<1>}
    
    reg mStatusMie : UInt<1>, clock @[Csr.scala 15:23]
    reg mStatusMpie : UInt<1>, clock @[Csr.scala 16:24]
    reg mieMtie : UInt<1>, clock @[Csr.scala 17:20]
    node _T = and(io.count.count2, mStatusMie) @[Csr.scala 18:41]
    reg mStatus : UInt<1>, clock @[Csr.scala 18:24]
    mStatus <= _T @[Csr.scala 18:24]
    reg mCause3_0 : UInt<4>, clock @[Csr.scala 19:22]
    reg mCause31 : UInt<1>, clock @[Csr.scala 20:21]
    node _T_1 = bits(mCause3_0, 0, 0) @[Csr.scala 22:49]
    node _T_2 = mux(io.count.done, mCause31, UInt<1>("h00")) @[Csr.scala 22:57]
    node mCause = mux(io.count.count0To3, _T_1, _T_2) @[Csr.scala 22:19]
    node _T_3 = and(io.decode.mStatusEn, io.count.enabled) @[Csr.scala 24:38]
    node _T_4 = and(_T_3, mStatus) @[Csr.scala 24:58]
    node _T_5 = bits(io.rf.readData, 0, 0) @[Csr.scala 25:26]
    node _T_6 = or(_T_4, _T_5) @[Csr.scala 24:70]
    node _T_7 = and(io.decode.mcauseEn, io.count.enabled) @[Csr.scala 26:25]
    node _T_8 = bits(mCause, 0, 0) @[Csr.scala 26:61]
    node _T_9 = and(_T_7, _T_8) @[Csr.scala 26:45]
    node csrOut = or(_T_6, _T_9) @[Csr.scala 25:29]
    io.dataOut <= csrOut @[Csr.scala 28:14]
    node _T_10 = or(csrOut, io.dataIn) @[Csr.scala 32:30]
    node _T_11 = eq(io.dataIn, UInt<1>("h00")) @[Csr.scala 33:32]
    node _T_12 = and(csrOut, _T_11) @[Csr.scala 33:30]
    node _T_13 = eq(UInt<2>("h02"), io.decode.source) @[Mux.scala 80:60]
    node _T_14 = mux(_T_13, _T_10, io.dataIn) @[Mux.scala 80:57]
    node _T_15 = eq(UInt<2>("h03"), io.decode.source) @[Mux.scala 80:60]
    node _T_16 = mux(_T_15, _T_12, _T_14) @[Mux.scala 80:57]
    node _T_17 = eq(UInt<2>("h00"), io.decode.source) @[Mux.scala 80:60]
    node csrIn = mux(_T_17, csrOut, _T_16) @[Mux.scala 80:57]
    io.rf.writeData <= csrIn @[Csr.scala 37:19]
    node _T_18 = and(io.timerInterrupt, mStatusMie) @[Csr.scala 39:36]
    node timerIrq = and(_T_18, mieMtie) @[Csr.scala 39:50]
    reg REG : UInt<1>, clock @[Csr.scala 41:30]
    REG <= timerIrq @[Csr.scala 41:30]
    node _T_19 = eq(REG, UInt<1>("h00")) @[Csr.scala 41:22]
    node _T_20 = and(_T_19, timerIrq) @[Csr.scala 41:41]
    io.state.newIrq <= _T_20 @[Csr.scala 41:19]
    node _T_21 = and(io.decode.mStatusEn, io.count.count3) @[Csr.scala 43:28]
    when _T_21 : @[Csr.scala 43:48]
      mStatusMie <= io.dataIn @[Csr.scala 44:16]
      skip @[Csr.scala 43:48]
    node _T_22 = and(io.decode.mieEn, io.count.count7) @[Csr.scala 47:24]
    when _T_22 : @[Csr.scala 47:44]
      mieMtie <= io.dataIn @[Csr.scala 48:13]
      skip @[Csr.scala 47:44]
    when io.decode.mRet : @[Csr.scala 51:24]
      mStatusMie <= mStatusMpie @[Csr.scala 52:16]
      skip @[Csr.scala 51:24]
    when io.state.trapTaken : @[Csr.scala 55:28]
      mStatusMpie <= mStatusMie @[Csr.scala 56:17]
      mStatusMie <= UInt<1>("h00") @[Csr.scala 57:16]
      mCause31 <= io.state.pendingIrq @[Csr.scala 58:14]
      when io.state.pendingIrq : @[Csr.scala 59:31]
        mCause3_0 <= UInt<3>("h07") @[Csr.scala 60:17]
        skip @[Csr.scala 59:31]
      else : @[Csr.scala 61:32]
        when io.decode.eOp : @[Csr.scala 61:32]
          node _T_23 = eq(io.decode.eBreak, UInt<1>("h00")) @[Csr.scala 62:21]
          node _T_24 = cat(_T_23, UInt<3>("h03")) @[Csr.scala 62:40]
          mCause3_0 <= _T_24 @[Csr.scala 62:17]
          skip @[Csr.scala 61:32]
        else : @[Csr.scala 63:35]
          when io.memMisaligned : @[Csr.scala 63:35]
            node _T_25 = cat(UInt<2>("h01"), io.memCmd) @[Csr.scala 64:33]
            node _T_26 = cat(_T_25, UInt<1>("h00")) @[Csr.scala 64:46]
            mCause3_0 <= _T_26 @[Csr.scala 64:17]
            skip @[Csr.scala 63:35]
          else : @[Csr.scala 65:18]
            mCause3_0 <= UInt<1>("h00") @[Csr.scala 66:17]
            skip @[Csr.scala 65:18]
      skip @[Csr.scala 55:28]
    node _T_27 = and(io.decode.mcauseEn, io.count.enabled) @[Csr.scala 70:27]
    when _T_27 : @[Csr.scala 70:48]
      when io.count.count0To3 : @[Csr.scala 71:30]
        node _T_28 = bits(mCause3_0, 3, 1) @[Csr.scala 72:38]
        node _T_29 = cat(csrIn, _T_28) @[Csr.scala 72:26]
        mCause3_0 <= _T_29 @[Csr.scala 72:17]
        skip @[Csr.scala 71:30]
      when io.count.done : @[Csr.scala 74:25]
        mCause3_0 <= csrIn @[Csr.scala 75:17]
        skip @[Csr.scala 74:25]
      skip @[Csr.scala 70:48]
    
  module ServTop : 
    input clock : Clock
    input reset : Reset
    output io : {flip timerInterrupt : UInt<1>, flip rf : {flip writeRequest : UInt<1>, flip readRequest : UInt<1>, ready : UInt<1>, ports : {write0 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, write1 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, read0 : {flip addr : UInt<6>, data : UInt<1>}, read1 : {flip addr : UInt<6>, data : UInt<1>}}}, ibus : {adr : UInt<32>, cyc : UInt<1>, flip rdt : UInt<32>, flip ack : UInt<1>}, dbus : {adr : UInt<32>, cyc : UInt<1>, flip rdt : UInt<32>, flip ack : UInt<1>, dat : UInt<32>, sel : UInt<4>, we : UInt<1>}}
    
    inst state of State @[ServTop.scala 15:21]
    state.clock <= clock
    state.reset <= reset
    inst decode of Decode @[ServTop.scala 16:22]
    decode.clock <= clock
    decode.reset <= reset
    inst bufreg of BufReg @[ServTop.scala 17:22]
    bufreg.clock <= clock
    bufreg.reset <= reset
    inst control of Control @[ServTop.scala 18:23]
    control.clock <= clock
    control.reset <= reset
    inst alu of Alu @[ServTop.scala 19:19]
    alu.clock <= clock
    alu.reset <= reset
    inst rfInterface of RegisterFileInterface @[ServTop.scala 20:27]
    rfInterface.clock <= clock
    rfInterface.reset <= reset
    inst mem of MemoryInterface @[ServTop.scala 21:19]
    mem.clock <= clock
    mem.reset <= reset
    io.dbus.adr <= bufreg.io.dataBusAddress @[ServTop.scala 25:15]
    io.dbus.cyc <= state.io.dbus.cyc @[ServTop.scala 26:15]
    io.dbus.dat <= mem.io.dbus.dat @[ServTop.scala 27:15]
    io.dbus.sel <= mem.io.dbus.sel @[ServTop.scala 28:15]
    io.dbus.we <= decode.io.mem.cmd @[ServTop.scala 29:14]
    mem.io.dbus.rdt <= io.dbus.rdt @[ServTop.scala 30:19]
    state.io.dbus.ack <= io.dbus.ack @[ServTop.scala 31:21]
    mem.io.dbus.ack <= io.dbus.ack @[ServTop.scala 32:19]
    io.ibus.adr <= control.io.ibus.address @[ServTop.scala 36:15]
    io.ibus.cyc <= control.io.ibus.cyc @[ServTop.scala 37:15]
    state.io.ibus.ack <= io.ibus.ack @[ServTop.scala 38:21]
    control.io.ibus.ack <= io.ibus.ack @[ServTop.scala 39:23]
    node _T = and(io.ibus.cyc, io.ibus.ack) @[ServTop.scala 40:37]
    decode.io.top.wbEn <= _T @[ServTop.scala 40:22]
    decode.io.top.wbRdt <= io.ibus.rdt @[ServTop.scala 41:23]
    io.rf.writeRequest <= state.io.ram.writeRequest @[ServTop.scala 44:22]
    io.rf.readRequest <= state.io.ram.readRequest @[ServTop.scala 45:21]
    state.io.ram.ready <= io.rf.ready @[ServTop.scala 46:22]
    state.io.decode.rdOp <= decode.io.state.rdOp @[ServTop.scala 56:19]
    state.io.decode.sltOp <= decode.io.state.sltOp @[ServTop.scala 56:19]
    state.io.decode.shiftOp <= decode.io.state.shiftOp @[ServTop.scala 56:19]
    state.io.decode.memOp <= decode.io.state.memOp @[ServTop.scala 56:19]
    state.io.decode.branchOp <= decode.io.state.branchOp @[ServTop.scala 56:19]
    state.io.decode.eBreak <= decode.io.state.eBreak @[ServTop.scala 56:19]
    state.io.decode.eOp <= decode.io.state.eOp @[ServTop.scala 56:19]
    state.io.decode.takeBranch <= decode.io.state.takeBranch @[ServTop.scala 56:19]
    bufreg.io.state.hold <= state.io.bufreg.hold @[ServTop.scala 57:19]
    control.io.state.trap <= state.io.control.trap @[ServTop.scala 58:20]
    control.io.state.jump <= state.io.control.jump @[ServTop.scala 58:20]
    control.io.state.pcEnable <= state.io.control.pcEnable @[ServTop.scala 58:20]
    state.io.alu.shiftDone <= alu.io.state.shiftDone @[ServTop.scala 59:16]
    alu.io.state.shiftAmountEnable <= state.io.alu.shiftAmountEnable @[ServTop.scala 59:16]
    state.io.mem.misaligned <= mem.io.state.misaligned @[ServTop.scala 60:16]
    mem.io.state.byteCount <= state.io.mem.byteCount @[ServTop.scala 60:16]
    node _T_1 = bits(bufreg.io.lsb, 1, 1) @[ServTop.scala 61:23]
    state.io.lsb1 <= _T_1 @[ServTop.scala 61:17]
    decode.io.count.done <= state.io.count.done @[ServTop.scala 63:19]
    decode.io.count.count7 <= state.io.count.count7 @[ServTop.scala 63:19]
    decode.io.count.count3 <= state.io.count.count3 @[ServTop.scala 63:19]
    decode.io.count.count2 <= state.io.count.count2 @[ServTop.scala 63:19]
    decode.io.count.count1 <= state.io.count.count1 @[ServTop.scala 63:19]
    decode.io.count.count12To31 <= state.io.count.count12To31 @[ServTop.scala 63:19]
    decode.io.count.count0To3 <= state.io.count.count0To3 @[ServTop.scala 63:19]
    decode.io.count.count0 <= state.io.count.count0 @[ServTop.scala 63:19]
    decode.io.count.init <= state.io.count.init @[ServTop.scala 63:19]
    decode.io.count.enabled <= state.io.count.enabled @[ServTop.scala 63:19]
    bufreg.io.decode.clearLsb <= decode.io.bufreg.clearLsb @[ServTop.scala 64:20]
    bufreg.io.decode.immEn <= decode.io.bufreg.immEn @[ServTop.scala 64:20]
    bufreg.io.decode.rs1En <= decode.io.bufreg.rs1En @[ServTop.scala 64:20]
    bufreg.io.decode.loop <= decode.io.bufreg.loop @[ServTop.scala 64:20]
    control.io.decode.mRet <= decode.io.control.mRet @[ServTop.scala 65:21]
    control.io.decode.pcRel <= decode.io.control.pcRel @[ServTop.scala 65:21]
    control.io.decode.uType <= decode.io.control.uType @[ServTop.scala 65:21]
    control.io.decode.jalOrJalr <= decode.io.control.jalOrJalr @[ServTop.scala 65:21]
    decode.io.alu.cmpResult <= alu.io.decode.cmpResult @[ServTop.scala 66:17]
    alu.io.decode.opBIsRS2 <= decode.io.alu.opBIsRS2 @[ServTop.scala 66:17]
    alu.io.decode.rdSelect <= decode.io.alu.rdSelect @[ServTop.scala 66:17]
    alu.io.decode.shiftRight <= decode.io.alu.shiftRight @[ServTop.scala 66:17]
    alu.io.decode.shiftSigned <= decode.io.alu.shiftSigned @[ServTop.scala 66:17]
    alu.io.decode.cmpUnsigned <= decode.io.alu.cmpUnsigned @[ServTop.scala 66:17]
    alu.io.decode.cmpEqual <= decode.io.alu.cmpEqual @[ServTop.scala 66:17]
    alu.io.decode.boolOp <= decode.io.alu.boolOp @[ServTop.scala 66:17]
    alu.io.decode.doSubtract <= decode.io.alu.doSubtract @[ServTop.scala 66:17]
    rfInterface.io.decode.csrEnable <= decode.io.rf.csrEnable @[ServTop.scala 67:16]
    rfInterface.io.decode.csrAddress <= decode.io.rf.csrAddress @[ServTop.scala 67:16]
    rfInterface.io.decode.rs2Address <= decode.io.rf.rs2Address @[ServTop.scala 67:16]
    rfInterface.io.decode.rs1Address <= decode.io.rf.rs1Address @[ServTop.scala 67:16]
    rfInterface.io.decode.rdAddress <= decode.io.rf.rdAddress @[ServTop.scala 67:16]
    mem.io.decode.cmd <= decode.io.mem.cmd @[ServTop.scala 68:17]
    mem.io.decode.half <= decode.io.mem.half @[ServTop.scala 68:17]
    mem.io.decode.word <= decode.io.mem.word @[ServTop.scala 68:17]
    mem.io.decode.signed <= decode.io.mem.signed @[ServTop.scala 68:17]
    mem.io.decode.memOp <= decode.io.mem.memOp @[ServTop.scala 68:17]
    bufreg.io.count.done <= state.io.count.done @[ServTop.scala 70:19]
    bufreg.io.count.count7 <= state.io.count.count7 @[ServTop.scala 70:19]
    bufreg.io.count.count3 <= state.io.count.count3 @[ServTop.scala 70:19]
    bufreg.io.count.count2 <= state.io.count.count2 @[ServTop.scala 70:19]
    bufreg.io.count.count1 <= state.io.count.count1 @[ServTop.scala 70:19]
    bufreg.io.count.count12To31 <= state.io.count.count12To31 @[ServTop.scala 70:19]
    bufreg.io.count.count0To3 <= state.io.count.count0To3 @[ServTop.scala 70:19]
    bufreg.io.count.count0 <= state.io.count.count0 @[ServTop.scala 70:19]
    bufreg.io.count.init <= state.io.count.init @[ServTop.scala 70:19]
    bufreg.io.count.enabled <= state.io.count.enabled @[ServTop.scala 70:19]
    bufreg.io.imm <= decode.io.top.imm @[ServTop.scala 71:17]
    bufreg.io.rs1 <= rfInterface.io.rs1Data @[ServTop.scala 72:17]
    control.io.count.done <= state.io.count.done @[ServTop.scala 74:20]
    control.io.count.count7 <= state.io.count.count7 @[ServTop.scala 74:20]
    control.io.count.count3 <= state.io.count.count3 @[ServTop.scala 74:20]
    control.io.count.count2 <= state.io.count.count2 @[ServTop.scala 74:20]
    control.io.count.count1 <= state.io.count.count1 @[ServTop.scala 74:20]
    control.io.count.count12To31 <= state.io.count.count12To31 @[ServTop.scala 74:20]
    control.io.count.count0To3 <= state.io.count.count0To3 @[ServTop.scala 74:20]
    control.io.count.count0 <= state.io.count.count0 @[ServTop.scala 74:20]
    control.io.count.init <= state.io.count.init @[ServTop.scala 74:20]
    control.io.count.enabled <= state.io.count.enabled @[ServTop.scala 74:20]
    control.io.data.imm <= decode.io.top.imm @[ServTop.scala 75:23]
    control.io.data.buf <= bufreg.io.dataOut @[ServTop.scala 76:23]
    control.io.data.csrPc <= rfInterface.io.trap.csrPC @[ServTop.scala 78:25]
    rfInterface.io.trap.badPC <= control.io.data.badPc @[ServTop.scala 79:29]
    alu.io.count.done <= state.io.count.done @[ServTop.scala 82:16]
    alu.io.count.count7 <= state.io.count.count7 @[ServTop.scala 82:16]
    alu.io.count.count3 <= state.io.count.count3 @[ServTop.scala 82:16]
    alu.io.count.count2 <= state.io.count.count2 @[ServTop.scala 82:16]
    alu.io.count.count1 <= state.io.count.count1 @[ServTop.scala 82:16]
    alu.io.count.count12To31 <= state.io.count.count12To31 @[ServTop.scala 82:16]
    alu.io.count.count0To3 <= state.io.count.count0To3 @[ServTop.scala 82:16]
    alu.io.count.count0 <= state.io.count.count0 @[ServTop.scala 82:16]
    alu.io.count.init <= state.io.count.init @[ServTop.scala 82:16]
    alu.io.count.enabled <= state.io.count.enabled @[ServTop.scala 82:16]
    alu.io.data.rs1 <= rfInterface.io.rs1Data @[ServTop.scala 83:19]
    alu.io.data.rs2 <= rfInterface.io.rs2Data @[ServTop.scala 84:19]
    alu.io.data.imm <= decode.io.top.imm @[ServTop.scala 85:19]
    alu.io.data.buffer <= bufreg.io.dataOut @[ServTop.scala 86:22]
    rfInterface.io.rf.read1.data <= io.rf.ports.read1.data @[ServTop.scala 88:21]
    io.rf.ports.read1.addr <= rfInterface.io.rf.read1.addr @[ServTop.scala 88:21]
    rfInterface.io.rf.read0.data <= io.rf.ports.read0.data @[ServTop.scala 88:21]
    io.rf.ports.read0.addr <= rfInterface.io.rf.read0.addr @[ServTop.scala 88:21]
    io.rf.ports.write1.data <= rfInterface.io.rf.write1.data @[ServTop.scala 88:21]
    io.rf.ports.write1.enable <= rfInterface.io.rf.write1.enable @[ServTop.scala 88:21]
    io.rf.ports.write1.addr <= rfInterface.io.rf.write1.addr @[ServTop.scala 88:21]
    io.rf.ports.write0.data <= rfInterface.io.rf.write0.data @[ServTop.scala 88:21]
    io.rf.ports.write0.enable <= rfInterface.io.rf.write0.enable @[ServTop.scala 88:21]
    io.rf.ports.write0.addr <= rfInterface.io.rf.write0.addr @[ServTop.scala 88:21]
    rfInterface.io.rd.writeEnable <= state.io.rf.writeEnable @[ServTop.scala 90:33]
    rfInterface.io.rd.controlData <= control.io.data.rd @[ServTop.scala 91:33]
    rfInterface.io.rd.aluData <= alu.io.data.rd @[ServTop.scala 92:29]
    rfInterface.io.rd.aluEnable <= decode.io.top.rdAluEn @[ServTop.scala 93:31]
    rfInterface.io.rd.csrEnable <= decode.io.top.rdCsrEn @[ServTop.scala 94:31]
    rfInterface.io.rd.memData <= mem.io.rd @[ServTop.scala 95:29]
    rfInterface.io.trap.doTrap <= state.io.control.trap @[ServTop.scala 97:30]
    rfInterface.io.trap.mRet <= decode.io.control.mRet @[ServTop.scala 98:28]
    node _T_2 = bits(io.ibus.adr, 0, 0) @[ServTop.scala 99:42]
    rfInterface.io.trap.mePC <= _T_2 @[ServTop.scala 99:28]
    rfInterface.io.trap.memMisaligned <= mem.io.state.misaligned @[ServTop.scala 100:37]
    rfInterface.io.trap.bufRegData <= bufreg.io.dataOut @[ServTop.scala 101:34]
    mem.io.enabled <= state.io.count.enabled @[ServTop.scala 103:18]
    mem.io.lsb <= bufreg.io.lsb @[ServTop.scala 104:14]
    mem.io.rs2 <= rfInterface.io.rs2Data @[ServTop.scala 105:14]
    inst csr of Csr @[ServTop.scala 108:21]
    csr.clock <= clock
    csr.reset <= reset
    csr.io.count.done <= state.io.count.done @[ServTop.scala 109:18]
    csr.io.count.count7 <= state.io.count.count7 @[ServTop.scala 109:18]
    csr.io.count.count3 <= state.io.count.count3 @[ServTop.scala 109:18]
    csr.io.count.count2 <= state.io.count.count2 @[ServTop.scala 109:18]
    csr.io.count.count1 <= state.io.count.count1 @[ServTop.scala 109:18]
    csr.io.count.count12To31 <= state.io.count.count12To31 @[ServTop.scala 109:18]
    csr.io.count.count0To3 <= state.io.count.count0To3 @[ServTop.scala 109:18]
    csr.io.count.count0 <= state.io.count.count0 @[ServTop.scala 109:18]
    csr.io.count.init <= state.io.count.init @[ServTop.scala 109:18]
    csr.io.count.enabled <= state.io.count.enabled @[ServTop.scala 109:18]
    csr.io.timerInterrupt <= io.timerInterrupt @[ServTop.scala 110:27]
    node _csr_io_dataIn_T = mux(decode.io.csr.dSel, decode.io.csr.imm, rfInterface.io.rs1Data) @[ServTop.scala 111:25]
    csr.io.dataIn <= _csr_io_dataIn_T @[ServTop.scala 111:19]
    csr.io.memCmd <= io.dbus.we @[ServTop.scala 112:19]
    csr.io.memMisaligned <= mem.io.state.misaligned @[ServTop.scala 113:26]
    csr.io.state.pendingIrq <= state.io.csr.pendingIrq @[ServTop.scala 114:18]
    csr.io.state.trapTaken <= state.io.csr.trapTaken @[ServTop.scala 114:18]
    state.io.csr.newIrq <= csr.io.state.newIrq @[ServTop.scala 114:18]
    csr.io.decode.mRet <= decode.io.csr.mRet @[ServTop.scala 115:19]
    csr.io.decode.eBreak <= decode.io.csr.eBreak @[ServTop.scala 115:19]
    csr.io.decode.eOp <= decode.io.csr.eOp @[ServTop.scala 115:19]
    csr.io.decode.imm <= decode.io.csr.imm @[ServTop.scala 115:19]
    csr.io.decode.dSel <= decode.io.csr.dSel @[ServTop.scala 115:19]
    csr.io.decode.source <= decode.io.csr.source @[ServTop.scala 115:19]
    csr.io.decode.mcauseEn <= decode.io.csr.mcauseEn @[ServTop.scala 115:19]
    csr.io.decode.mieEn <= decode.io.csr.mieEn @[ServTop.scala 115:19]
    csr.io.decode.mStatusEn <= decode.io.csr.mStatusEn @[ServTop.scala 115:19]
    rfInterface.io.rd.csrData <= csr.io.dataOut @[ServTop.scala 116:31]
    rfInterface.io.csr.writeData <= csr.io.rf.writeData @[ServTop.scala 117:24]
    csr.io.rf.readData <= rfInterface.io.csr.readData @[ServTop.scala 117:24]
    
  module RamInterface : 
    input clock : Clock
    input reset : Reset
    output io : {flip ram : {flip writeAddr : UInt<10>, flip writeData : UInt<2>, flip writeEnable : UInt<1>, flip readAddr : UInt<10>, readData : UInt<2>}, rf : {flip writeRequest : UInt<1>, flip readRequest : UInt<1>, ready : UInt<1>, ports : {write0 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, write1 : {flip addr : UInt<6>, flip enable : UInt<1>, flip data : UInt<1>}, read0 : {flip addr : UInt<6>, data : UInt<1>}, read1 : {flip addr : UInt<6>, data : UInt<1>}}}}
    
    reg readRequestBuffer : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Ram.scala 23:34]
    readRequestBuffer <= io.rf.readRequest @[Ram.scala 23:34]
    reg rgnt : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Ram.scala 24:21]
    rgnt <= readRequestBuffer @[Ram.scala 24:21]
    node _T = or(rgnt, io.rf.writeRequest) @[Ram.scala 25:23]
    io.rf.ready <= _T @[Ram.scala 25:15]
    reg writeCount : UInt<5>, clock with : (reset => (reset, UInt<5>("h00"))) @[Ram.scala 28:27]
    reg writeGo : UInt<1>, clock @[Ram.scala 29:20]
    reg writeData0Buffer : UInt<1>, clock @[Ram.scala 30:29]
    reg writeData1Buffer : UInt<2>, clock @[Ram.scala 31:29]
    reg writeEnable0Buffer : UInt<1>, clock @[Ram.scala 32:35]
    writeEnable0Buffer <= io.rf.ports.write0.enable @[Ram.scala 32:35]
    reg writeEnable1Buffer : UInt<1>, clock @[Ram.scala 33:35]
    writeEnable1Buffer <= io.rf.ports.write1.enable @[Ram.scala 33:35]
    node _T_1 = or(io.rf.writeRequest, rgnt) @[Ram.scala 34:55]
    reg writeRequestBuffer : UInt<1>, clock @[Ram.scala 34:35]
    writeRequestBuffer <= _T_1 @[Ram.scala 34:35]
    node _T_2 = bits(writeCount, 0, 0) @[Ram.scala 37:17]
    node _T_3 = eq(_T_2, UInt<1>("h00")) @[Ram.scala 37:6]
    node _T_4 = bits(writeCount, 0, 0) @[Ram.scala 37:32]
    node _T_5 = cat(io.rf.ports.write0.data, writeData0Buffer) @[Ram.scala 42:86]
    node _T_6 = mux(_T_4, writeData1Buffer, _T_5) @[Ram.scala 42:26]
    io.ram.writeData <= _T_6 @[Ram.scala 42:20]
    node writeAddress = mux(_T_4, io.rf.ports.write1.addr, io.rf.ports.write0.addr) @[Ram.scala 43:25]
    node _T_7 = head(writeCount, 4) @[package.scala 18:19]
    node _T_8 = tail(writeCount, 4) @[package.scala 18:36]
    node _T_9 = cat(writeAddress, _T_7) @[Ram.scala 44:36]
    io.ram.writeAddr <= _T_9 @[Ram.scala 44:20]
    node _T_10 = and(_T_3, writeEnable0Buffer) @[Ram.scala 45:54]
    node _T_11 = and(_T_4, writeEnable1Buffer) @[Ram.scala 45:97]
    node _T_12 = or(_T_10, _T_11) @[Ram.scala 45:77]
    node _T_13 = and(writeGo, _T_12) @[Ram.scala 45:33]
    io.ram.writeEnable <= _T_13 @[Ram.scala 45:22]
    node _T_14 = head(writeData0Buffer, 0) @[package.scala 18:19]
    node _T_15 = tail(writeData0Buffer, 0) @[package.scala 18:36]
    node _T_16 = head(_T_15, 0) @[package.scala 18:19]
    node _T_17 = tail(_T_15, 0) @[package.scala 18:36]
    node _T_18 = cat(io.rf.ports.write0.data, _T_16) @[Ram.scala 47:47]
    writeData0Buffer <= _T_18 @[Ram.scala 47:20]
    node _T_19 = head(writeData1Buffer, 0) @[package.scala 18:19]
    node _T_20 = tail(writeData1Buffer, 0) @[package.scala 18:36]
    node _T_21 = head(_T_20, 1) @[package.scala 18:19]
    node _T_22 = tail(_T_20, 1) @[package.scala 18:36]
    node _T_23 = cat(io.rf.ports.write1.data, _T_21) @[Ram.scala 48:47]
    writeData1Buffer <= _T_23 @[Ram.scala 48:20]
    when writeGo : @[Ram.scala 50:17]
      node _T_24 = add(writeCount, UInt<1>("h01")) @[Ram.scala 50:44]
      node _T_25 = tail(_T_24, 1) @[Ram.scala 50:44]
      writeCount <= _T_25 @[Ram.scala 50:30]
      skip @[Ram.scala 50:17]
    when writeRequestBuffer : @[Ram.scala 51:28]
      writeGo <= UInt<1>("h01") @[Ram.scala 51:38]
      skip @[Ram.scala 51:28]
    node _T_26 = eq(writeCount, UInt<5>("h01f")) @[Ram.scala 52:19]
    when _T_26 : @[Ram.scala 52:35]
      writeGo <= UInt<1>("h00") @[Ram.scala 52:45]
      skip @[Ram.scala 52:35]
    reg readCount : UInt<5>, clock @[Ram.scala 55:22]
    node _T_27 = head(readCount, 4) @[package.scala 18:19]
    node _T_28 = tail(readCount, 4) @[package.scala 18:36]
    node readTrigger0 = eq(_T_28, UInt<1>("h01")) @[Ram.scala 56:53]
    reg readTrigger1 : UInt<1>, clock @[Ram.scala 57:29]
    readTrigger1 <= readTrigger0 @[Ram.scala 57:29]
    node readAddress = mux(readTrigger0, io.rf.ports.read1.addr, io.rf.ports.read0.addr) @[Ram.scala 58:24]
    node _T_29 = head(readCount, 4) @[package.scala 18:19]
    node _T_30 = tail(readCount, 4) @[package.scala 18:36]
    node _T_31 = cat(readAddress, _T_29) @[Ram.scala 60:34]
    io.ram.readAddr <= _T_31 @[Ram.scala 60:19]
    reg readData0Buffer : UInt<2>, clock @[Ram.scala 62:28]
    node _T_32 = head(readData0Buffer, 1) @[package.scala 18:19]
    node _T_33 = tail(readData0Buffer, 1) @[package.scala 18:36]
    readData0Buffer <= _T_32 @[Ram.scala 63:19]
    when readTrigger0 : @[Ram.scala 64:22]
      readData0Buffer <= io.ram.readData @[Ram.scala 64:40]
      skip @[Ram.scala 64:22]
    reg readData1Buffer : UInt<1>, clock @[Ram.scala 65:28]
    node _T_34 = head(readData1Buffer, 0) @[package.scala 18:19]
    node _T_35 = tail(readData1Buffer, 0) @[package.scala 18:36]
    readData1Buffer <= _T_34 @[Ram.scala 66:19]
    when readTrigger1 : @[Ram.scala 67:22]
      node _T_36 = head(io.ram.readData, 1) @[package.scala 18:19]
      node _T_37 = tail(io.ram.readData, 1) @[package.scala 18:36]
      readData1Buffer <= _T_36 @[Ram.scala 67:40]
      skip @[Ram.scala 67:22]
    node _T_38 = bits(readData0Buffer, 0, 0) @[Ram.scala 69:44]
    io.rf.ports.read0.data <= _T_38 @[Ram.scala 69:26]
    node _T_39 = bits(io.ram.readData, 0, 0) @[Ram.scala 70:62]
    node _T_40 = bits(readData1Buffer, 0, 0) @[Ram.scala 70:82]
    node _T_41 = mux(readTrigger1, _T_39, _T_40) @[Ram.scala 70:32]
    io.rf.ports.read1.data <= _T_41 @[Ram.scala 70:26]
    node _T_42 = add(readCount, UInt<1>("h01")) @[Ram.scala 72:26]
    node _T_43 = tail(_T_42, 1) @[Ram.scala 72:26]
    readCount <= _T_43 @[Ram.scala 72:13]
    when io.rf.readRequest : @[Ram.scala 73:27]
      readCount <= UInt<1>("h00") @[Ram.scala 73:39]
      skip @[Ram.scala 73:27]
    
  module Ram : 
    input clock : Clock
    input reset : Reset
    output io : {flip writeAddr : UInt<10>, flip writeData : UInt<2>, flip writeEnable : UInt<1>, flip readAddr : UInt<10>, readData : UInt<2>}
    
    smem memory : UInt<2>[576], undefined @[Ram.scala 79:27]
    when io.writeEnable : @[Ram.scala 80:24]
      write mport MPORT = memory[io.writeAddr], clock
      MPORT <= io.writeData
      skip @[Ram.scala 80:24]
    read mport MPORT_1 = memory[io.readAddr], clock @[Ram.scala 81:29]
    io.readData <= MPORT_1 @[Ram.scala 81:15]
    
  module ServTopWithRam : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip timerInterrupt : UInt<1>, ibus : {adr : UInt<32>, cyc : UInt<1>, flip rdt : UInt<32>, flip ack : UInt<1>}, dbus : {adr : UInt<32>, cyc : UInt<1>, flip rdt : UInt<32>, flip ack : UInt<1>, dat : UInt<32>, sel : UInt<4>, we : UInt<1>}}
    
    inst top of ServTop @[ServTopWithRam.scala 17:19]
    top.clock <= clock
    top.reset <= reset
    inst ramInterface of RamInterface @[ServTopWithRam.scala 18:28]
    ramInterface.clock <= clock
    ramInterface.reset <= reset
    inst ram of Ram @[ServTopWithRam.scala 20:19]
    ram.clock <= clock
    ram.reset <= reset
    top.io.timerInterrupt <= io.timerInterrupt @[ServTopWithRam.scala 22:25]
    top.io.ibus.ack <= io.ibus.ack @[ServTopWithRam.scala 23:15]
    top.io.ibus.rdt <= io.ibus.rdt @[ServTopWithRam.scala 23:15]
    io.ibus.cyc <= top.io.ibus.cyc @[ServTopWithRam.scala 23:15]
    io.ibus.adr <= top.io.ibus.adr @[ServTopWithRam.scala 23:15]
    io.dbus.we <= top.io.dbus.we @[ServTopWithRam.scala 24:15]
    io.dbus.sel <= top.io.dbus.sel @[ServTopWithRam.scala 24:15]
    io.dbus.dat <= top.io.dbus.dat @[ServTopWithRam.scala 24:15]
    top.io.dbus.ack <= io.dbus.ack @[ServTopWithRam.scala 24:15]
    top.io.dbus.rdt <= io.dbus.rdt @[ServTopWithRam.scala 24:15]
    io.dbus.cyc <= top.io.dbus.cyc @[ServTopWithRam.scala 24:15]
    io.dbus.adr <= top.io.dbus.adr @[ServTopWithRam.scala 24:15]
    top.io.rf.ports.read1.data <= ramInterface.io.rf.ports.read1.data @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.read1.addr <= top.io.rf.ports.read1.addr @[ServTopWithRam.scala 26:13]
    top.io.rf.ports.read0.data <= ramInterface.io.rf.ports.read0.data @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.read0.addr <= top.io.rf.ports.read0.addr @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write1.data <= top.io.rf.ports.write1.data @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write1.enable <= top.io.rf.ports.write1.enable @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write1.addr <= top.io.rf.ports.write1.addr @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write0.data <= top.io.rf.ports.write0.data @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write0.enable <= top.io.rf.ports.write0.enable @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.ports.write0.addr <= top.io.rf.ports.write0.addr @[ServTopWithRam.scala 26:13]
    top.io.rf.ready <= ramInterface.io.rf.ready @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.readRequest <= top.io.rf.readRequest @[ServTopWithRam.scala 26:13]
    ramInterface.io.rf.writeRequest <= top.io.rf.writeRequest @[ServTopWithRam.scala 26:13]
    ramInterface.io.ram.readData <= ram.io.readData @[ServTopWithRam.scala 27:10]
    ram.io.readAddr <= ramInterface.io.ram.readAddr @[ServTopWithRam.scala 27:10]
    ram.io.writeEnable <= ramInterface.io.ram.writeEnable @[ServTopWithRam.scala 27:10]
    ram.io.writeData <= ramInterface.io.ram.writeData @[ServTopWithRam.scala 27:10]
    ram.io.writeAddr <= ramInterface.io.ram.writeAddr @[ServTopWithRam.scala 27:10]
    
